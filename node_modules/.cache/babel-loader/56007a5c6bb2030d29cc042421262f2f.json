{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (tasks, callback) {\n  callback = (0, _once2.default)(callback || _noop2.default);\n  if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n  if (!tasks.length) return callback();\n  var taskIndex = 0;\n\n  function nextTask(args) {\n    var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n    args.push((0, _onlyOnce2.default)(next));\n    task.apply(null, args);\n  }\n\n  function next(err\n  /*, ...args*/\n  ) {\n    if (err || taskIndex === tasks.length) {\n      return callback.apply(null, arguments);\n    }\n\n    nextTask((0, _slice2.default)(arguments, 1));\n  }\n\n  nextTask([]);\n};\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _slice = require('./internal/slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = exports['default'];\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */","map":null,"metadata":{},"sourceType":"script"}
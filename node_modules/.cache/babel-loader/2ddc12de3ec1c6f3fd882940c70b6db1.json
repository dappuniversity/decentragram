{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-utils'), require('web3-core-helpers'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/inherits'), require('web3-core-method'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/assertThisInitialized'), require('lodash/isFunction'), require('lodash/isObject'), require('eth-lib/lib/hash'), require('eth-lib/lib/rlp'), require('eth-lib/lib/bytes'), require('eth-lib/lib/account'), require('web3-core'), require('scrypt.js'), require('lodash/isString'), require('uuid'), require('randombytes'), require('pbkdf2'), require('browserify-cipher')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-utils', 'web3-core-helpers', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits', 'web3-core-method', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/assertThisInitialized', 'lodash/isFunction', 'lodash/isObject', 'eth-lib/lib/hash', 'eth-lib/lib/rlp', 'eth-lib/lib/bytes', 'eth-lib/lib/account', 'web3-core', 'scrypt.js', 'lodash/isString', 'uuid', 'randombytes', 'pbkdf2', 'browserify-cipher'], factory) : (global = global || self, factory(global.Web3EthAccounts = {}, global.Utils, global.web3CoreHelpers, global._classCallCheck, global._possibleConstructorReturn, global._getPrototypeOf, global._inherits, global.web3CoreMethod, global._regeneratorRuntime, global._asyncToGenerator, global._createClass, global._assertThisInitialized, global.isFunction, global.isObject, global.Hash, global.RLP, global.Bytes, global.EthLibAccount, global.web3Core, global.scryptsy, global.isString, global.uuid, global.randomBytes, global.pbkdf2, global.browserifyCipher));\n})(this, function (exports, Utils, web3CoreHelpers, _classCallCheck, _possibleConstructorReturn, _getPrototypeOf, _inherits, web3CoreMethod, _regeneratorRuntime, _asyncToGenerator, _createClass, _assertThisInitialized, isFunction, isObject, Hash, RLP, Bytes, EthLibAccount, web3Core, scryptsy, isString, uuid, randomBytes, pbkdf2, browserifyCipher) {\n  'use strict';\n\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  _assertThisInitialized = _assertThisInitialized && _assertThisInitialized.hasOwnProperty('default') ? _assertThisInitialized['default'] : _assertThisInitialized;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  Hash = Hash && Hash.hasOwnProperty('default') ? Hash['default'] : Hash;\n  RLP = RLP && RLP.hasOwnProperty('default') ? RLP['default'] : RLP;\n  Bytes = Bytes && Bytes.hasOwnProperty('default') ? Bytes['default'] : Bytes;\n  scryptsy = scryptsy && scryptsy.hasOwnProperty('default') ? scryptsy['default'] : scryptsy;\n  isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;\n  uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;\n  randomBytes = randomBytes && randomBytes.hasOwnProperty('default') ? randomBytes['default'] : randomBytes;\n\n  var MethodFactory = function (_AbstractMethodFactor) {\n    _inherits(MethodFactory, _AbstractMethodFactor);\n\n    function MethodFactory(utils, formatters) {\n      var _this;\n\n      _classCallCheck(this, MethodFactory);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MethodFactory).call(this, utils, formatters));\n      _this.methods = {\n        getChainId: web3CoreMethod.ChainIdMethod,\n        getGasPrice: web3CoreMethod.GetGasPriceMethod,\n        getTransactionCount: web3CoreMethod.GetTransactionCountMethod\n      };\n      return _this;\n    }\n\n    return MethodFactory;\n  }(web3CoreMethod.AbstractMethodFactory);\n\n  var Account = function () {\n    function Account(options) {\n      var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, Account);\n\n      this.address = options.address;\n      this.privateKey = options.privateKey;\n      this.accounts = accounts;\n    }\n\n    _createClass(Account, [{\n      key: \"signTransaction\",\n      value: function signTransaction(tx, callback) {\n        return this.accounts.signTransaction(tx, this.privateKey, callback);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(data) {\n        if (Utils.isHexStrict(data)) {\n          data = Utils.hexToBytes(data);\n        }\n\n        var messageBuffer = Buffer.from(data);\n        var preamble = \"\\x19Ethereum Signed Message:\\n\".concat(data.length);\n        var preambleBuffer = Buffer.from(preamble);\n        var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n        var hash = Hash.keccak256s(ethMessage);\n        var signature = EthLibAccount.sign(hash, this.privateKey);\n        var vrs = EthLibAccount.decodeSignature(signature);\n        return {\n          message: data,\n          messageHash: hash,\n          v: vrs[0],\n          r: vrs[1],\n          s: vrs[2],\n          signature: signature\n        };\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(password, options) {\n        return Account.fromPrivateKey(this.privateKey, this.accounts).toV3Keystore(password, options);\n      }\n    }, {\n      key: \"toV3Keystore\",\n      value: function toV3Keystore(password, options) {\n        options = options || {};\n        var salt = options.salt || randomBytes(32);\n        var iv = options.iv || randomBytes(16);\n        var derivedKey;\n        var kdf = options.kdf || 'scrypt';\n        var kdfparams = {\n          dklen: options.dklen || 32,\n          salt: salt.toString('hex')\n        };\n\n        if (kdf === 'pbkdf2') {\n          kdfparams.c = options.c || 262144;\n          kdfparams.prf = 'hmac-sha256';\n          derivedKey = pbkdf2.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n        } else if (kdf === 'scrypt') {\n          kdfparams.n = options.n || 8192;\n          kdfparams.r = options.r || 8;\n          kdfparams.p = options.p || 1;\n          derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else {\n          throw new Error('Unsupported kdf');\n        }\n\n        var cipher = browserifyCipher.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n        if (!cipher) {\n          throw new Error('Unsupported cipher');\n        }\n\n        var ciphertext = Buffer.concat([cipher.update(Buffer.from(this.privateKey.replace('0x', ''), 'hex')), cipher.final()]);\n        var mac = Utils.keccak256(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')])).replace('0x', '');\n        return {\n          version: 3,\n          id: uuid.v4({\n            random: options.uuid || randomBytes(16)\n          }),\n          address: this.address.toLowerCase().replace('0x', ''),\n          crypto: {\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n              iv: iv.toString('hex')\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf: kdf,\n            kdfparams: kdfparams,\n            mac: mac.toString('hex')\n          }\n        };\n      }\n    }], [{\n      key: \"from\",\n      value: function from(entropy) {\n        var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new Account(EthLibAccount.create(entropy || Utils.randomHex(32)), accounts);\n      }\n    }, {\n      key: \"fromPrivateKey\",\n      value: function fromPrivateKey(privateKey) {\n        var accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new Account(EthLibAccount.fromPrivate(privateKey), accounts);\n      }\n    }, {\n      key: \"fromV3Keystore\",\n      value: function fromV3Keystore(v3Keystore, password) {\n        var nonStrict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var accounts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        if (!isString(password)) {\n          throw new Error('No password given.');\n        }\n\n        var json = isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n        if (json.version !== 3) {\n          throw new Error('Not a valid V3 wallet');\n        }\n\n        var derivedKey;\n        var kdfparams;\n\n        if (json.crypto.kdf === 'scrypt') {\n          kdfparams = json.crypto.kdfparams;\n          derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else if (json.crypto.kdf === 'pbkdf2') {\n          kdfparams = json.crypto.kdfparams;\n\n          if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n          }\n\n          derivedKey = pbkdf2.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n        } else {\n          throw new Error('Unsupported key derivation scheme');\n        }\n\n        var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n        var mac = Utils.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n        if (mac !== json.crypto.mac) {\n          throw new Error('Key derivation failed - possibly wrong password');\n        }\n\n        var decipher = browserifyCipher.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n        var seed = \"0x\".concat(Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex'));\n        return Account.fromPrivateKey(seed, accounts);\n      }\n    }]);\n\n    return Account;\n  }();\n\n  var Wallet = function () {\n    function Wallet(utils, accountsModule) {\n      _classCallCheck(this, Wallet);\n\n      this.utils = utils;\n      this.accountsModule = accountsModule;\n      this.defaultKeyName = 'web3js_wallet';\n      this.accounts = {};\n      this.accountsIndex = 0;\n      return new Proxy(this, {\n        get: function get(target, name) {\n          if (target.accounts[name]) {\n            return target.accounts[name];\n          }\n\n          if (name === 'length') {\n            return target.accountsIndex;\n          }\n\n          return target[name];\n        }\n      });\n    }\n\n    _createClass(Wallet, [{\n      key: \"create\",\n      value: function create(numberOfAccounts, entropy) {\n        for (var i = 0; i < numberOfAccounts; ++i) {\n          this.add(Account.from(entropy || this.utils.randomHex(32), this.accountsModule));\n        }\n\n        return this;\n      }\n    }, {\n      key: \"get\",\n      value: function get(account) {\n        return this.accounts[account];\n      }\n    }, {\n      key: \"add\",\n      value: function add(account) {\n        if (isString(account)) {\n          account = Account.fromPrivateKey(account, this.accountsModule);\n        }\n\n        if (!this.accounts[account.address]) {\n          this.accounts[this.accountsIndex] = account;\n          this.accounts[account.address] = account;\n          this.accounts[account.address.toLowerCase()] = account;\n          this.accountsIndex++;\n          return account;\n        }\n\n        return this.accounts[account.address];\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(addressOrIndex) {\n        var account = this.accounts[addressOrIndex];\n\n        if (account) {\n          delete this.accounts[account.address];\n          delete this.accounts[account.address.toLowerCase()];\n          delete this.accounts[account.index];\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        for (var i = 0; i <= this.accountsIndex; i++) {\n          this.remove(i);\n        }\n\n        this.accountsIndex = 0;\n        return this;\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(password, options) {\n        var encryptedAccounts = [];\n\n        for (var i = 0; i < this.accountsIndex; i++) {\n          encryptedAccounts.push(this.accounts[i].encrypt(password, options));\n        }\n\n        return encryptedAccounts;\n      }\n    }, {\n      key: \"decrypt\",\n      value: function decrypt(encryptedWallet, password) {\n        var _this = this;\n\n        encryptedWallet.forEach(function (keystore) {\n          var account = Account.fromV3Keystore(keystore, password, false, _this.accountsModule);\n\n          if (!account) {\n            throw new Error(\"Couldn't decrypt accounts. Password wrong?\");\n          }\n\n          _this.add(account);\n        });\n        return this;\n      }\n    }, {\n      key: \"save\",\n      value: function save(password, keyName) {\n        console.warn('SECURITY WARNING: Storing of accounts in the localStorage is highly insecure!');\n\n        if (typeof localStorage === 'undefined') {\n          throw new TypeError('window.localStorage is undefined.');\n        }\n\n        try {\n          localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n        } catch (error) {\n          if (error.code === 18) {\n            return true;\n          }\n\n          throw new Error(error);\n        }\n\n        return true;\n      }\n    }, {\n      key: \"load\",\n      value: function load(password, keyName) {\n        console.warn('SECURITY WARNING: Storing of accounts in the localStorage is highly insecure!');\n\n        if (typeof localStorage === 'undefined') {\n          throw new TypeError('window.localStorage is undefined.');\n        }\n\n        var keystore;\n\n        try {\n          keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n          if (keystore) {\n            keystore = JSON.parse(keystore);\n          }\n        } catch (error) {\n          if (error.code === 18) {\n            keystore = this.defaultKeyName;\n          } else {\n            throw new Error(error);\n          }\n        }\n\n        return this.decrypt(keystore || [], password);\n      }\n    }]);\n\n    return Wallet;\n  }();\n\n  var Accounts = function (_AbstractWeb3Module) {\n    _inherits(Accounts, _AbstractWeb3Module);\n\n    function Accounts(provider, utils, formatters, methodFactory, options, net) {\n      var _this;\n\n      _classCallCheck(this, Accounts);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Accounts).call(this, provider, options, methodFactory, net));\n      _this.utils = utils;\n      _this.formatters = formatters;\n      _this._transactionSigner = options.transactionSigner;\n      _this.defaultKeyName = 'web3js_wallet';\n      _this.accounts = {};\n      _this.accountsIndex = 0;\n      _this.wallet = new Wallet(utils, _assertThisInitialized(_this));\n      return _this;\n    }\n\n    _createClass(Accounts, [{\n      key: \"create\",\n      value: function create(entropy) {\n        return Account.from(entropy, this);\n      }\n    }, {\n      key: \"privateKeyToAccount\",\n      value: function privateKeyToAccount(privateKey) {\n        return Account.fromPrivateKey(privateKey, this);\n      }\n    }, {\n      key: \"hashMessage\",\n      value: function hashMessage(data) {\n        if (this.utils.isHexStrict(data)) {\n          data = this.utils.hexToBytes(data);\n        }\n\n        var messageBuffer = Buffer.from(data);\n        var preambleBuffer = Buffer.from(\"\\x19Ethereum Signed Message:\\n\".concat(data.length));\n        var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n        return Hash.keccak256s(ethMessage);\n      }\n    }, {\n      key: \"signTransaction\",\n      value: function () {\n        var _signTransaction = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tx, privateKey, callback) {\n          var account, signedTransaction;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  account = Account.fromPrivateKey(privateKey, this);\n\n                  if (tx.chainId) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  _context.next = 5;\n                  return this.getChainId();\n\n                case 5:\n                  tx.chainId = _context.sent;\n\n                case 6:\n                  if (tx.gasPrice) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  _context.next = 9;\n                  return this.getGasPrice();\n\n                case 9:\n                  tx.gasPrice = _context.sent;\n\n                case 10:\n                  if (!(!tx.nonce && tx.nonce !== 0)) {\n                    _context.next = 14;\n                    break;\n                  }\n\n                  _context.next = 13;\n                  return this.getTransactionCount(account.address);\n\n                case 13:\n                  tx.nonce = _context.sent;\n\n                case 14:\n                  _context.next = 16;\n                  return this.transactionSigner.sign(this.formatters.inputCallFormatter(tx, this), account.privateKey);\n\n                case 16:\n                  signedTransaction = _context.sent;\n\n                  if (isFunction(callback)) {\n                    callback(false, signedTransaction);\n                  }\n\n                  return _context.abrupt(\"return\", signedTransaction);\n\n                case 21:\n                  _context.prev = 21;\n                  _context.t0 = _context[\"catch\"](0);\n\n                  if (!isFunction(callback)) {\n                    _context.next = 26;\n                    break;\n                  }\n\n                  callback(_context.t0, null);\n                  return _context.abrupt(\"return\");\n\n                case 26:\n                  throw _context.t0;\n\n                case 27:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 21]]);\n        }));\n\n        function signTransaction(_x, _x2, _x3) {\n          return _signTransaction.apply(this, arguments);\n        }\n\n        return signTransaction;\n      }()\n    }, {\n      key: \"recoverTransaction\",\n      value: function recoverTransaction(rawTx) {\n        var values = RLP.decode(rawTx);\n        var signature = EthLibAccount.encodeSignature(values.slice(6, 9));\n        var recovery = Bytes.toNumber(values[6]);\n        var extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n        var signingData = values.slice(0, 6).concat(extraData);\n        var signingDataHex = RLP.encode(signingData);\n        return EthLibAccount.recover(Hash.keccak256(signingDataHex), signature);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(data, privateKey) {\n        if (this.utils.isHexStrict(data)) {\n          data = this.utils.hexToBytes(data);\n        }\n\n        return Account.fromPrivateKey(privateKey, this).sign(data);\n      }\n    }, {\n      key: \"recover\",\n      value: function recover(message, signature, preFixed) {\n        if (isObject(message)) {\n          return this.recover(message.messageHash, EthLibAccount.encodeSignature([message.v, message.r, message.s]), true);\n        }\n\n        if (!preFixed) {\n          message = this.hashMessage(message);\n        }\n\n        if (arguments.length >= 4) {\n          return this.recover(arguments[0], EthLibAccount.encodeSignature([arguments[1], arguments[2], arguments[3]]), !!arguments[4]);\n        }\n\n        return EthLibAccount.recover(message, signature);\n      }\n    }, {\n      key: \"decrypt\",\n      value: function decrypt(v3Keystore, password, nonStrict) {\n        return Account.fromV3Keystore(v3Keystore, password, nonStrict, this);\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(privateKey, password, options) {\n        return Account.fromPrivateKey(privateKey, this).toV3Keystore(password, options);\n      }\n    }, {\n      key: \"transactionSigner\",\n      get: function get() {\n        return this._transactionSigner;\n      },\n      set: function set(transactionSigner) {\n        if (transactionSigner.type && transactionSigner.type === 'TransactionSigner') {\n          throw new Error('Invalid TransactionSigner given!');\n        }\n\n        this._transactionSigner = transactionSigner;\n      }\n    }]);\n\n    return Accounts;\n  }(web3Core.AbstractWeb3Module);\n\n  function Accounts$1(provider) {\n    var net = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new Accounts(provider, Utils, web3CoreHelpers.formatters, new MethodFactory(Utils, web3CoreHelpers.formatters), options, net);\n  }\n\n  exports.Accounts = Accounts$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar BN = require('./bn');\n\nvar ECJPoint = require('./ecjpoint');\n\nfunction ECPoint(x, y) {\n  if (x === null && y === null) {\n    this.x = this.y = null;\n    this.inf = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.inf = false;\n  }\n}\n\nECPoint.fromPublicKey = function (publicKey) {\n  var first = publicKey[0];\n  var x;\n  var y;\n\n  if (publicKey.length === 33 && (first === 0x02 || first === 0x03)) {\n    x = BN.fromBuffer(publicKey.slice(1, 33)); // overflow\n\n    if (x.ucmp(BN.p) >= 0) return null; // create from X\n\n    y = x.redSqr().redMul(x).redIAdd7().redSqrt();\n    if (y === null) return null;\n    if (first === 0x03 !== y.isOdd()) y = y.redNeg();\n    return new ECPoint(x, y);\n  }\n\n  if (publicKey.length === 65 && (first === 0x04 || first === 0x06 || first === 0x07)) {\n    x = BN.fromBuffer(publicKey.slice(1, 33));\n    y = BN.fromBuffer(publicKey.slice(33, 65)); // overflow\n\n    if (x.ucmp(BN.p) >= 0 || y.ucmp(BN.p) >= 0) return null; // is odd flag\n\n    if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null; // x*x*x + 7 = y*y\n\n    if (x.redSqr().redMul(x).redIAdd7().ucmp(y.redSqr()) !== 0) return null;\n    return new ECPoint(x, y);\n  }\n\n  return null;\n};\n\nECPoint.prototype.toPublicKey = function (compressed) {\n  var x = this.x;\n  var y = this.y;\n  var publicKey;\n\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toBuffer().copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toBuffer().copy(publicKey, 1);\n    y.toBuffer().copy(publicKey, 33);\n  }\n\n  return publicKey;\n};\n\nECPoint.fromECJPoint = function (p) {\n  if (p.inf) return new ECPoint(null, null);\n  var zinv = p.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = p.x.redMul(zinv2);\n  var ay = p.y.redMul(zinv2).redMul(zinv);\n  return new ECPoint(ax, ay);\n};\n\nECPoint.prototype.toECJPoint = function () {\n  if (this.inf) return new ECJPoint(null, null, null);\n  return new ECJPoint(this.x, this.y, ECJPoint.one);\n};\n\nECPoint.prototype.neg = function () {\n  if (this.inf) return this;\n  return new ECPoint(this.x, this.y.redNeg());\n};\n\nECPoint.prototype.add = function (p) {\n  // O + P = P\n  if (this.inf) return p; // P + O = P\n\n  if (p.inf) return this;\n\n  if (this.x.ucmp(p.x) === 0) {\n    // P + P = 2P\n    if (this.y.ucmp(p.y) === 0) return this.dbl(); // P + (-P) = O\n\n    return new ECPoint(null, null);\n  } // s = (y - yp) / (x - xp)\n  // nx = s^2 - x - xp\n  // ny = s * (x - nx) - y\n\n\n  var s = this.y.redSub(p.y);\n  if (!s.isZero()) s = s.redMul(this.x.redSub(p.x).redInvm());\n  var nx = s.redSqr().redISub(this.x).redISub(p.x);\n  var ny = s.redMul(this.x.redSub(nx)).redISub(this.y);\n  return new ECPoint(nx, ny);\n};\n\nECPoint.prototype.dbl = function () {\n  if (this.inf) return this; // 2P = O\n\n  var yy = this.y.redAdd(this.y);\n  if (yy.isZero()) return new ECPoint(null, null); // s = (3 * x^2) / (2 * y)\n  // nx = s^2 - 2*x\n  // ny = s * (x - nx) - y\n\n  var x2 = this.x.redSqr();\n  var s = x2.redAdd(x2).redIAdd(x2).redMul(yy.redInvm());\n  var nx = s.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = s.redMul(this.x.redSub(nx)).redISub(this.y);\n  return new ECPoint(nx, ny);\n};\n\nECPoint.prototype.mul = function (num) {\n  // Algorithm 3.36 Window NAF method for point multiplication\n  var nafPoints = this._getNAFPoints(4);\n\n  var points = nafPoints.points; // Get NAF form\n\n  var naf = num.getNAF(nafPoints.wnd); // Add `this`*(N+1) for every w-NAF index\n\n  var acc = new ECJPoint(null, null, null);\n\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var k = 0; i >= 0 && naf[i] === 0; i--, ++k) {\n      ;\n    }\n\n    if (i >= 0) k += 1;\n    acc = acc.dblp(k);\n    if (i < 0) break; // J +- P\n\n    var z = naf[i];\n\n    if (z > 0) {\n      acc = acc.mixedAdd(points[z - 1 >> 1]);\n    } else {\n      acc = acc.mixedAdd(points[-z - 1 >> 1].neg());\n    }\n  }\n\n  return ECPoint.fromECJPoint(acc);\n};\n\nECPoint.prototype._getNAFPoints1 = function () {\n  return {\n    wnd: 1,\n    points: [this]\n  };\n};\n\nECPoint.prototype._getNAFPoints = function (wnd) {\n  var points = new Array((1 << wnd) - 1);\n  points[0] = this;\n  var dbl = this.dbl();\n\n  for (var i = 1; i < points.length; ++i) {\n    points[i] = points[i - 1].add(dbl);\n  }\n\n  return {\n    wnd: wnd,\n    points: points\n  };\n};\n\nmodule.exports = ECPoint;","map":null,"metadata":{},"sourceType":"script"}
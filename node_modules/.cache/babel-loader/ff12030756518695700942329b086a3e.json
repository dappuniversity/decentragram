{"ast":null,"code":"'use strict';\n\nvar secp256k1 = require('secp256k1');\n\nvar multihashing = require('multihashing-async');\n\nvar setImmediate = require('async/setImmediate');\n\nvar HASH_ALGORITHM = 'sha2-256';\n\nmodule.exports = function (randomBytes) {\n  var privateKeyLength = 32;\n\n  function generateKey(callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    var privateKey;\n\n    do {\n      privateKey = randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privateKey));\n\n    done(null, privateKey);\n  }\n\n  function hashAndSign(key, msg, callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        var sig = secp256k1.sign(digest, key);\n        var sigDER = secp256k1.signatureExport(sig.signature);\n        return done(null, sigDER);\n      } catch (err) {\n        done(err);\n      }\n    });\n  }\n\n  function hashAndVerify(key, sig, msg, callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        sig = secp256k1.signatureImport(sig);\n        var valid = secp256k1.verify(digest, sig, key);\n        return done(null, valid);\n      } catch (err) {\n        done(err);\n      }\n    });\n  }\n\n  function compressPublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n\n    return secp256k1.publicKeyConvert(key, true);\n  }\n\n  function decompressPublicKey(key) {\n    return secp256k1.publicKeyConvert(key, false);\n  }\n\n  function validatePrivateKey(key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key');\n    }\n  }\n\n  function validatePublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    validatePrivateKey(privateKey);\n    return secp256k1.publicKeyCreate(privateKey);\n  }\n\n  return {\n    generateKey: generateKey,\n    privateKeyLength: privateKeyLength,\n    hashAndSign: hashAndSign,\n    hashAndVerify: hashAndVerify,\n    compressPublicKey: compressPublicKey,\n    decompressPublicKey: decompressPublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validatePublicKey: validatePublicKey,\n    computePublicKey: computePublicKey\n  };\n};","map":null,"metadata":{},"sourceType":"script"}
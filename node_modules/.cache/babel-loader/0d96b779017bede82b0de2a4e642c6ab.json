{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar errcode = require('err-code');\n\nvar multihash = require('multihashes');\n\nvar crypto = require('./crypto');\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\n\nfunction Multihashing(_x, _x2, _x3) {\n  return _Multihashing.apply(this, arguments);\n}\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\n\n\nfunction _Multihashing() {\n  _Multihashing = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(buf, alg, length) {\n    var digest;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return Multihashing.digest(buf, alg, length);\n\n          case 2:\n            digest = _context3.sent;\n            return _context3.abrupt(\"return\", multihash.encode(digest, alg, length));\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _Multihashing.apply(this, arguments);\n}\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\nMultihashing.multihash = multihash;\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\nMultihashing.digest =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(buf, alg, length) {\n    var hash, digest;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            hash = Multihashing.createHash(alg);\n            _context.next = 3;\n            return hash(buf);\n\n          case 3:\n            digest = _context.sent;\n            return _context.abrupt(\"return\", length ? digest.slice(0, length) : digest);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\n\n\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode('hash algorithm must be specified', 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n  }\n\n  alg = multihash.coerceCode(alg);\n\n  if (!Multihashing.functions[alg]) {\n    throw errcode(\"multihash function '\".concat(alg, \"' not yet supported\"), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n\n  return Multihashing.functions[alg];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\n\n\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256 // add blake functions\n\n};\ncrypto.addBlake(Multihashing.functions);\n\nMultihashing.validate =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(buf, hash) {\n    var newHash;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return Multihashing(buf, multihash.decode(hash).name);\n\n          case 2:\n            newHash = _context2.sent;\n            return _context2.abrupt(\"return\", Buffer.compare(hash, newHash) === 0);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = Multihashing;","map":null,"metadata":{},"sourceType":"script"}
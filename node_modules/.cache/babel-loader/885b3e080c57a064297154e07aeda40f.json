{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-utils'), require('web3-core-helpers'), require('web3-providers'), require('web3-eth-contract'), require('web3-eth-abi'), require('web3-net'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/get'), require('@babel/runtime/helpers/inherits'), require('web3-core-method'), require('web3-core'), require('lodash/isFunction'), require('eth-ens-namehash')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-utils', 'web3-core-helpers', 'web3-providers', 'web3-eth-contract', 'web3-eth-abi', 'web3-net', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/get', '@babel/runtime/helpers/inherits', 'web3-core-method', 'web3-core', 'lodash/isFunction', 'eth-ens-namehash'], factory) : (global = global || self, factory(global.Web3EthEns = {}, global.Utils, global.web3CoreHelpers, global.web3Providers, global['web3-eth-contract'], global.web3EthAbi, global.web3Net, global._classCallCheck, global._createClass, global._regeneratorRuntime, global._asyncToGenerator, global._possibleConstructorReturn, global._getPrototypeOf, global._get, global._inherits, global.web3CoreMethod, global.web3Core, global.isFunction, global['eth-ens-namehash']));\n})(this, function (exports, Utils, web3CoreHelpers, web3Providers, web3EthContract, web3EthAbi, web3Net, _classCallCheck, _createClass, _regeneratorRuntime, _asyncToGenerator, _possibleConstructorReturn, _getPrototypeOf, _get, _inherits, web3CoreMethod, web3Core, isFunction, namehash) {\n  'use strict';\n\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  namehash = namehash && namehash.hasOwnProperty('default') ? namehash['default'] : namehash;\n\n  var Ens = function (_AbstractWeb3Module) {\n    _inherits(Ens, _AbstractWeb3Module);\n\n    function Ens(provider, options, ensModuleFactory, contractModuleFactory, accounts, abiCoder, utils, formatters, net, nodeNet) {\n      var _this;\n\n      _classCallCheck(this, Ens);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Ens).call(this, provider, options, null, nodeNet));\n      _this.accounts = accounts;\n      _this.ensModuleFactory = ensModuleFactory;\n      _this.contractModuleFactory = contractModuleFactory;\n      _this.abiCoder = abiCoder;\n      _this.utils = utils;\n      _this.formatters = formatters;\n      _this.registryOptions = options;\n      _this.net = net;\n      _this.transactionSigner = options.transactionSigner;\n      _this._registry = false;\n      return _this;\n    }\n\n    _createClass(Ens, [{\n      key: \"setProvider\",\n      value: function setProvider(provider, net) {\n        return _get(_getPrototypeOf(Ens.prototype), \"setProvider\", this).call(this, provider, net) && this.registry.setProvider(provider, net);\n      }\n    }, {\n      key: \"resolver\",\n      value: function resolver(name) {\n        return this.registry.resolver(name);\n      }\n    }, {\n      key: \"supportsInterface\",\n      value: function () {\n        var _supportsInterface = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(name, interfaceId, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context.sent;\n                  return _context.abrupt(\"return\", resolver.methods.supportsInterface(interfaceId).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function supportsInterface(_x, _x2, _x3) {\n          return _supportsInterface.apply(this, arguments);\n        }\n\n        return supportsInterface;\n      }()\n    }, {\n      key: \"getAddress\",\n      value: function () {\n        var _getAddress = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(name, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context2.sent;\n                  return _context2.abrupt(\"return\", resolver.methods.addr(namehash.hash(name)).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function getAddress(_x4, _x5) {\n          return _getAddress.apply(this, arguments);\n        }\n\n        return getAddress;\n      }()\n    }, {\n      key: \"setAddress\",\n      value: function setAddress(name, address, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setAddr(namehash.hash(name), address).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getPubkey\",\n      value: function () {\n        var _getPubkey = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(name, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context3.sent;\n                  return _context3.abrupt(\"return\", resolver.methods.pubkey(namehash.hash(name)).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function getPubkey(_x6, _x7) {\n          return _getPubkey.apply(this, arguments);\n        }\n\n        return getPubkey;\n      }()\n    }, {\n      key: \"setPubkey\",\n      value: function setPubkey(name, x, y, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setPubkey(namehash.hash(name), x, y).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getText\",\n      value: function () {\n        var _getText = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(name, key, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context4.sent;\n                  return _context4.abrupt(\"return\", resolver.methods.text(namehash.hash(name), key).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function getText(_x8, _x9, _x10) {\n          return _getText.apply(this, arguments);\n        }\n\n        return getText;\n      }()\n    }, {\n      key: \"setText\",\n      value: function setText(name, key, value, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setText(namehash.hash(name), key, value).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getContent\",\n      value: function () {\n        var _getContent = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(name, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context5.sent;\n                  return _context5.abrupt(\"return\", resolver.methods.content(namehash.hash(name)).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function getContent(_x11, _x12) {\n          return _getContent.apply(this, arguments);\n        }\n\n        return getContent;\n      }()\n    }, {\n      key: \"setContent\",\n      value: function setContent(name, hash, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setContent(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getMultihash\",\n      value: function () {\n        var _getMultihash = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6(name, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context6.sent;\n                  return _context6.abrupt(\"return\", resolver.methods.multihash(namehash.hash(name)).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function getMultihash(_x13, _x14) {\n          return _getMultihash.apply(this, arguments);\n        }\n\n        return getMultihash;\n      }()\n    }, {\n      key: \"setMultihash\",\n      value: function setMultihash(name, hash, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setMultihash(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getContenthash\",\n      value: function () {\n        var _getContenthash = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7(name, callback) {\n          var resolver;\n          return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.next = 2;\n                  return this.registry.resolver(name);\n\n                case 2:\n                  resolver = _context7.sent;\n                  return _context7.abrupt(\"return\", resolver.methods.contenthash(namehash.hash(name)).call(callback));\n\n                case 4:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, this);\n        }));\n\n        function getContenthash(_x15, _x16) {\n          return _getContenthash.apply(this, arguments);\n        }\n\n        return getContenthash;\n      }()\n    }, {\n      key: \"setContenthash\",\n      value: function setContenthash(name, hash, sendOptions, callback) {\n        var promiEvent = new web3CoreMethod.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setContenthash(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"registry\",\n      get: function get() {\n        if (!this._registry) {\n          this._registry = this.ensModuleFactory.createRegistry(this.currentProvider, this.contractModuleFactory, this.accounts, this.abiCoder, this.utils, this.formatters, this.registryOptions, this.net);\n        }\n\n        return this._registry;\n      }\n    }]);\n\n    return Ens;\n  }(web3Core.AbstractWeb3Module);\n\n  var REGISTRY_ABI = [{\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'resolver',\n    outputs: [{\n      name: '',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'owner',\n    outputs: [{\n      name: '',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'label',\n      type: 'bytes32'\n    }, {\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'setSubnodeOwner',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'ttl',\n      type: 'uint64'\n    }],\n    name: 'setTTL',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'ttl',\n    outputs: [{\n      name: '',\n      type: 'uint64'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'resolver',\n      type: 'address'\n    }],\n    name: 'setResolver',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'setOwner',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'Transfer',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: true,\n      name: 'label',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'NewOwner',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'resolver',\n      type: 'address'\n    }],\n    name: 'NewResolver',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'ttl',\n      type: 'uint64'\n    }],\n    name: 'NewTTL',\n    type: 'event'\n  }];\n  var RESOLVER_ABI = [{\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'key',\n      type: 'string'\n    }],\n    name: 'text',\n    outputs: [{\n      name: '',\n      type: 'string'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'key',\n      type: 'string'\n    }, {\n      name: 'value',\n      type: 'string'\n    }],\n    name: 'setText',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'interfaceID',\n      type: 'bytes4'\n    }],\n    name: 'supportsInterface',\n    outputs: [{\n      name: '',\n      type: 'bool'\n    }],\n    payable: false,\n    stateMutability: 'pure',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'contentTypes',\n      type: 'uint256'\n    }],\n    name: 'ABI',\n    outputs: [{\n      name: 'contentType',\n      type: 'uint256'\n    }, {\n      name: 'data',\n      type: 'bytes'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'setMultihash',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'multihash',\n    outputs: [{\n      name: '',\n      type: 'bytes'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'setContenthash',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'contenthash',\n    outputs: [{\n      name: '',\n      type: 'bytes'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      name: 'y',\n      type: 'bytes32'\n    }],\n    name: 'setPubkey',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'content',\n    outputs: [{\n      name: 'ret',\n      type: 'bytes32'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'addr',\n    outputs: [{\n      name: 'ret',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'contentType',\n      type: 'uint256'\n    }, {\n      name: 'data',\n      type: 'bytes'\n    }],\n    name: 'setABI',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'name',\n    outputs: [{\n      name: 'ret',\n      type: 'string'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'name',\n      type: 'string'\n    }],\n    name: 'setName',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes32'\n    }],\n    name: 'setContent',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'pubkey',\n    outputs: [{\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      name: 'y',\n      type: 'bytes32'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'addr',\n      type: 'address'\n    }],\n    name: 'setAddr',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    inputs: [{\n      name: 'ensAddr',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'constructor'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'a',\n      type: 'address'\n    }],\n    name: 'AddrChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'hash',\n      type: 'bytes32'\n    }],\n    name: 'ContentChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'indexedKey',\n      type: 'string'\n    }, {\n      indexed: false,\n      name: 'key',\n      type: 'string'\n    }],\n    name: 'TextChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'ContenthashChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'name',\n      type: 'string'\n    }],\n    name: 'NameChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: true,\n      name: 'contentType',\n      type: 'uint256'\n    }],\n    name: 'ABIChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'y',\n      type: 'bytes32'\n    }],\n    name: 'PubkeyChanged',\n    type: 'event'\n  }];\n\n  var Registry = function (_AbstractContract) {\n    _inherits(Registry, _AbstractContract);\n\n    function Registry(provider, contractModuleFactory, accounts, abiCoder, utils, formatters, options, net) {\n      var _this;\n\n      _classCallCheck(this, Registry);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Registry).call(this, provider, contractModuleFactory, accounts, abiCoder, utils, formatters, REGISTRY_ABI, '', options));\n      _this.net = net;\n      _this.resolverContract = null;\n      _this.resolverName = null;\n      return _this;\n    }\n\n    _createClass(Registry, [{\n      key: \"owner\",\n      value: function () {\n        var _owner = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(name, callback) {\n          var _owner2;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (this.address) {\n                    _context.next = 4;\n                    break;\n                  }\n\n                  _context.next = 3;\n                  return this.checkNetwork();\n\n                case 3:\n                  this.address = _context.sent;\n\n                case 4:\n                  _context.prev = 4;\n                  _context.next = 7;\n                  return this.methods.owner(namehash.hash(name)).call();\n\n                case 7:\n                  _owner2 = _context.sent;\n\n                  if (isFunction(callback)) {\n                    callback(false, _owner2);\n                  }\n\n                  return _context.abrupt(\"return\", _owner2);\n\n                case 12:\n                  _context.prev = 12;\n                  _context.t0 = _context[\"catch\"](4);\n\n                  if (isFunction(callback)) {\n                    callback(_context.t0, null);\n                  }\n\n                  throw _context.t0;\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[4, 12]]);\n        }));\n\n        function owner(_x, _x2) {\n          return _owner.apply(this, arguments);\n        }\n\n        return owner;\n      }()\n    }, {\n      key: \"setProvider\",\n      value: function setProvider(provider, net) {\n        if (this.resolverContract) {\n          return this.resolverContract.setProvider(provider, net) && _get(_getPrototypeOf(Registry.prototype), \"setProvider\", this).call(this, provider, net);\n        }\n\n        return _get(_getPrototypeOf(Registry.prototype), \"setProvider\", this).call(this, provider, net);\n      }\n    }, {\n      key: \"resolver\",\n      value: function () {\n        var _resolver = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(name) {\n          var address, clone;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(this.resolverName === name && this.resolverContract)) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\", this.resolverContract);\n\n                case 2:\n                  if (this.address) {\n                    _context2.next = 6;\n                    break;\n                  }\n\n                  _context2.next = 5;\n                  return this.checkNetwork();\n\n                case 5:\n                  this.address = _context2.sent;\n\n                case 6:\n                  _context2.next = 8;\n                  return this.methods.resolver(namehash.hash(name)).call();\n\n                case 8:\n                  address = _context2.sent;\n                  clone = this.clone();\n                  clone.jsonInterface = RESOLVER_ABI;\n                  clone.address = address;\n                  this.resolverName = name;\n                  this.resolverContract = clone;\n                  return _context2.abrupt(\"return\", clone);\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function resolver(_x3) {\n          return _resolver.apply(this, arguments);\n        }\n\n        return resolver;\n      }()\n    }, {\n      key: \"checkNetwork\",\n      value: function () {\n        var _checkNetwork = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n          var ensAddresses, block, headAge, networkType, address;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  ensAddresses = {\n                    main: '0x314159265dD8dbb310642f98f50C066173C1259b',\n                    ropsten: '0x112234455c3a32fd11230c42e7bccd4a84e02010',\n                    rinkeby: '0xe7410170f87102df0055eb195163a03b7f2bff4a'\n                  };\n                  _context3.next = 3;\n                  return this.net.getBlockByNumber('latest', false);\n\n                case 3:\n                  block = _context3.sent;\n                  headAge = new Date() / 1000 - block.timestamp;\n\n                  if (!(headAge > 3600)) {\n                    _context3.next = 7;\n                    break;\n                  }\n\n                  throw new Error(\"Network not synced; last block was \".concat(headAge, \" seconds ago\"));\n\n                case 7:\n                  _context3.next = 9;\n                  return this.net.getNetworkType();\n\n                case 9:\n                  networkType = _context3.sent;\n                  address = ensAddresses[networkType];\n\n                  if (!(typeof address === 'undefined')) {\n                    _context3.next = 13;\n                    break;\n                  }\n\n                  throw new TypeError(\"ENS is not supported on network: \\\"\".concat(networkType, \"\\\"\"));\n\n                case 13:\n                  return _context3.abrupt(\"return\", address);\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function checkNetwork() {\n          return _checkNetwork.apply(this, arguments);\n        }\n\n        return checkNetwork;\n      }()\n    }]);\n\n    return Registry;\n  }(web3EthContract.AbstractContract);\n\n  var EnsModuleFactory = function () {\n    function EnsModuleFactory() {\n      _classCallCheck(this, EnsModuleFactory);\n    }\n\n    _createClass(EnsModuleFactory, [{\n      key: \"createENS\",\n      value: function createENS(provider, contractModuleFactory, accounts, abiCoder, utils, formatters, net, ensModuleOptions, nodeNet) {\n        return new Ens(provider, ensModuleOptions, this, contractModuleFactory, accounts, abiCoder, utils, formatters, net, nodeNet);\n      }\n    }, {\n      key: \"createRegistry\",\n      value: function createRegistry(provider, contractModuleFactory, accounts, abiCoder, utils, formatters, options, net) {\n        return new Registry(provider, contractModuleFactory, accounts, abiCoder, utils, formatters, options, net);\n      }\n    }]);\n\n    return EnsModuleFactory;\n  }();\n\n  function Ens$1(provider) {\n    var net = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var accounts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var abiCoder = new web3EthAbi.AbiCoder();\n    var resolvedProvider = new web3Providers.ProviderResolver().resolve(provider, net);\n    return new EnsModuleFactory().createENS(resolvedProvider, new web3EthContract.ContractModuleFactory(Utils, web3CoreHelpers.formatters, abiCoder), accounts, abiCoder, Utils, web3CoreHelpers.formatters, new web3Net.Network(resolvedProvider, null, options), options, null);\n  }\n\n  exports.Ens = Ens$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}
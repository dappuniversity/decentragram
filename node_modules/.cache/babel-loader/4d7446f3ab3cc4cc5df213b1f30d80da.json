{"ast":null,"code":"/**\n * Javascript implementation of X.509 and related components (such as\n * Certification Signing Requests) of a Public Key Infrastructure.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The ASN.1 representation of an X.509v3 certificate is as follows\n * (see RFC 2459):\n *\n * Certificate ::= SEQUENCE {\n *   tbsCertificate       TBSCertificate,\n *   signatureAlgorithm   AlgorithmIdentifier,\n *   signatureValue       BIT STRING\n * }\n *\n * TBSCertificate ::= SEQUENCE {\n *   version         [0]  EXPLICIT Version DEFAULT v1,\n *   serialNumber         CertificateSerialNumber,\n *   signature            AlgorithmIdentifier,\n *   issuer               Name,\n *   validity             Validity,\n *   subject              Name,\n *   subjectPublicKeyInfo SubjectPublicKeyInfo,\n *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   extensions      [3]  EXPLICIT Extensions OPTIONAL\n *                        -- If present, version shall be v3\n * }\n *\n * Version ::= INTEGER  { v1(0), v2(1), v3(2) }\n *\n * CertificateSerialNumber ::= INTEGER\n *\n * Name ::= CHOICE {\n *   // only one possible choice for now\n *   RDNSequence\n * }\n *\n * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n *\n * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue\n *\n * AttributeTypeAndValue ::= SEQUENCE {\n *   type     AttributeType,\n *   value    AttributeValue\n * }\n * AttributeType ::= OBJECT IDENTIFIER\n * AttributeValue ::= ANY DEFINED BY AttributeType\n *\n * Validity ::= SEQUENCE {\n *   notBefore      Time,\n *   notAfter       Time\n * }\n *\n * Time ::= CHOICE {\n *   utcTime        UTCTime,\n *   generalTime    GeneralizedTime\n * }\n *\n * UniqueIdentifier ::= BIT STRING\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm            AlgorithmIdentifier,\n *   subjectPublicKey     BIT STRING\n * }\n *\n * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\n *\n * Extension ::= SEQUENCE {\n *   extnID      OBJECT IDENTIFIER,\n *   critical    BOOLEAN DEFAULT FALSE,\n *   extnValue   OCTET STRING\n * }\n *\n * The only key algorithm currently supported for PKI is RSA.\n *\n * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.\n *\n * PKCS#10 v1.7 describes certificate signing requests:\n *\n * CertificationRequestInfo:\n *\n * CertificationRequestInfo ::= SEQUENCE {\n *   version       INTEGER { v1(0) } (v1,...),\n *   subject       Name,\n *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\n *   attributes    [0] Attributes{{ CRIAttributes }}\n * }\n *\n * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}\n *\n * CRIAttributes  ATTRIBUTE  ::= {\n *   ... -- add any locally defined attributes here -- }\n *\n * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\n *   type   ATTRIBUTE.&id({IOSet}),\n *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\n * }\n *\n * CertificationRequest ::= SEQUENCE {\n *   certificationRequestInfo CertificationRequestInfo,\n *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},\n *   signature          BIT STRING\n * }\n */\nvar forge = require('./forge');\n\nrequire('./aes');\n\nrequire('./asn1');\n\nrequire('./des');\n\nrequire('./md');\n\nrequire('./mgf');\n\nrequire('./oids');\n\nrequire('./pem');\n\nrequire('./pss');\n\nrequire('./rsa');\n\nrequire('./util'); // shortcut for asn.1 API\n\n\nvar asn1 = forge.asn1;\n/* Public Key Infrastructure (PKI) implementation. */\n\nvar pki = module.exports = forge.pki = forge.pki || {};\nvar oids = pki.oids; // short name OID mappings\n\nvar _shortNames = {};\n_shortNames['CN'] = oids['commonName'];\n_shortNames['commonName'] = 'CN';\n_shortNames['C'] = oids['countryName'];\n_shortNames['countryName'] = 'C';\n_shortNames['L'] = oids['localityName'];\n_shortNames['localityName'] = 'L';\n_shortNames['ST'] = oids['stateOrProvinceName'];\n_shortNames['stateOrProvinceName'] = 'ST';\n_shortNames['O'] = oids['organizationName'];\n_shortNames['organizationName'] = 'O';\n_shortNames['OU'] = oids['organizationalUnitName'];\n_shortNames['organizationalUnitName'] = 'OU';\n_shortNames['E'] = oids['emailAddress'];\n_shortNames['emailAddress'] = 'E'; // validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\n\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator; // validator for an X.509v3 certificate\n\nvar x509CertificateValidator = {\n  name: 'Certificate',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Certificate.TBSCertificate',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: 'tbsCertificate',\n    value: [{\n      name: 'Certificate.TBSCertificate.version',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 0,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.version.integer',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: 'certVersion'\n      }]\n    }, {\n      name: 'Certificate.TBSCertificate.serialNumber',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      capture: 'certSerialNumber'\n    }, {\n      name: 'Certificate.TBSCertificate.signature',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.signature.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'certinfoSignatureOid'\n      }, {\n        name: 'Certificate.TBSCertificate.signature.parameters',\n        tagClass: asn1.Class.UNIVERSAL,\n        optional: true,\n        captureAsn1: 'certinfoSignatureParams'\n      }]\n    }, {\n      name: 'Certificate.TBSCertificate.issuer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'certIssuer'\n    }, {\n      name: 'Certificate.TBSCertificate.validity',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      // Note: UTC and generalized times may both appear so the capture\n      // names are based on their detected order, the names used below\n      // are only for the common case, which validity time really means\n      // \"notBefore\" and which means \"notAfter\" will be determined by order\n      value: [{\n        // notBefore (Time) (UTC time case)\n        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity1UTCTime'\n      }, {\n        // notBefore (Time) (generalized time case)\n        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity2GeneralizedTime'\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity3UTCTime'\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity4GeneralizedTime'\n      }]\n    }, {\n      // Name (subject) (RDNSequence)\n      name: 'Certificate.TBSCertificate.subject',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'certSubject'\n    }, // SubjectPublicKeyInfo\n    publicKeyValidator, {\n      // issuerUniqueID (optional)\n      name: 'Certificate.TBSCertificate.issuerUniqueID',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 1,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.issuerUniqueID.id',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        // TODO: support arbitrary bit length ids\n        captureBitStringValue: 'certIssuerUniqueId'\n      }]\n    }, {\n      // subjectUniqueID (optional)\n      name: 'Certificate.TBSCertificate.subjectUniqueID',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 2,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.subjectUniqueID.id',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        // TODO: support arbitrary bit length ids\n        captureBitStringValue: 'certSubjectUniqueId'\n      }]\n    }, {\n      // Extensions (optional)\n      name: 'Certificate.TBSCertificate.extensions',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 3,\n      constructed: true,\n      captureAsn1: 'certExtensions',\n      optional: true\n    }]\n  }, {\n    // AlgorithmIdentifier (signature algorithm)\n    name: 'Certificate.signatureAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // algorithm\n      name: 'Certificate.signatureAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'certSignatureOid'\n    }, {\n      name: 'Certificate.TBSCertificate.signature.parameters',\n      tagClass: asn1.Class.UNIVERSAL,\n      optional: true,\n      captureAsn1: 'certSignatureParams'\n    }]\n  }, {\n    // SignatureValue\n    name: 'Certificate.signatureValue',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    captureBitStringValue: 'certSignature'\n  }]\n};\nvar rsassaPssParameterValidator = {\n  name: 'rsapss',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'rsapss.hashAlgorithm',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    value: [{\n      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.SEQUENCE,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'hashOid'\n        /* parameter block omitted, for SHA1 NULL anyhow. */\n\n      }]\n    }]\n  }, {\n    name: 'rsapss.maskGenAlgorithm',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 1,\n    constructed: true,\n    value: [{\n      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.SEQUENCE,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'maskGenOid'\n      }, {\n        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'maskGenHashOid'\n          /* parameter block omitted, for SHA1 NULL anyhow. */\n\n        }]\n      }]\n    }]\n  }, {\n    name: 'rsapss.saltLength',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 2,\n    optional: true,\n    value: [{\n      name: 'rsapss.saltLength.saltLength',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.INTEGER,\n      constructed: false,\n      capture: 'saltLength'\n    }]\n  }, {\n    name: 'rsapss.trailerField',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 3,\n    optional: true,\n    value: [{\n      name: 'rsapss.trailer.trailer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.INTEGER,\n      constructed: false,\n      capture: 'trailer'\n    }]\n  }]\n}; // validator for a CertificationRequestInfo structure\n\nvar certificationRequestInfoValidator = {\n  name: 'CertificationRequestInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'certificationRequestInfo',\n  value: [{\n    name: 'CertificationRequestInfo.integer',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'certificationRequestInfoVersion'\n  }, {\n    // Name (subject) (RDNSequence)\n    name: 'CertificationRequestInfo.subject',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: 'certificationRequestInfoSubject'\n  }, // SubjectPublicKeyInfo\n  publicKeyValidator, {\n    name: 'CertificationRequestInfo.attributes',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    optional: true,\n    capture: 'certificationRequestInfoAttributes',\n    value: [{\n      name: 'CertificationRequestInfo.attributes',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: 'CertificationRequestInfo.attributes.type',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false\n      }, {\n        name: 'CertificationRequestInfo.attributes.value',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SET,\n        constructed: true\n      }]\n    }]\n  }]\n}; // validator for a CertificationRequest structure\n\nvar certificationRequestValidator = {\n  name: 'CertificationRequest',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'csr',\n  value: [certificationRequestInfoValidator, {\n    // AlgorithmIdentifier (signature algorithm)\n    name: 'CertificationRequest.signatureAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // algorithm\n      name: 'CertificationRequest.signatureAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'csrSignatureOid'\n    }, {\n      name: 'CertificationRequest.signatureAlgorithm.parameters',\n      tagClass: asn1.Class.UNIVERSAL,\n      optional: true,\n      captureAsn1: 'csrSignatureParams'\n    }]\n  }, {\n    // signature\n    name: 'CertificationRequest.signature',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    captureBitStringValue: 'csrSignature'\n  }]\n};\n/**\n * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName\n * sets into an array with objects that have type and value properties.\n *\n * @param rdn the RDNSequence to convert.\n * @param md a message digest to append type and value to if provided.\n */\n\npki.RDNAttributesAsArray = function (rdn, md) {\n  var rval = []; // each value in 'rdn' in is a SET of RelativeDistinguishedName\n\n  var set, attr, obj;\n\n  for (var si = 0; si < rdn.value.length; ++si) {\n    // get the RelativeDistinguishedName set\n    set = rdn.value[si]; // each value in the SET is an AttributeTypeAndValue sequence\n    // containing first a type (an OID) and second a value (defined by\n    // the OID)\n\n    for (var i = 0; i < set.value.length; ++i) {\n      obj = {};\n      attr = set.value[i];\n      obj.type = asn1.derToOid(attr.value[0].value);\n      obj.value = attr.value[1].value;\n      obj.valueTagClass = attr.value[1].type; // if the OID is known, get its name and short name\n\n      if (obj.type in oids) {\n        obj.name = oids[obj.type];\n\n        if (obj.name in _shortNames) {\n          obj.shortName = _shortNames[obj.name];\n        }\n      }\n\n      if (md) {\n        md.update(obj.type);\n        md.update(obj.value);\n      }\n\n      rval.push(obj);\n    }\n  }\n\n  return rval;\n};\n/**\n * Converts ASN.1 CRIAttributes into an array with objects that have type and\n * value properties.\n *\n * @param attributes the CRIAttributes to convert.\n */\n\n\npki.CRIAttributesAsArray = function (attributes) {\n  var rval = []; // each value in 'attributes' in is a SEQUENCE with an OID and a SET\n\n  for (var si = 0; si < attributes.length; ++si) {\n    // get the attribute sequence\n    var seq = attributes[si]; // each value in the SEQUENCE containing first a type (an OID) and\n    // second a set of values (defined by the OID)\n\n    var type = asn1.derToOid(seq.value[0].value);\n    var values = seq.value[1].value;\n\n    for (var vi = 0; vi < values.length; ++vi) {\n      var obj = {};\n      obj.type = type;\n      obj.value = values[vi].value;\n      obj.valueTagClass = values[vi].type; // if the OID is known, get its name and short name\n\n      if (obj.type in oids) {\n        obj.name = oids[obj.type];\n\n        if (obj.name in _shortNames) {\n          obj.shortName = _shortNames[obj.name];\n        }\n      } // parse extensions\n\n\n      if (obj.type === oids.extensionRequest) {\n        obj.extensions = [];\n\n        for (var ei = 0; ei < obj.value.length; ++ei) {\n          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));\n        }\n      }\n\n      rval.push(obj);\n    }\n  }\n\n  return rval;\n};\n/**\n * Gets an issuer or subject attribute from its name, type, or short name.\n *\n * @param obj the issuer or subject object.\n * @param options a short name string or an object with:\n *          shortName the short name for the attribute.\n *          name the name for the attribute.\n *          type the type for the attribute.\n *\n * @return the attribute.\n */\n\n\nfunction _getAttribute(obj, options) {\n  if (typeof options === 'string') {\n    options = {\n      shortName: options\n    };\n  }\n\n  var rval = null;\n  var attr;\n\n  for (var i = 0; rval === null && i < obj.attributes.length; ++i) {\n    attr = obj.attributes[i];\n\n    if (options.type && options.type === attr.type) {\n      rval = attr;\n    } else if (options.name && options.name === attr.name) {\n      rval = attr;\n    } else if (options.shortName && options.shortName === attr.shortName) {\n      rval = attr;\n    }\n  }\n\n  return rval;\n}\n/**\n * Converts signature parameters from ASN.1 structure.\n *\n * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had\n * no parameters.\n *\n * RSASSA-PSS-params  ::=  SEQUENCE  {\n *   hashAlgorithm      [0] HashAlgorithm DEFAULT\n *                             sha1Identifier,\n *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\n *                             mgf1SHA1Identifier,\n *   saltLength         [2] INTEGER DEFAULT 20,\n *   trailerField       [3] INTEGER DEFAULT 1\n * }\n *\n * HashAlgorithm  ::=  AlgorithmIdentifier\n *\n * MaskGenAlgorithm  ::=  AlgorithmIdentifier\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * @param oid The OID specifying the signature algorithm\n * @param obj The ASN.1 structure holding the parameters\n * @param fillDefaults Whether to use return default values where omitted\n * @return signature parameter object\n */\n\n\nvar _readSignatureParameters = function _readSignatureParameters(oid, obj, fillDefaults) {\n  var params = {};\n\n  if (oid !== oids['RSASSA-PSS']) {\n    return params;\n  }\n\n  if (fillDefaults) {\n    params = {\n      hash: {\n        algorithmOid: oids['sha1']\n      },\n      mgf: {\n        algorithmOid: oids['mgf1'],\n        hash: {\n          algorithmOid: oids['sha1']\n        }\n      },\n      saltLength: 20\n    };\n  }\n\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\n    var error = new Error('Cannot read RSASSA-PSS parameter block.');\n    error.errors = errors;\n    throw error;\n  }\n\n  if (capture.hashOid !== undefined) {\n    params.hash = params.hash || {};\n    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\n  }\n\n  if (capture.maskGenOid !== undefined) {\n    params.mgf = params.mgf || {};\n    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\n    params.mgf.hash = params.mgf.hash || {};\n    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\n  }\n\n  if (capture.saltLength !== undefined) {\n    params.saltLength = capture.saltLength.charCodeAt(0);\n  }\n\n  return params;\n};\n/**\n * Converts an X.509 certificate from PEM format.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. This will scan the TBSCertificate part of the ASN.1\n * object while it is converted so it doesn't need to be converted back\n * to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certificate.\n */\n\n\npki.certificateFromPem = function (pem, computeHash, strict) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if (msg.type !== 'CERTIFICATE' && msg.type !== 'X509 CERTIFICATE' && msg.type !== 'TRUSTED CERTIFICATE') {\n    var error = new Error('Could not convert certificate from PEM; PEM header type ' + 'is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n\n  if (msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert certificate from PEM; PEM is encrypted.');\n  } // convert DER to ASN.1 object\n\n\n  var obj = asn1.fromDer(msg.body, strict);\n  return pki.certificateFromAsn1(obj, computeHash);\n};\n/**\n * Converts an X.509 certificate to PEM format.\n *\n * @param cert the certificate.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certificate.\n */\n\n\npki.certificateToPem = function (cert, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'CERTIFICATE',\n    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()\n  };\n  return forge.pem.encode(msg, {\n    maxline: maxline\n  });\n};\n/**\n * Converts an RSA public key from PEM format.\n *\n * @param pem the PEM-formatted public key.\n *\n * @return the public key.\n */\n\n\npki.publicKeyFromPem = function (pem) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if (msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {\n    var error = new Error('Could not convert public key from PEM; PEM header ' + 'type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n\n  if (msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert public key from PEM; PEM is encrypted.');\n  } // convert DER to ASN.1 object\n\n\n  var obj = asn1.fromDer(msg.body);\n  return pki.publicKeyFromAsn1(obj);\n};\n/**\n * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */\n\n\npki.publicKeyToPem = function (key, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'PUBLIC KEY',\n    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()\n  };\n  return forge.pem.encode(msg, {\n    maxline: maxline\n  });\n};\n/**\n * Converts an RSA public key to PEM format (using an RSAPublicKey).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */\n\n\npki.publicKeyToRSAPublicKeyPem = function (key, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'RSA PUBLIC KEY',\n    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()\n  };\n  return forge.pem.encode(msg, {\n    maxline: maxline\n  });\n};\n/**\n * Gets a fingerprint for the given public key.\n *\n * @param options the options to use.\n *          [md] the message digest object to use (defaults to forge.md.sha1).\n *          [type] the type of fingerprint, such as 'RSAPublicKey',\n *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').\n *          [encoding] an alternative output encoding, such as 'hex'\n *            (defaults to none, outputs a byte buffer).\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\n *            output, eg: ':' (defaults to none).\n *\n * @return the fingerprint as a byte buffer or other encoding based on options.\n */\n\n\npki.getPublicKeyFingerprint = function (key, options) {\n  options = options || {};\n  var md = options.md || forge.md.sha1.create();\n  var type = options.type || 'RSAPublicKey';\n  var bytes;\n\n  switch (type) {\n    case 'RSAPublicKey':\n      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();\n      break;\n\n    case 'SubjectPublicKeyInfo':\n      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();\n      break;\n\n    default:\n      throw new Error('Unknown fingerprint type \"' + options.type + '\".');\n  } // hash public key bytes\n\n\n  md.start();\n  md.update(bytes);\n  var digest = md.digest();\n\n  if (options.encoding === 'hex') {\n    var hex = digest.toHex();\n\n    if (options.delimiter) {\n      return hex.match(/.{2}/g).join(options.delimiter);\n    }\n\n    return hex;\n  } else if (options.encoding === 'binary') {\n    return digest.getBytes();\n  } else if (options.encoding) {\n    throw new Error('Unknown encoding \"' + options.encoding + '\".');\n  }\n\n  return digest;\n};\n/**\n * Converts a PKCS#10 certification request (CSR) from PEM format.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. This will scan the CertificationRequestInfo part of\n * the ASN.1 object while it is converted so it doesn't need to be converted\n * back to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certification request (CSR).\n */\n\n\npki.certificationRequestFromPem = function (pem, computeHash, strict) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if (msg.type !== 'CERTIFICATE REQUEST') {\n    var error = new Error('Could not convert certification request from PEM; ' + 'PEM header type is not \"CERTIFICATE REQUEST\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n\n  if (msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert certification request from PEM; ' + 'PEM is encrypted.');\n  } // convert DER to ASN.1 object\n\n\n  var obj = asn1.fromDer(msg.body, strict);\n  return pki.certificationRequestFromAsn1(obj, computeHash);\n};\n/**\n * Converts a PKCS#10 certification request (CSR) to PEM format.\n *\n * @param csr the certification request.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certification request.\n */\n\n\npki.certificationRequestToPem = function (csr, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'CERTIFICATE REQUEST',\n    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()\n  };\n  return forge.pem.encode(msg, {\n    maxline: maxline\n  });\n};\n/**\n * Creates an empty X.509v3 RSA certificate.\n *\n * @return the certificate.\n */\n\n\npki.createCertificate = function () {\n  var cert = {};\n  cert.version = 0x02;\n  cert.serialNumber = '00';\n  cert.signatureOid = null;\n  cert.signature = null;\n  cert.siginfo = {};\n  cert.siginfo.algorithmOid = null;\n  cert.validity = {};\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.issuer = {};\n\n  cert.issuer.getField = function (sn) {\n    return _getAttribute(cert.issuer, sn);\n  };\n\n  cert.issuer.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    cert.issuer.attributes.push(attr);\n  };\n\n  cert.issuer.attributes = [];\n  cert.issuer.hash = null;\n  cert.subject = {};\n\n  cert.subject.getField = function (sn) {\n    return _getAttribute(cert.subject, sn);\n  };\n\n  cert.subject.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    cert.subject.attributes.push(attr);\n  };\n\n  cert.subject.attributes = [];\n  cert.subject.hash = null;\n  cert.extensions = [];\n  cert.publicKey = null;\n  cert.md = null;\n  /**\n   * Sets the subject of this certificate.\n   *\n   * @param attrs the array of subject attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */\n\n  cert.setSubject = function (attrs, uniqueId) {\n    // set new attributes, clear hash\n    _fillMissingFields(attrs);\n\n    cert.subject.attributes = attrs;\n    delete cert.subject.uniqueId;\n\n    if (uniqueId) {\n      // TODO: support arbitrary bit length ids\n      cert.subject.uniqueId = uniqueId;\n    }\n\n    cert.subject.hash = null;\n  };\n  /**\n   * Sets the issuer of this certificate.\n   *\n   * @param attrs the array of issuer attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */\n\n\n  cert.setIssuer = function (attrs, uniqueId) {\n    // set new attributes, clear hash\n    _fillMissingFields(attrs);\n\n    cert.issuer.attributes = attrs;\n    delete cert.issuer.uniqueId;\n\n    if (uniqueId) {\n      // TODO: support arbitrary bit length ids\n      cert.issuer.uniqueId = uniqueId;\n    }\n\n    cert.issuer.hash = null;\n  };\n  /**\n   * Sets the extensions of this certificate.\n   *\n   * @param exts the array of extensions to use.\n   */\n\n\n  cert.setExtensions = function (exts) {\n    for (var i = 0; i < exts.length; ++i) {\n      _fillMissingExtensionFields(exts[i], {\n        cert: cert\n      });\n    } // set new extensions\n\n\n    cert.extensions = exts;\n  };\n  /**\n   * Gets an extension by its name or id.\n   *\n   * @param options the name to use or an object with:\n   *          name the name to use.\n   *          id the id to use.\n   *\n   * @return the extension or null if not found.\n   */\n\n\n  cert.getExtension = function (options) {\n    if (typeof options === 'string') {\n      options = {\n        name: options\n      };\n    }\n\n    var rval = null;\n    var ext;\n\n    for (var i = 0; rval === null && i < cert.extensions.length; ++i) {\n      ext = cert.extensions[i];\n\n      if (options.id && ext.id === options.id) {\n        rval = ext;\n      } else if (options.name && ext.name === options.name) {\n        rval = ext;\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Signs this certificate using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */\n\n\n  cert.sign = function (key, md) {\n    // TODO: get signature OID from private key\n    cert.md = md || forge.md.sha1.create();\n    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];\n\n    if (!algorithmOid) {\n      var error = new Error('Could not compute certificate digest. ' + 'Unknown message digest algorithm OID.');\n      error.algorithm = cert.md.algorithm;\n      throw error;\n    }\n\n    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid; // get TBSCertificate, convert to DER\n\n    cert.tbsCertificate = pki.getTBSCertificate(cert);\n    var bytes = asn1.toDer(cert.tbsCertificate); // digest and sign\n\n    cert.md.update(bytes.getBytes());\n    cert.signature = key.sign(cert.md);\n  };\n  /**\n   * Attempts verify the signature on the passed certificate using this\n   * certificate's public key.\n   *\n   * @param child the certificate to verify.\n   *\n   * @return true if verified, false if not.\n   */\n\n\n  cert.verify = function (child) {\n    var rval = false;\n\n    if (!cert.issued(child)) {\n      var issuer = child.issuer;\n      var subject = cert.subject;\n      var error = new Error('The parent certificate did not issue the given child ' + 'certificate; the child certificate\\'s issuer does not match the ' + 'parent\\'s subject.');\n      error.expectedIssuer = issuer.attributes;\n      error.actualIssuer = subject.attributes;\n      throw error;\n    }\n\n    var md = child.md;\n\n    if (md === null) {\n      // check signature OID for supported signature types\n      if (child.signatureOid in oids) {\n        var oid = oids[child.signatureOid];\n\n        switch (oid) {\n          case 'sha1WithRSAEncryption':\n            md = forge.md.sha1.create();\n            break;\n\n          case 'md5WithRSAEncryption':\n            md = forge.md.md5.create();\n            break;\n\n          case 'sha256WithRSAEncryption':\n            md = forge.md.sha256.create();\n            break;\n\n          case 'sha384WithRSAEncryption':\n            md = forge.md.sha384.create();\n            break;\n\n          case 'sha512WithRSAEncryption':\n            md = forge.md.sha512.create();\n            break;\n\n          case 'RSASSA-PSS':\n            md = forge.md.sha256.create();\n            break;\n        }\n      }\n\n      if (md === null) {\n        var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');\n        error.signatureOid = child.signatureOid;\n        throw error;\n      } // produce DER formatted TBSCertificate and digest it\n\n\n      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);\n      var bytes = asn1.toDer(tbsCertificate);\n      md.update(bytes.getBytes());\n    }\n\n    if (md !== null) {\n      var scheme;\n\n      switch (child.signatureOid) {\n        case oids.sha1WithRSAEncryption:\n          scheme = undefined;\n          /* use PKCS#1 v1.5 padding scheme */\n\n          break;\n\n        case oids['RSASSA-PSS']:\n          var hash, mgf;\n          /* initialize mgf */\n\n          hash = oids[child.signatureParameters.mgf.hash.algorithmOid];\n\n          if (hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported MGF hash function.');\n            error.oid = child.signatureParameters.mgf.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          mgf = oids[child.signatureParameters.mgf.algorithmOid];\n\n          if (mgf === undefined || forge.mgf[mgf] === undefined) {\n            var error = new Error('Unsupported MGF function.');\n            error.oid = child.signatureParameters.mgf.algorithmOid;\n            error.name = mgf;\n            throw error;\n          }\n\n          mgf = forge.mgf[mgf].create(forge.md[hash].create());\n          /* initialize hash function */\n\n          hash = oids[child.signatureParameters.hash.algorithmOid];\n\n          if (hash === undefined || forge.md[hash] === undefined) {\n            throw {\n              message: 'Unsupported RSASSA-PSS hash function.',\n              oid: child.signatureParameters.hash.algorithmOid,\n              name: hash\n            };\n          }\n\n          scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);\n          break;\n      } // verify signature on cert using public key\n\n\n      rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);\n    }\n\n    return rval;\n  };\n  /**\n   * Returns true if this certificate's issuer matches the passed\n   * certificate's subject. Note that no signature check is performed.\n   *\n   * @param parent the certificate to check.\n   *\n   * @return true if this certificate's issuer matches the passed certificate's\n   *         subject.\n   */\n\n\n  cert.isIssuer = function (parent) {\n    var rval = false;\n    var i = cert.issuer;\n    var s = parent.subject; // compare hashes if present\n\n    if (i.hash && s.hash) {\n      rval = i.hash === s.hash;\n    } else if (i.attributes.length === s.attributes.length) {\n      // all attributes are the same so issuer matches subject\n      rval = true;\n      var iattr, sattr;\n\n      for (var n = 0; rval && n < i.attributes.length; ++n) {\n        iattr = i.attributes[n];\n        sattr = s.attributes[n];\n\n        if (iattr.type !== sattr.type || iattr.value !== sattr.value) {\n          // attribute mismatch\n          rval = false;\n        }\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Returns true if this certificate's subject matches the issuer of the\n   * given certificate). Note that not signature check is performed.\n   *\n   * @param child the certificate to check.\n   *\n   * @return true if this certificate's subject matches the passed\n   *         certificate's issuer.\n   */\n\n\n  cert.issued = function (child) {\n    return child.isIssuer(cert);\n  };\n  /**\n   * Generates the subjectKeyIdentifier for this certificate as byte buffer.\n   *\n   * @return the subjectKeyIdentifier for this certificate as byte buffer.\n   */\n\n\n  cert.generateSubjectKeyIdentifier = function () {\n    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:\n       (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the\n        value of the BIT STRING subjectPublicKey (excluding the tag,\n        length, and number of unused bits).\n       (2) The keyIdentifier is composed of a four bit type field with\n        the value 0100 followed by the least significant 60 bits of the\n        SHA-1 hash of the value of the BIT STRING subjectPublicKey\n        (excluding the tag, length, and number of unused bit string bits).\n    */\n    // skipping the tag, length, and number of unused bits is the same\n    // as just using the RSAPublicKey (for RSA keys, which are the\n    // only ones supported)\n    return pki.getPublicKeyFingerprint(cert.publicKey, {\n      type: 'RSAPublicKey'\n    });\n  };\n  /**\n   * Verifies the subjectKeyIdentifier extension value for this certificate\n   * against its public key. If no extension is found, false will be\n   * returned.\n   *\n   * @return true if verified, false if not.\n   */\n\n\n  cert.verifySubjectKeyIdentifier = function () {\n    var oid = oids['subjectKeyIdentifier'];\n\n    for (var i = 0; i < cert.extensions.length; ++i) {\n      var ext = cert.extensions[i];\n\n      if (ext.id === oid) {\n        var ski = cert.generateSubjectKeyIdentifier().getBytes();\n        return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;\n      }\n    }\n\n    return false;\n  };\n\n  return cert;\n};\n/**\n * Converts an X.509v3 RSA certificate from an ASN.1 object.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1\n * object needs to be scanned before the cert object is created.\n *\n * @param obj the asn1 representation of an X.509v3 RSA certificate.\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certificate.\n */\n\n\npki.certificateFromAsn1 = function (obj, computeHash) {\n  // validate certificate and capture data\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\n    var error = new Error('Cannot read X.509 certificate. ' + 'ASN.1 object is not an X509v3 Certificate.');\n    error.errors = errors;\n    throw error;\n  } // get oid\n\n\n  var oid = asn1.derToOid(capture.publicKeyOid);\n\n  if (oid !== pki.oids.rsaEncryption) {\n    throw new Error('Cannot read public key. OID is not RSA.');\n  } // create certificate\n\n\n  var cert = pki.createCertificate();\n  cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;\n  var serial = forge.util.createBuffer(capture.certSerialNumber);\n  cert.serialNumber = serial.toHex();\n  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\n  cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);\n  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\n  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);\n  cert.signature = capture.certSignature;\n  var validity = [];\n\n  if (capture.certValidity1UTCTime !== undefined) {\n    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\n  }\n\n  if (capture.certValidity2GeneralizedTime !== undefined) {\n    validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));\n  }\n\n  if (capture.certValidity3UTCTime !== undefined) {\n    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\n  }\n\n  if (capture.certValidity4GeneralizedTime !== undefined) {\n    validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));\n  }\n\n  if (validity.length > 2) {\n    throw new Error('Cannot read notBefore/notAfter validity times; more ' + 'than two times were provided in the certificate.');\n  }\n\n  if (validity.length < 2) {\n    throw new Error('Cannot read notBefore/notAfter validity times; they ' + 'were not provided as either UTCTime or GeneralizedTime.');\n  }\n\n  cert.validity.notBefore = validity[0];\n  cert.validity.notAfter = validity[1]; // keep TBSCertificate to preserve signature when exporting\n\n  cert.tbsCertificate = capture.tbsCertificate;\n\n  if (computeHash) {\n    // check signature OID for supported signature types\n    cert.md = null;\n\n    if (cert.signatureOid in oids) {\n      var oid = oids[cert.signatureOid];\n\n      switch (oid) {\n        case 'sha1WithRSAEncryption':\n          cert.md = forge.md.sha1.create();\n          break;\n\n        case 'md5WithRSAEncryption':\n          cert.md = forge.md.md5.create();\n          break;\n\n        case 'sha256WithRSAEncryption':\n          cert.md = forge.md.sha256.create();\n          break;\n\n        case 'sha384WithRSAEncryption':\n          cert.md = forge.md.sha384.create();\n          break;\n\n        case 'sha512WithRSAEncryption':\n          cert.md = forge.md.sha512.create();\n          break;\n\n        case 'RSASSA-PSS':\n          cert.md = forge.md.sha256.create();\n          break;\n      }\n    }\n\n    if (cert.md === null) {\n      var error = new Error('Could not compute certificate digest. ' + 'Unknown signature OID.');\n      error.signatureOid = cert.signatureOid;\n      throw error;\n    } // produce DER formatted TBSCertificate and digest it\n\n\n    var bytes = asn1.toDer(cert.tbsCertificate);\n    cert.md.update(bytes.getBytes());\n  } // handle issuer, build issuer message digest\n\n\n  var imd = forge.md.sha1.create();\n\n  cert.issuer.getField = function (sn) {\n    return _getAttribute(cert.issuer, sn);\n  };\n\n  cert.issuer.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    cert.issuer.attributes.push(attr);\n  };\n\n  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);\n\n  if (capture.certIssuerUniqueId) {\n    cert.issuer.uniqueId = capture.certIssuerUniqueId;\n  }\n\n  cert.issuer.hash = imd.digest().toHex(); // handle subject, build subject message digest\n\n  var smd = forge.md.sha1.create();\n\n  cert.subject.getField = function (sn) {\n    return _getAttribute(cert.subject, sn);\n  };\n\n  cert.subject.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    cert.subject.attributes.push(attr);\n  };\n\n  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);\n\n  if (capture.certSubjectUniqueId) {\n    cert.subject.uniqueId = capture.certSubjectUniqueId;\n  }\n\n  cert.subject.hash = smd.digest().toHex(); // handle extensions\n\n  if (capture.certExtensions) {\n    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);\n  } else {\n    cert.extensions = [];\n  } // convert RSA public key from ASN.1\n\n\n  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n  return cert;\n};\n/**\n * Converts an ASN.1 extensions object (with extension sequences as its\n * values) into an array of extension objects with types and values.\n *\n * Supported extensions:\n *\n * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\n * KeyUsage ::= BIT STRING {\n *   digitalSignature        (0),\n *   nonRepudiation          (1),\n *   keyEncipherment         (2),\n *   dataEncipherment        (3),\n *   keyAgreement            (4),\n *   keyCertSign             (5),\n *   cRLSign                 (6),\n *   encipherOnly            (7),\n *   decipherOnly            (8)\n * }\n *\n * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\n * BasicConstraints ::= SEQUENCE {\n *   cA                      BOOLEAN DEFAULT FALSE,\n *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL\n * }\n *\n * subjectAltName EXTENSION ::= {\n *   SYNTAX GeneralNames\n *   IDENTIFIED BY id-ce-subjectAltName\n * }\n *\n * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n *\n * GeneralName ::= CHOICE {\n *   otherName      [0] INSTANCE OF OTHER-NAME,\n *   rfc822Name     [1] IA5String,\n *   dNSName        [2] IA5String,\n *   x400Address    [3] ORAddress,\n *   directoryName  [4] Name,\n *   ediPartyName   [5] EDIPartyName,\n *   uniformResourceIdentifier [6] IA5String,\n *   IPAddress      [7] OCTET STRING,\n *   registeredID   [8] OBJECT IDENTIFIER\n * }\n *\n * OTHER-NAME ::= TYPE-IDENTIFIER\n *\n * EDIPartyName ::= SEQUENCE {\n *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,\n *   partyName    [1] DirectoryString {ub-name}\n * }\n *\n * @param exts the extensions ASN.1 with extension sequences to parse.\n *\n * @return the array.\n */\n\n\npki.certificateExtensionsFromAsn1 = function (exts) {\n  var rval = [];\n\n  for (var i = 0; i < exts.value.length; ++i) {\n    // get extension sequence\n    var extseq = exts.value[i];\n\n    for (var ei = 0; ei < extseq.value.length; ++ei) {\n      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));\n    }\n  }\n\n  return rval;\n};\n/**\n * Parses a single certificate extension from ASN.1.\n *\n * @param ext the extension in ASN.1 format.\n *\n * @return the parsed extension as an object.\n */\n\n\npki.certificateExtensionFromAsn1 = function (ext) {\n  // an extension has:\n  // [0] extnID      OBJECT IDENTIFIER\n  // [1] critical    BOOLEAN DEFAULT FALSE\n  // [2] extnValue   OCTET STRING\n  var e = {};\n  e.id = asn1.derToOid(ext.value[0].value);\n  e.critical = false;\n\n  if (ext.value[1].type === asn1.Type.BOOLEAN) {\n    e.critical = ext.value[1].value.charCodeAt(0) !== 0x00;\n    e.value = ext.value[2].value;\n  } else {\n    e.value = ext.value[1].value;\n  } // if the oid is known, get its name\n\n\n  if (e.id in oids) {\n    e.name = oids[e.id]; // handle key usage\n\n    if (e.name === 'keyUsage') {\n      // get value as BIT STRING\n      var ev = asn1.fromDer(e.value);\n      var b2 = 0x00;\n      var b3 = 0x00;\n\n      if (ev.value.length > 1) {\n        // skip first byte, just indicates unused bits which\n        // will be padded with 0s anyway\n        // get bytes with flag bits\n        b2 = ev.value.charCodeAt(1);\n        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\n      } // set flags\n\n\n      e.digitalSignature = (b2 & 0x80) === 0x80;\n      e.nonRepudiation = (b2 & 0x40) === 0x40;\n      e.keyEncipherment = (b2 & 0x20) === 0x20;\n      e.dataEncipherment = (b2 & 0x10) === 0x10;\n      e.keyAgreement = (b2 & 0x08) === 0x08;\n      e.keyCertSign = (b2 & 0x04) === 0x04;\n      e.cRLSign = (b2 & 0x02) === 0x02;\n      e.encipherOnly = (b2 & 0x01) === 0x01;\n      e.decipherOnly = (b3 & 0x80) === 0x80;\n    } else if (e.name === 'basicConstraints') {\n      // handle basic constraints\n      // get value as SEQUENCE\n      var ev = asn1.fromDer(e.value); // get cA BOOLEAN flag (defaults to false)\n\n      if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\n        e.cA = ev.value[0].value.charCodeAt(0) !== 0x00;\n      } else {\n        e.cA = false;\n      } // get path length constraint\n\n\n      var value = null;\n\n      if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\n        value = ev.value[0].value;\n      } else if (ev.value.length > 1) {\n        value = ev.value[1].value;\n      }\n\n      if (value !== null) {\n        e.pathLenConstraint = asn1.derToInteger(value);\n      }\n    } else if (e.name === 'extKeyUsage') {\n      // handle extKeyUsage\n      // value is a SEQUENCE of OIDs\n      var ev = asn1.fromDer(e.value);\n\n      for (var vi = 0; vi < ev.value.length; ++vi) {\n        var oid = asn1.derToOid(ev.value[vi].value);\n\n        if (oid in oids) {\n          e[oids[oid]] = true;\n        } else {\n          e[oid] = true;\n        }\n      }\n    } else if (e.name === 'nsCertType') {\n      // handle nsCertType\n      // get value as BIT STRING\n      var ev = asn1.fromDer(e.value);\n      var b2 = 0x00;\n\n      if (ev.value.length > 1) {\n        // skip first byte, just indicates unused bits which\n        // will be padded with 0s anyway\n        // get bytes with flag bits\n        b2 = ev.value.charCodeAt(1);\n      } // set flags\n\n\n      e.client = (b2 & 0x80) === 0x80;\n      e.server = (b2 & 0x40) === 0x40;\n      e.email = (b2 & 0x20) === 0x20;\n      e.objsign = (b2 & 0x10) === 0x10;\n      e.reserved = (b2 & 0x08) === 0x08;\n      e.sslCA = (b2 & 0x04) === 0x04;\n      e.emailCA = (b2 & 0x02) === 0x02;\n      e.objCA = (b2 & 0x01) === 0x01;\n    } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {\n      // handle subjectAltName/issuerAltName\n      e.altNames = []; // ev is a SYNTAX SEQUENCE\n\n      var gn;\n      var ev = asn1.fromDer(e.value);\n\n      for (var n = 0; n < ev.value.length; ++n) {\n        // get GeneralName\n        gn = ev.value[n];\n        var altName = {\n          type: gn.type,\n          value: gn.value\n        };\n        e.altNames.push(altName); // Note: Support for types 1,2,6,7,8\n\n        switch (gn.type) {\n          // rfc822Name\n          case 1: // dNSName\n\n          case 2: // uniformResourceIdentifier (URI)\n\n          case 6:\n            break;\n          // IPAddress\n\n          case 7:\n            // convert to IPv4/IPv6 string representation\n            altName.ip = forge.util.bytesToIP(gn.value);\n            break;\n          // registeredID\n\n          case 8:\n            altName.oid = asn1.derToOid(gn.value);\n            break;\n\n          default: // unsupported\n\n        }\n      }\n    } else if (e.name === 'subjectKeyIdentifier') {\n      // value is an OCTETSTRING w/the hash of the key-type specific\n      // public key structure (eg: RSAPublicKey)\n      var ev = asn1.fromDer(e.value);\n      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\n    }\n  }\n\n  return e;\n};\n/**\n * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the CertificationRequestInfo part of the\n * ASN.1 object needs to be scanned before the csr object is created.\n *\n * @param obj the asn1 representation of a PKCS#10 certification request (CSR).\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certification request (CSR).\n */\n\n\npki.certificationRequestFromAsn1 = function (obj, computeHash) {\n  // validate certification request and capture data\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#10 certificate request. ' + 'ASN.1 object is not a PKCS#10 CertificationRequest.');\n    error.errors = errors;\n    throw error;\n  } // get oid\n\n\n  var oid = asn1.derToOid(capture.publicKeyOid);\n\n  if (oid !== pki.oids.rsaEncryption) {\n    throw new Error('Cannot read public key. OID is not RSA.');\n  } // create certification request\n\n\n  var csr = pki.createCertificationRequest();\n  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\n  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\n  csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);\n  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\n  csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);\n  csr.signature = capture.csrSignature; // keep CertificationRequestInfo to preserve signature when exporting\n\n  csr.certificationRequestInfo = capture.certificationRequestInfo;\n\n  if (computeHash) {\n    // check signature OID for supported signature types\n    csr.md = null;\n\n    if (csr.signatureOid in oids) {\n      var oid = oids[csr.signatureOid];\n\n      switch (oid) {\n        case 'sha1WithRSAEncryption':\n          csr.md = forge.md.sha1.create();\n          break;\n\n        case 'md5WithRSAEncryption':\n          csr.md = forge.md.md5.create();\n          break;\n\n        case 'sha256WithRSAEncryption':\n          csr.md = forge.md.sha256.create();\n          break;\n\n        case 'sha384WithRSAEncryption':\n          csr.md = forge.md.sha384.create();\n          break;\n\n        case 'sha512WithRSAEncryption':\n          csr.md = forge.md.sha512.create();\n          break;\n\n        case 'RSASSA-PSS':\n          csr.md = forge.md.sha256.create();\n          break;\n      }\n    }\n\n    if (csr.md === null) {\n      var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');\n      error.signatureOid = csr.signatureOid;\n      throw error;\n    } // produce DER formatted CertificationRequestInfo and digest it\n\n\n    var bytes = asn1.toDer(csr.certificationRequestInfo);\n    csr.md.update(bytes.getBytes());\n  } // handle subject, build subject message digest\n\n\n  var smd = forge.md.sha1.create();\n\n  csr.subject.getField = function (sn) {\n    return _getAttribute(csr.subject, sn);\n  };\n\n  csr.subject.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    csr.subject.attributes.push(attr);\n  };\n\n  csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);\n  csr.subject.hash = smd.digest().toHex(); // convert RSA public key from ASN.1\n\n  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo); // convert attributes from ASN.1\n\n  csr.getAttribute = function (sn) {\n    return _getAttribute(csr, sn);\n  };\n\n  csr.addAttribute = function (attr) {\n    _fillMissingFields([attr]);\n\n    csr.attributes.push(attr);\n  };\n\n  csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);\n  return csr;\n};\n/**\n * Creates an empty certification request (a CSR or certificate signing\n * request). Once created, its public key and attributes can be set and then\n * it can be signed.\n *\n * @return the empty certification request.\n */\n\n\npki.createCertificationRequest = function () {\n  var csr = {};\n  csr.version = 0x00;\n  csr.signatureOid = null;\n  csr.signature = null;\n  csr.siginfo = {};\n  csr.siginfo.algorithmOid = null;\n  csr.subject = {};\n\n  csr.subject.getField = function (sn) {\n    return _getAttribute(csr.subject, sn);\n  };\n\n  csr.subject.addField = function (attr) {\n    _fillMissingFields([attr]);\n\n    csr.subject.attributes.push(attr);\n  };\n\n  csr.subject.attributes = [];\n  csr.subject.hash = null;\n  csr.publicKey = null;\n  csr.attributes = [];\n\n  csr.getAttribute = function (sn) {\n    return _getAttribute(csr, sn);\n  };\n\n  csr.addAttribute = function (attr) {\n    _fillMissingFields([attr]);\n\n    csr.attributes.push(attr);\n  };\n\n  csr.md = null;\n  /**\n   * Sets the subject of this certification request.\n   *\n   * @param attrs the array of subject attributes to use.\n   */\n\n  csr.setSubject = function (attrs) {\n    // set new attributes\n    _fillMissingFields(attrs);\n\n    csr.subject.attributes = attrs;\n    csr.subject.hash = null;\n  };\n  /**\n   * Sets the attributes of this certification request.\n   *\n   * @param attrs the array of attributes to use.\n   */\n\n\n  csr.setAttributes = function (attrs) {\n    // set new attributes\n    _fillMissingFields(attrs);\n\n    csr.attributes = attrs;\n  };\n  /**\n   * Signs this certification request using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */\n\n\n  csr.sign = function (key, md) {\n    // TODO: get signature OID from private key\n    csr.md = md || forge.md.sha1.create();\n    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];\n\n    if (!algorithmOid) {\n      var error = new Error('Could not compute certification request digest. ' + 'Unknown message digest algorithm OID.');\n      error.algorithm = csr.md.algorithm;\n      throw error;\n    }\n\n    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid; // get CertificationRequestInfo, convert to DER\n\n    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);\n    var bytes = asn1.toDer(csr.certificationRequestInfo); // digest and sign\n\n    csr.md.update(bytes.getBytes());\n    csr.signature = key.sign(csr.md);\n  };\n  /**\n   * Attempts verify the signature on the passed certification request using\n   * its public key.\n   *\n   * A CSR that has been exported to a file in PEM format can be verified using\n   * OpenSSL using this command:\n   *\n   * openssl req -in <the-csr-pem-file> -verify -noout -text\n   *\n   * @return true if verified, false if not.\n   */\n\n\n  csr.verify = function () {\n    var rval = false;\n    var md = csr.md;\n\n    if (md === null) {\n      // check signature OID for supported signature types\n      if (csr.signatureOid in oids) {\n        // TODO: create DRY `OID to md` function\n        var oid = oids[csr.signatureOid];\n\n        switch (oid) {\n          case 'sha1WithRSAEncryption':\n            md = forge.md.sha1.create();\n            break;\n\n          case 'md5WithRSAEncryption':\n            md = forge.md.md5.create();\n            break;\n\n          case 'sha256WithRSAEncryption':\n            md = forge.md.sha256.create();\n            break;\n\n          case 'sha384WithRSAEncryption':\n            md = forge.md.sha384.create();\n            break;\n\n          case 'sha512WithRSAEncryption':\n            md = forge.md.sha512.create();\n            break;\n\n          case 'RSASSA-PSS':\n            md = forge.md.sha256.create();\n            break;\n        }\n      }\n\n      if (md === null) {\n        var error = new Error('Could not compute certification request digest. ' + 'Unknown signature OID.');\n        error.signatureOid = csr.signatureOid;\n        throw error;\n      } // produce DER formatted CertificationRequestInfo and digest it\n\n\n      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);\n      var bytes = asn1.toDer(cri);\n      md.update(bytes.getBytes());\n    }\n\n    if (md !== null) {\n      var scheme;\n\n      switch (csr.signatureOid) {\n        case oids.sha1WithRSAEncryption:\n          /* use PKCS#1 v1.5 padding scheme */\n          break;\n\n        case oids['RSASSA-PSS']:\n          var hash, mgf;\n          /* initialize mgf */\n\n          hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];\n\n          if (hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported MGF hash function.');\n            error.oid = csr.signatureParameters.mgf.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          mgf = oids[csr.signatureParameters.mgf.algorithmOid];\n\n          if (mgf === undefined || forge.mgf[mgf] === undefined) {\n            var error = new Error('Unsupported MGF function.');\n            error.oid = csr.signatureParameters.mgf.algorithmOid;\n            error.name = mgf;\n            throw error;\n          }\n\n          mgf = forge.mgf[mgf].create(forge.md[hash].create());\n          /* initialize hash function */\n\n          hash = oids[csr.signatureParameters.hash.algorithmOid];\n\n          if (hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported RSASSA-PSS hash function.');\n            error.oid = csr.signatureParameters.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);\n          break;\n      } // verify signature on csr using its public key\n\n\n      rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);\n    }\n\n    return rval;\n  };\n\n  return csr;\n};\n/**\n * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.\n *\n * @param obj the subject or issuer (distinguished name).\n *\n * @return the ASN.1 RDNSequence.\n */\n\n\nfunction _dnToAsn1(obj) {\n  // create an empty RDNSequence\n  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // iterate over attributes\n\n  var attr, set;\n  var attrs = obj.attributes;\n\n  for (var i = 0; i < attrs.length; ++i) {\n    attr = attrs[i];\n    var value = attr.value; // reuse tag class for attribute value if available\n\n    var valueTagClass = asn1.Type.PRINTABLESTRING;\n\n    if ('valueTagClass' in attr) {\n      valueTagClass = attr.valueTagClass;\n\n      if (valueTagClass === asn1.Type.UTF8) {\n        value = forge.util.encodeUtf8(value);\n      } // FIXME: handle more encodings\n\n    } // create a RelativeDistinguishedName set\n    // each value in the set is an AttributeTypeAndValue first\n    // containing the type (an OID) and second the value\n\n\n    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AttributeType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), // AttributeValue\n    asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);\n    rval.value.push(set);\n  }\n\n  return rval;\n}\n/**\n * Gets all printable attributes (typically of an issuer or subject) in a\n * simplified JSON format for display.\n *\n * @param attrs the attributes.\n *\n * @return the JSON for display.\n */\n\n\nfunction _getAttributesAsJson(attrs) {\n  var rval = {};\n\n  for (var i = 0; i < attrs.length; ++i) {\n    var attr = attrs[i];\n\n    if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) {\n      var value = attr.value;\n\n      if (attr.valueTagClass === asn1.Type.UTF8) {\n        value = forge.util.encodeUtf8(attr.value);\n      }\n\n      if (!(attr.shortName in rval)) {\n        rval[attr.shortName] = value;\n      } else if (forge.util.isArray(rval[attr.shortName])) {\n        rval[attr.shortName].push(value);\n      } else {\n        rval[attr.shortName] = [rval[attr.shortName], value];\n      }\n    }\n  }\n\n  return rval;\n}\n/**\n * Fills in missing fields in attributes.\n *\n * @param attrs the attributes to fill missing fields in.\n */\n\n\nfunction _fillMissingFields(attrs) {\n  var attr;\n\n  for (var i = 0; i < attrs.length; ++i) {\n    attr = attrs[i]; // populate missing name\n\n    if (typeof attr.name === 'undefined') {\n      if (attr.type && attr.type in pki.oids) {\n        attr.name = pki.oids[attr.type];\n      } else if (attr.shortName && attr.shortName in _shortNames) {\n        attr.name = pki.oids[_shortNames[attr.shortName]];\n      }\n    } // populate missing type (OID)\n\n\n    if (typeof attr.type === 'undefined') {\n      if (attr.name && attr.name in pki.oids) {\n        attr.type = pki.oids[attr.name];\n      } else {\n        var error = new Error('Attribute type not specified.');\n        error.attribute = attr;\n        throw error;\n      }\n    } // populate missing shortname\n\n\n    if (typeof attr.shortName === 'undefined') {\n      if (attr.name && attr.name in _shortNames) {\n        attr.shortName = _shortNames[attr.name];\n      }\n    } // convert extensions to value\n\n\n    if (attr.type === oids.extensionRequest) {\n      attr.valueConstructed = true;\n      attr.valueTagClass = asn1.Type.SEQUENCE;\n\n      if (!attr.value && attr.extensions) {\n        attr.value = [];\n\n        for (var ei = 0; ei < attr.extensions.length; ++ei) {\n          attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));\n        }\n      }\n    }\n\n    if (typeof attr.value === 'undefined') {\n      var error = new Error('Attribute value not specified.');\n      error.attribute = attr;\n      throw error;\n    }\n  }\n}\n/**\n * Fills in missing fields in certificate extensions.\n *\n * @param e the extension.\n * @param [options] the options to use.\n *          [cert] the certificate the extensions are for.\n *\n * @return the extension.\n */\n\n\nfunction _fillMissingExtensionFields(e, options) {\n  options = options || {}; // populate missing name\n\n  if (typeof e.name === 'undefined') {\n    if (e.id && e.id in pki.oids) {\n      e.name = pki.oids[e.id];\n    }\n  } // populate missing id\n\n\n  if (typeof e.id === 'undefined') {\n    if (e.name && e.name in pki.oids) {\n      e.id = pki.oids[e.name];\n    } else {\n      var error = new Error('Extension ID not specified.');\n      error.extension = e;\n      throw error;\n    }\n  }\n\n  if (typeof e.value !== 'undefined') {\n    return e;\n  } // handle missing value:\n  // value is a BIT STRING\n\n\n  if (e.name === 'keyUsage') {\n    // build flags\n    var unused = 0;\n    var b2 = 0x00;\n    var b3 = 0x00;\n\n    if (e.digitalSignature) {\n      b2 |= 0x80;\n      unused = 7;\n    }\n\n    if (e.nonRepudiation) {\n      b2 |= 0x40;\n      unused = 6;\n    }\n\n    if (e.keyEncipherment) {\n      b2 |= 0x20;\n      unused = 5;\n    }\n\n    if (e.dataEncipherment) {\n      b2 |= 0x10;\n      unused = 4;\n    }\n\n    if (e.keyAgreement) {\n      b2 |= 0x08;\n      unused = 3;\n    }\n\n    if (e.keyCertSign) {\n      b2 |= 0x04;\n      unused = 2;\n    }\n\n    if (e.cRLSign) {\n      b2 |= 0x02;\n      unused = 1;\n    }\n\n    if (e.encipherOnly) {\n      b2 |= 0x01;\n      unused = 0;\n    }\n\n    if (e.decipherOnly) {\n      b3 |= 0x80;\n      unused = 7;\n    } // create bit string\n\n\n    var value = String.fromCharCode(unused);\n\n    if (b3 !== 0) {\n      value += String.fromCharCode(b2) + String.fromCharCode(b3);\n    } else if (b2 !== 0) {\n      value += String.fromCharCode(b2);\n    }\n\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n  } else if (e.name === 'basicConstraints') {\n    // basicConstraints is a SEQUENCE\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // cA BOOLEAN flag defaults to false\n\n    if (e.cA) {\n      e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));\n    }\n\n    if ('pathLenConstraint' in e) {\n      e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));\n    }\n  } else if (e.name === 'extKeyUsage') {\n    // extKeyUsage is a SEQUENCE of OIDs\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value;\n\n    for (var key in e) {\n      if (e[key] !== true) {\n        continue;\n      } // key is name in OID map\n\n\n      if (key in oids) {\n        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));\n      } else if (key.indexOf('.') !== -1) {\n        // assume key is an OID\n        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));\n      }\n    }\n  } else if (e.name === 'nsCertType') {\n    // nsCertType is a BIT STRING\n    // build flags\n    var unused = 0;\n    var b2 = 0x00;\n\n    if (e.client) {\n      b2 |= 0x80;\n      unused = 7;\n    }\n\n    if (e.server) {\n      b2 |= 0x40;\n      unused = 6;\n    }\n\n    if (e.email) {\n      b2 |= 0x20;\n      unused = 5;\n    }\n\n    if (e.objsign) {\n      b2 |= 0x10;\n      unused = 4;\n    }\n\n    if (e.reserved) {\n      b2 |= 0x08;\n      unused = 3;\n    }\n\n    if (e.sslCA) {\n      b2 |= 0x04;\n      unused = 2;\n    }\n\n    if (e.emailCA) {\n      b2 |= 0x02;\n      unused = 1;\n    }\n\n    if (e.objCA) {\n      b2 |= 0x01;\n      unused = 0;\n    } // create bit string\n\n\n    var value = String.fromCharCode(unused);\n\n    if (b2 !== 0) {\n      value += String.fromCharCode(b2);\n    }\n\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n  } else if (e.name === 'subjectAltName' || e.name === 'issuerAltName') {\n    // SYNTAX SEQUENCE\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var altName;\n\n    for (var n = 0; n < e.altNames.length; ++n) {\n      altName = e.altNames[n];\n      var value = altName.value; // handle IP\n\n      if (altName.type === 7 && altName.ip) {\n        value = forge.util.bytesFromIP(altName.ip);\n\n        if (value === null) {\n          var error = new Error('Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n          error.extension = e;\n          throw error;\n        }\n      } else if (altName.type === 8) {\n        // handle OID\n        if (altName.oid) {\n          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n        } else {\n          // deprecated ... convert value to OID\n          value = asn1.oidToDer(value);\n        }\n      }\n\n      e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));\n    }\n  } else if (e.name === 'nsComment' && options.cert) {\n    // sanity check value is ASCII (req'd) and not too big\n    if (!/^[\\x00-\\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {\n      throw new Error('Invalid \"nsComment\" content.');\n    } // IA5STRING opaque comment\n\n\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);\n  } else if (e.name === 'subjectKeyIdentifier' && options.cert) {\n    var ski = options.cert.generateSubjectKeyIdentifier();\n    e.subjectKeyIdentifier = ski.toHex(); // OCTETSTRING w/digest\n\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());\n  } else if (e.name === 'authorityKeyIdentifier' && options.cert) {\n    // SYNTAX SEQUENCE\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value;\n\n    if (e.keyIdentifier) {\n      var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;\n      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));\n    }\n\n    if (e.authorityCertIssuer) {\n      var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [_dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)])];\n      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));\n    }\n\n    if (e.serialNumber) {\n      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);\n      seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));\n    }\n  } else if (e.name === 'cRLDistributionPoints') {\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value; // Create sub SEQUENCE of DistributionPointName\n\n    var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // Create fullName CHOICE\n\n    var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n    var altName;\n\n    for (var n = 0; n < e.altNames.length; ++n) {\n      altName = e.altNames[n];\n      var value = altName.value; // handle IP\n\n      if (altName.type === 7 && altName.ip) {\n        value = forge.util.bytesFromIP(altName.ip);\n\n        if (value === null) {\n          var error = new Error('Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n          error.extension = e;\n          throw error;\n        }\n      } else if (altName.type === 8) {\n        // handle OID\n        if (altName.oid) {\n          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n        } else {\n          // deprecated ... convert value to OID\n          value = asn1.oidToDer(value);\n        }\n      }\n\n      fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));\n    } // Add to the parent SEQUENCE\n\n\n    subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));\n    seq.push(subSeq);\n  } // ensure value has been defined by now\n\n\n  if (typeof e.value === 'undefined') {\n    var error = new Error('Extension value not specified.');\n    error.extension = e;\n    throw error;\n  }\n\n  return e;\n}\n/**\n * Convert signature parameters object to ASN.1\n *\n * @param {String} oid Signature algorithm OID\n * @param params The signature parametrs object\n * @return ASN.1 object representing signature parameters\n */\n\n\nfunction _signatureParametersToAsn1(oid, params) {\n  switch (oid) {\n    case oids['RSASSA-PSS']:\n      var parts = [];\n\n      if (params.hash.algorithmOid !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])]));\n      }\n\n      if (params.mgf.algorithmOid !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')])])]));\n      }\n\n      if (params.saltLength !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));\n      }\n\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\n\n    default:\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');\n  }\n}\n/**\n * Converts a certification request's attributes to an ASN.1 set of\n * CRIAttributes.\n *\n * @param csr certification request.\n *\n * @return the ASN.1 set of CRIAttributes.\n */\n\n\nfunction _CRIAttributesToAsn1(csr) {\n  // create an empty context-specific container\n  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); // no attributes, return empty container\n\n  if (csr.attributes.length === 0) {\n    return rval;\n  } // each attribute has a sequence with a type and a set of values\n\n\n  var attrs = csr.attributes;\n\n  for (var i = 0; i < attrs.length; ++i) {\n    var attr = attrs[i];\n    var value = attr.value; // reuse tag class for attribute value if available\n\n    var valueTagClass = asn1.Type.UTF8;\n\n    if ('valueTagClass' in attr) {\n      valueTagClass = attr.valueTagClass;\n    }\n\n    if (valueTagClass === asn1.Type.UTF8) {\n      value = forge.util.encodeUtf8(value);\n    }\n\n    var valueConstructed = false;\n\n    if ('valueConstructed' in attr) {\n      valueConstructed = attr.valueConstructed;\n    } // FIXME: handle more encodings\n    // create a RelativeDistinguishedName set\n    // each value in the set is an AttributeTypeAndValue first\n    // containing the type (an OID) and second the value\n\n\n    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// AttributeType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [// AttributeValue\n    asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);\n    rval.value.push(seq);\n  }\n\n  return rval;\n}\n\nvar jan_1_1950 = new Date('1950-01-01T00:00:00Z');\nvar jan_1_2050 = new Date('2050-01-01T00:00:00Z');\n/**\n * Converts a Date object to ASN.1\n * Handles the different format before and after 1st January 2050\n *\n * @param date date object.\n *\n * @return the ASN.1 object representing the date.\n */\n\nfunction _dateToAsn1(date) {\n  if (date >= jan_1_1950 && date < jan_1_2050) {\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));\n  } else {\n    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));\n  }\n}\n/**\n * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.\n *\n * @param cert the certificate.\n *\n * @return the asn1 TBSCertificate.\n */\n\n\npki.getTBSCertificate = function (cert) {\n  // TBSCertificate\n  var notBefore = _dateToAsn1(cert.validity.notBefore);\n\n  var notAfter = _dateToAsn1(cert.validity.notAfter);\n\n  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// integer\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]), // serialNumber\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)), // signature\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), // parameters\n  _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), // issuer\n  _dnToAsn1(cert.issuer), // validity\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [notBefore, notAfter]), // subject\n  _dnToAsn1(cert.subject), // SubjectPublicKeyInfo\n  pki.publicKeyToAsn1(cert.publicKey)]);\n\n  if (cert.issuer.uniqueId) {\n    // issuerUniqueID (optional)\n    tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids\n    String.fromCharCode(0x00) + cert.issuer.uniqueId)]));\n  }\n\n  if (cert.subject.uniqueId) {\n    // subjectUniqueID (optional)\n    tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, // TODO: support arbitrary bit length ids\n    String.fromCharCode(0x00) + cert.subject.uniqueId)]));\n  }\n\n  if (cert.extensions.length > 0) {\n    // extensions (optional)\n    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));\n  }\n\n  return tbs;\n};\n/**\n * Gets the ASN.1 CertificationRequestInfo part of a\n * PKCS#10 CertificationRequest.\n *\n * @param csr the certification request.\n *\n * @return the asn1 CertificationRequestInfo.\n */\n\n\npki.getCertificationRequestInfo = function (csr) {\n  // CertificationRequestInfo\n  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()), // subject\n  _dnToAsn1(csr.subject), // SubjectPublicKeyInfo\n  pki.publicKeyToAsn1(csr.publicKey), // attributes\n  _CRIAttributesToAsn1(csr)]);\n  return cri;\n};\n/**\n * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.\n *\n * @param dn the DistinguishedName.\n *\n * @return the asn1 representation of a DistinguishedName.\n */\n\n\npki.distinguishedNameToAsn1 = function (dn) {\n  return _dnToAsn1(dn);\n};\n/**\n * Converts an X.509v3 RSA certificate to an ASN.1 object.\n *\n * @param cert the certificate.\n *\n * @return the asn1 representation of an X.509v3 RSA certificate.\n */\n\n\npki.certificateToAsn1 = function (cert) {\n  // prefer cached TBSCertificate over generating one\n  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert); // Certificate\n\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// TBSCertificate\n  tbsCertificate, // AlgorithmIdentifier (signature algorithm)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), // parameters\n  _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), // SignatureValue\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + cert.signature)]);\n};\n/**\n * Converts X.509v3 certificate extensions to ASN.1.\n *\n * @param exts the extensions to convert.\n *\n * @return the extensions in ASN.1 format.\n */\n\n\npki.certificateExtensionsToAsn1 = function (exts) {\n  // create top-level extension container\n  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []); // create extension sequence (stores a sequence for each extension)\n\n  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  rval.value.push(seq);\n\n  for (var i = 0; i < exts.length; ++i) {\n    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));\n  }\n\n  return rval;\n};\n/**\n * Converts a single certificate extension to ASN.1.\n *\n * @param ext the extension to convert.\n *\n * @return the extension in ASN.1 format.\n */\n\n\npki.certificateExtensionToAsn1 = function (ext) {\n  // create a sequence for each extension\n  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); // extnID (OID)\n\n  extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes())); // critical defaults to false\n\n  if (ext.critical) {\n    // critical BOOLEAN DEFAULT FALSE\n    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(0xFF)));\n  }\n\n  var value = ext.value;\n\n  if (typeof ext.value !== 'string') {\n    // value is asn.1\n    value = asn1.toDer(value).getBytes();\n  } // extnValue (OCTET STRING)\n\n\n  extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));\n  return extseq;\n};\n/**\n * Converts a PKCS#10 certification request to an ASN.1 object.\n *\n * @param csr the certification request.\n *\n * @return the asn1 representation of a certification request.\n */\n\n\npki.certificationRequestToAsn1 = function (csr) {\n  // prefer cached CertificationRequestInfo over generating one\n  var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr); // Certificate\n\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// CertificationRequestInfo\n  cri, // AlgorithmIdentifier (signature algorithm)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), // parameters\n  _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), // signature\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0x00) + csr.signature)]);\n};\n/**\n * Creates a CA store.\n *\n * @param certs an optional array of certificate objects or PEM-formatted\n *          certificate strings to add to the CA store.\n *\n * @return the CA store.\n */\n\n\npki.createCaStore = function (certs) {\n  // create CA store\n  var caStore = {\n    // stored certificates\n    certs: {}\n  };\n  /**\n   * Gets the certificate that issued the passed certificate or its\n   * 'parent'.\n   *\n   * @param cert the certificate to get the parent for.\n   *\n   * @return the parent certificate or null if none was found.\n   */\n\n  caStore.getIssuer = function (cert) {\n    var rval = getBySubject(cert.issuer); // see if there are multiple matches\n\n    /*if(forge.util.isArray(rval)) {\n      // TODO: resolve multiple matches by checking\n      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.\n      // FIXME: or alternatively do authority key mapping\n      // if possible (X.509v1 certs can't work?)\n      throw new Error('Resolving multiple issuer matches not implemented yet.');\n    }*/\n\n    return rval;\n  };\n  /**\n   * Adds a trusted certificate to the store.\n   *\n   * @param cert the certificate to add as a trusted certificate (either a\n   *          pki.certificate object or a PEM-formatted certificate).\n   */\n\n\n  caStore.addCertificate = function (cert) {\n    // convert from pem if necessary\n    if (typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n\n    ensureSubjectHasHash(cert.subject);\n\n    if (!caStore.hasCertificate(cert)) {\n      // avoid duplicate certificates in store\n      if (cert.subject.hash in caStore.certs) {\n        // subject hash already exists, append to array\n        var tmp = caStore.certs[cert.subject.hash];\n\n        if (!forge.util.isArray(tmp)) {\n          tmp = [tmp];\n        }\n\n        tmp.push(cert);\n        caStore.certs[cert.subject.hash] = tmp;\n      } else {\n        caStore.certs[cert.subject.hash] = cert;\n      }\n    }\n  };\n  /**\n   * Checks to see if the given certificate is in the store.\n   *\n   * @param cert the certificate to check (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return true if the certificate is in the store, false if not.\n   */\n\n\n  caStore.hasCertificate = function (cert) {\n    // convert from pem if necessary\n    if (typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n\n    var match = getBySubject(cert.subject);\n\n    if (!match) {\n      return false;\n    }\n\n    if (!forge.util.isArray(match)) {\n      match = [match];\n    } // compare DER-encoding of certificates\n\n\n    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n\n    for (var i = 0; i < match.length; ++i) {\n      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n\n      if (der1 === der2) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Lists all of the certificates kept in the store.\n   *\n   * @return an array of all of the pki.certificate objects in the store.\n   */\n\n\n  caStore.listAllCertificates = function () {\n    var certList = [];\n\n    for (var hash in caStore.certs) {\n      if (caStore.certs.hasOwnProperty(hash)) {\n        var value = caStore.certs[hash];\n\n        if (!forge.util.isArray(value)) {\n          certList.push(value);\n        } else {\n          for (var i = 0; i < value.length; ++i) {\n            certList.push(value[i]);\n          }\n        }\n      }\n    }\n\n    return certList;\n  };\n  /**\n   * Removes a certificate from the store.\n   *\n   * @param cert the certificate to remove (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return the certificate that was removed or null if the certificate\n   *           wasn't in store.\n   */\n\n\n  caStore.removeCertificate = function (cert) {\n    var result; // convert from pem if necessary\n\n    if (typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n\n    ensureSubjectHasHash(cert.subject);\n\n    if (!caStore.hasCertificate(cert)) {\n      return null;\n    }\n\n    var match = getBySubject(cert.subject);\n\n    if (!forge.util.isArray(match)) {\n      result = caStore.certs[cert.subject.hash];\n      delete caStore.certs[cert.subject.hash];\n      return result;\n    } // compare DER-encoding of certificates\n\n\n    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n\n    for (var i = 0; i < match.length; ++i) {\n      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n\n      if (der1 === der2) {\n        result = match[i];\n        match.splice(i, 1);\n      }\n    }\n\n    if (match.length === 0) {\n      delete caStore.certs[cert.subject.hash];\n    }\n\n    return result;\n  };\n\n  function getBySubject(subject) {\n    ensureSubjectHasHash(subject);\n    return caStore.certs[subject.hash] || null;\n  }\n\n  function ensureSubjectHasHash(subject) {\n    // produce subject hash if it doesn't exist\n    if (!subject.hash) {\n      var md = forge.md.sha1.create();\n      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);\n      subject.hash = md.digest().toHex();\n    }\n  } // auto-add passed in certs\n\n\n  if (certs) {\n    // parse PEM-formatted certificates as necessary\n    for (var i = 0; i < certs.length; ++i) {\n      var cert = certs[i];\n      caStore.addCertificate(cert);\n    }\n  }\n\n  return caStore;\n};\n/**\n * Certificate verification errors, based on TLS.\n */\n\n\npki.certificateError = {\n  bad_certificate: 'forge.pki.BadCertificate',\n  unsupported_certificate: 'forge.pki.UnsupportedCertificate',\n  certificate_revoked: 'forge.pki.CertificateRevoked',\n  certificate_expired: 'forge.pki.CertificateExpired',\n  certificate_unknown: 'forge.pki.CertificateUnknown',\n  unknown_ca: 'forge.pki.UnknownCertificateAuthority'\n};\n/**\n * Verifies a certificate chain against the given Certificate Authority store\n * with an optional custom verify callback.\n *\n * @param caStore a certificate store to verify against.\n * @param chain the certificate chain to verify, with the root or highest\n *          authority at the end (an array of certificates).\n * @param options a callback to be called for every certificate in the chain or\n *                  an object with:\n *                  verify a callback to be called for every certificate in the\n *                    chain\n *                  validityCheckDate the date against which the certificate\n *                    validity period should be checked. Pass null to not check\n *                    the validity period. By default, the current date is used.\n *\n * The verify callback has the following signature:\n *\n * verified - Set to true if certificate was verified, otherwise the\n *   pki.certificateError for why the certificate failed.\n * depth - The current index in the chain, where 0 is the end point's cert.\n * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous\n *   end point.\n *\n * The function returns true on success and on failure either the appropriate\n * pki.certificateError or an object with 'error' set to the appropriate\n * pki.certificateError and 'message' set to a custom error message.\n *\n * @return true if successful, error thrown if not.\n */\n\npki.verifyCertificateChain = function (caStore, chain, options) {\n  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate\n    Section 6: Certification Path Validation\n    See inline parentheticals related to this particular implementation.\n     The primary goal of path validation is to verify the binding between\n    a subject distinguished name or a subject alternative name and subject\n    public key, as represented in the end entity certificate, based on the\n    public key of the trust anchor. This requires obtaining a sequence of\n    certificates that support that binding. That sequence should be provided\n    in the passed 'chain'. The trust anchor should be in the given CA\n    store. The 'end entity' certificate is the certificate provided by the\n    end point (typically a server) and is the first in the chain.\n     To meet this goal, the path validation process verifies, among other\n    things, that a prospective certification path (a sequence of n\n    certificates or a 'chain') satisfies the following conditions:\n     (a) for all x in {1, ..., n-1}, the subject of certificate x is\n          the issuer of certificate x+1;\n     (b) certificate 1 is issued by the trust anchor;\n     (c) certificate n is the certificate to be validated; and\n     (d) for all x in {1, ..., n}, the certificate was valid at the\n          time in question.\n     Note that here 'n' is index 0 in the chain and 1 is the last certificate\n    in the chain and it must be signed by a certificate in the connection's\n    CA store.\n     The path validation process also determines the set of certificate\n    policies that are valid for this path, based on the certificate policies\n    extension, policy mapping extension, policy constraints extension, and\n    inhibit any-policy extension.\n     Note: Policy mapping extension not supported (Not Required).\n     Note: If the certificate has an unsupported critical extension, then it\n    must be rejected.\n     Note: A certificate is self-issued if the DNs that appear in the subject\n    and issuer fields are identical and are not empty.\n     The path validation algorithm assumes the following seven inputs are\n    provided to the path processing logic. What this specific implementation\n    will use is provided parenthetically:\n     (a) a prospective certification path of length n (the 'chain')\n    (b) the current date/time: ('now').\n    (c) user-initial-policy-set: A set of certificate policy identifiers\n          naming the policies that are acceptable to the certificate user.\n          The user-initial-policy-set contains the special value any-policy\n          if the user is not concerned about certificate policy\n          (Not implemented. Any policy is accepted).\n    (d) trust anchor information, describing a CA that serves as a trust\n          anchor for the certification path. The trust anchor information\n          includes:\n       (1)  the trusted issuer name,\n      (2)  the trusted public key algorithm,\n      (3)  the trusted public key, and\n      (4)  optionally, the trusted public key parameters associated\n             with the public key.\n       (Trust anchors are provided via certificates in the CA store).\n       The trust anchor information may be provided to the path processing\n      procedure in the form of a self-signed certificate. The trusted anchor\n      information is trusted because it was delivered to the path processing\n      procedure by some trustworthy out-of-band procedure. If the trusted\n      public key algorithm requires parameters, then the parameters are\n      provided along with the trusted public key (No parameters used in this\n      implementation).\n     (e) initial-policy-mapping-inhibit, which indicates if policy mapping is\n          allowed in the certification path.\n          (Not implemented, no policy checking)\n     (f) initial-explicit-policy, which indicates if the path must be valid\n          for at least one of the certificate policies in the user-initial-\n          policy-set.\n          (Not implemented, no policy checking)\n     (g) initial-any-policy-inhibit, which indicates whether the\n          anyPolicy OID should be processed if it is included in a\n          certificate.\n          (Not implemented, so any policy is valid provided that it is\n          not marked as critical) */\n\n  /* Basic Path Processing:\n     For each certificate in the 'chain', the following is checked:\n     1. The certificate validity period includes the current time.\n    2. The certificate was signed by its parent (where the parent is either\n       the next in the chain or from the CA store). Allow processing to\n       continue to the next step if no parent is found but the certificate is\n       in the CA store.\n    3. TODO: The certificate has not been revoked.\n    4. The certificate issuer name matches the parent's subject name.\n    5. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is within one of the permitted subtrees of X.500 distinguished names\n       and that each of the alternative names in the subjectAltName extension\n       (critical or non-critical) is within one of the permitted subtrees for\n       that name type.\n    6. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is not within one of the excluded subtrees for X.500 distinguished\n       names and none of the subjectAltName extension names are excluded for\n       that name type.\n    7. The other steps in the algorithm for basic path processing involve\n       handling the policy extension which is not presently supported in this\n       implementation. Instead, if a critical policy extension is found, the\n       certificate is rejected as not supported.\n    8. If the certificate is not the first or if its the only certificate in\n       the chain (having no parent from the CA store or is self-signed) and it\n       has a critical key usage extension, verify that the keyCertSign bit is\n       set. If the key usage extension exists, verify that the basic\n       constraints extension exists. If the basic constraints extension exists,\n       verify that the cA flag is set. If pathLenConstraint is set, ensure that\n       the number of certificates that precede in the chain (come earlier\n       in the chain as implemented below), excluding the very first in the\n       chain (typically the end-entity one), isn't greater than the\n       pathLenConstraint. This constraint limits the number of intermediate\n       CAs that may appear below a CA before only end-entity certificates\n       may be issued. */\n  // if a verify callback is passed as the third parameter, package it within\n  // the options object. This is to support a legacy function signature that\n  // expected the verify callback as the third parameter.\n  if (typeof options === 'function') {\n    options = {\n      verify: options\n    };\n  }\n\n  options = options || {}; // copy cert chain references to another array to protect against changes\n  // in verify callback\n\n  chain = chain.slice(0);\n  var certs = chain.slice(0);\n  var validityCheckDate = options.validityCheckDate; // if no validityCheckDate is specified, default to the current date. Make\n  // sure to maintain the value null because it indicates that the validity\n  // period should not be checked.\n\n  if (typeof validityCheckDate === 'undefined') {\n    validityCheckDate = new Date();\n  } // verify each cert in the chain using its parent, where the parent\n  // is either the next in the chain or from the CA store\n\n\n  var first = true;\n  var error = null;\n  var depth = 0;\n\n  do {\n    var cert = chain.shift();\n    var parent = null;\n    var selfSigned = false;\n\n    if (validityCheckDate) {\n      // 1. check valid time\n      if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {\n        error = {\n          message: 'Certificate is not valid yet or has expired.',\n          error: pki.certificateError.certificate_expired,\n          notBefore: cert.validity.notBefore,\n          notAfter: cert.validity.notAfter,\n          // TODO: we might want to reconsider renaming 'now' to\n          // 'validityCheckDate' should this API be changed in the future.\n          now: validityCheckDate\n        };\n      }\n    } // 2. verify with parent from chain or CA store\n\n\n    if (error === null) {\n      parent = chain[0] || caStore.getIssuer(cert);\n\n      if (parent === null) {\n        // check for self-signed cert\n        if (cert.isIssuer(cert)) {\n          selfSigned = true;\n          parent = cert;\n        }\n      }\n\n      if (parent) {\n        // FIXME: current CA store implementation might have multiple\n        // certificates where the issuer can't be determined from the\n        // certificate (happens rarely with, eg: old certificates) so normalize\n        // by always putting parents into an array\n        // TODO: there's may be an extreme degenerate case currently uncovered\n        // where an old intermediate certificate seems to have a matching parent\n        // but none of the parents actually verify ... but the intermediate\n        // is in the CA and it should pass this check; needs investigation\n        var parents = parent;\n\n        if (!forge.util.isArray(parents)) {\n          parents = [parents];\n        } // try to verify with each possible parent (typically only one)\n\n\n        var verified = false;\n\n        while (!verified && parents.length > 0) {\n          parent = parents.shift();\n\n          try {\n            verified = parent.verify(cert);\n          } catch (ex) {// failure to verify, don't care why, try next one\n          }\n        }\n\n        if (!verified) {\n          error = {\n            message: 'Certificate signature is invalid.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      }\n\n      if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {\n        // no parent issuer and certificate itself is not trusted\n        error = {\n          message: 'Certificate is not trusted.',\n          error: pki.certificateError.unknown_ca\n        };\n      }\n    } // TODO: 3. check revoked\n    // 4. check for matching issuer/subject\n\n\n    if (error === null && parent && !cert.isIssuer(parent)) {\n      // parent is not issuer\n      error = {\n        message: 'Certificate issuer is invalid.',\n        error: pki.certificateError.bad_certificate\n      };\n    } // 5. TODO: check names with permitted names tree\n    // 6. TODO: check names against excluded names tree\n    // 7. check for unsupported critical extensions\n\n\n    if (error === null) {\n      // supported extensions\n      var se = {\n        keyUsage: true,\n        basicConstraints: true\n      };\n\n      for (var i = 0; error === null && i < cert.extensions.length; ++i) {\n        var ext = cert.extensions[i];\n\n        if (ext.critical && !(ext.name in se)) {\n          error = {\n            message: 'Certificate has an unsupported critical extension.',\n            error: pki.certificateError.unsupported_certificate\n          };\n        }\n      }\n    } // 8. check for CA if cert is not first or is the only certificate\n    // remaining in chain with no parent or is self-signed\n\n\n    if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {\n      // first check keyUsage extension and then basic constraints\n      var bcExt = cert.getExtension('basicConstraints');\n      var keyUsageExt = cert.getExtension('keyUsage');\n\n      if (keyUsageExt !== null) {\n        // keyCertSign must be true and there must be a basic\n        // constraints extension\n        if (!keyUsageExt.keyCertSign || bcExt === null) {\n          // bad certificate\n          error = {\n            message: 'Certificate keyUsage or basicConstraints conflict ' + 'or indicate that the certificate is not a CA. ' + 'If the certificate is the only one in the chain or ' + 'isn\\'t the first then the certificate must be a ' + 'valid CA.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      } // basic constraints cA flag must be set\n\n\n      if (error === null && bcExt !== null && !bcExt.cA) {\n        // bad certificate\n        error = {\n          message: 'Certificate basicConstraints indicates the certificate ' + 'is not a CA.',\n          error: pki.certificateError.bad_certificate\n        };\n      } // if error is not null and keyUsage is available, then we know it\n      // has keyCertSign and there is a basic constraints extension too,\n      // which means we can check pathLenConstraint (if it exists)\n\n\n      if (error === null && keyUsageExt !== null && 'pathLenConstraint' in bcExt) {\n        // pathLen is the maximum # of intermediate CA certs that can be\n        // found between the current certificate and the end-entity (depth 0)\n        // certificate; this number does not include the end-entity (depth 0,\n        // last in the chain) even if it happens to be a CA certificate itself\n        var pathLen = depth - 1;\n\n        if (pathLen > bcExt.pathLenConstraint) {\n          // pathLenConstraint violated, bad certificate\n          error = {\n            message: 'Certificate basicConstraints pathLenConstraint violated.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      }\n    } // call application callback\n\n\n    var vfd = error === null ? true : error.error;\n    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;\n\n    if (ret === true) {\n      // clear any set error\n      error = null;\n    } else {\n      // if passed basic tests, set default message and alert\n      if (vfd === true) {\n        error = {\n          message: 'The application rejected the certificate.',\n          error: pki.certificateError.bad_certificate\n        };\n      } // check for custom error info\n\n\n      if (ret || ret === 0) {\n        // set custom message and error\n        if (typeof ret === 'object' && !forge.util.isArray(ret)) {\n          if (ret.message) {\n            error.message = ret.message;\n          }\n\n          if (ret.error) {\n            error.error = ret.error;\n          }\n        } else if (typeof ret === 'string') {\n          // set custom error\n          error.error = ret;\n        }\n      } // throw error\n\n\n      throw error;\n    } // no longer first cert in chain\n\n\n    first = false;\n    ++depth;\n  } while (chain.length > 0);\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}
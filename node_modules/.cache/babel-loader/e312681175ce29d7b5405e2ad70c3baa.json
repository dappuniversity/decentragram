{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar cbor = require('borc');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar multicodec = require('multicodec');\n\nvar multihashing = require('multihashing-async');\n\nvar CID = require('cids');\n\nvar isCircular = require('is-circular'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nvar CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nfunction replaceCIDbyTAG(dagNode) {\n  var circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    var keys = Object.keys(obj);\n\n    if (keys.length > 0) {\n      // Recursive transform\n      var out = {};\n      keys.forEach(function (key) {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nexports = module.exports;\nexports.codec = multicodec.DAG_CBOR;\nexports.defaultHashAlg = multicodec.SHA2_256;\n\nvar defaultTags = _defineProperty({}, CID_CBOR_TAG, function (val) {\n  // remove that 0\n  val = val.slice(1);\n  return new CID(val);\n});\n\nvar defaultSize = 64 * 1024; // current decoder heap size, 64 Kb\n\nvar currentSize = defaultSize;\nvar defaultMaxSize = 64 * 1024 * 1024; // max heap size when auto-growing, 64 Mb\n\nvar maxSize = defaultMaxSize;\nvar decoder = null;\n/**\n * Configure the underlying CBOR decoder.\n *\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\n */\n\nexports.configureDecoder = function (options) {\n  var tags = defaultTags;\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size;\n    }\n\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize;\n    }\n\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags);\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize;\n    maxSize = defaultMaxSize;\n  }\n\n  var decoderOptions = {\n    tags: tags,\n    size: currentSize\n  };\n  decoder = new cbor.Decoder(decoderOptions); // borc edits opts.size in-place so we can capture _actual_ size\n\n  currentSize = decoderOptions.size;\n};\n\nexports.configureDecoder(); // Setup default cbor.Decoder\n\n/**\n * Serialize internal representation into a binary CBOR block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\n\nexports.serialize = function (node) {\n  var nodeTagged = replaceCIDbyTAG(node);\n  var serialized = cbor.encode(nodeTagged);\n  return serialized;\n};\n/**\n * Deserialize CBOR block into the internal representation.\n *\n * @param {Buffer} data - Binary representation of a CBOR block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\n\n\nexports.deserialize = function (data) {\n  if (data.length > currentSize && data.length <= maxSize) {\n    exports.configureDecoder({\n      size: data.length\n    });\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder');\n  }\n\n  var deserialized = decoder.decodeFirst(data);\n  return deserialized;\n};\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\n\n\nexports.cid =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(binaryBlob, userOptions) {\n    var defaultOptions, options, multihash, codecName, cid;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            defaultOptions = {\n              cidVersion: 1,\n              hashAlg: exports.defaultHashAlg\n            };\n            options = Object.assign(defaultOptions, userOptions);\n            _context.next = 4;\n            return multihashing(binaryBlob, options.hashAlg);\n\n          case 4:\n            multihash = _context.sent;\n            codecName = multicodec.print[exports.codec];\n            cid = new CID(options.cidVersion, codecName, multihash);\n            return _context.abrupt(\"return\", cid);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}
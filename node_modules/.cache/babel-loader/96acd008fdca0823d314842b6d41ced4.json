{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar createHash = require('create-hash');\n\nvar HmacDRBG = require('drbg.js/hmac');\n\nvar messages = require('../messages.json');\n\nvar BN = require('./bn');\n\nvar ECPoint = require('./ecpoint');\n\nvar g = require('./ecpointg');\n\nexports.privateKeyVerify = function (privateKey) {\n  var bn = BN.fromBuffer(privateKey);\n  return !(bn.isOverflow() || bn.isZero());\n};\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  var d = BN.fromBuffer(privateKey);\n  if (d.isOverflow() || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);\n  return g.mul(d).toPublicKey(compressed);\n};\n\nexports.privateKeyNegate = function (privateKey) {\n  var bn = BN.fromBuffer(privateKey);\n  if (bn.isZero()) return Buffer.alloc(32);\n  if (bn.ucmp(BN.n) > 0) bn.isub(BN.n);\n  return BN.n.sub(bn).toBuffer();\n};\n\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = BN.fromBuffer(privateKey);\n  if (bn.isOverflow() || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);\n  return bn.uinvm().toBuffer();\n};\n\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  var bn = BN.fromBuffer(tweak);\n  if (bn.isOverflow()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);\n  bn.iadd(BN.fromBuffer(privateKey));\n  if (bn.isOverflow()) bn.isub(BN.n);\n  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);\n  return bn.toBuffer();\n};\n\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  var bn = BN.fromBuffer(tweak);\n  if (bn.isOverflow() || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);\n  var d = BN.fromBuffer(privateKey);\n  return bn.umul(d).ureduce().toBuffer();\n};\n\nexports.publicKeyCreate = function (privateKey, compressed) {\n  var d = BN.fromBuffer(privateKey);\n  if (d.isOverflow() || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);\n  return g.mul(d).toPublicKey(compressed);\n};\n\nexports.publicKeyConvert = function (publicKey, compressed) {\n  var point = ECPoint.fromPublicKey(publicKey);\n  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  return point.toPublicKey(compressed);\n};\n\nexports.publicKeyVerify = function (publicKey) {\n  return ECPoint.fromPublicKey(publicKey) !== null;\n};\n\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  var point = ECPoint.fromPublicKey(publicKey);\n  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  tweak = BN.fromBuffer(tweak);\n  if (tweak.isOverflow()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);\n  var result = g.mul(tweak).add(point);\n  if (result.inf) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);\n  return result.toPublicKey(compressed);\n};\n\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  var point = ECPoint.fromPublicKey(publicKey);\n  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  tweak = BN.fromBuffer(tweak);\n  if (tweak.isOverflow() || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);\n  return point.mul(tweak).toPublicKey(compressed);\n};\n\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var points = new Array(publicKeys.length);\n\n  for (var i = 0; i < publicKeys.length; ++i) {\n    points[i] = ECPoint.fromPublicKey(publicKeys[i]);\n    if (points[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  }\n\n  var point = points[0];\n\n  for (var j = 1; j < points.length; ++j) {\n    point = point.add(points[j]);\n  }\n\n  if (point.inf) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);\n  return point.toPublicKey(compressed);\n};\n\nexports.signatureNormalize = function (signature) {\n  var r = BN.fromBuffer(signature.slice(0, 32));\n  var s = BN.fromBuffer(signature.slice(32, 64));\n  if (r.isOverflow() || s.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);\n  var result = Buffer.from(signature);\n  if (s.isHigh()) BN.n.sub(s).toBuffer().copy(result, 32);\n  return result;\n};\n\nexports.signatureExport = function (signature) {\n  var r = signature.slice(0, 32);\n  var s = signature.slice(32, 64);\n  if (BN.fromBuffer(r).isOverflow() || BN.fromBuffer(s).isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);\n  return {\n    r: r,\n    s: s\n  };\n};\n\nexports.signatureImport = function (sigObj) {\n  var r = BN.fromBuffer(sigObj.r);\n  if (r.isOverflow()) r = BN.fromNumber(0);\n  var s = BN.fromBuffer(sigObj.s);\n  if (s.isOverflow()) s = BN.fromNumber(0);\n  return Buffer.concat([r.toBuffer(), s.toBuffer()]);\n};\n\nexports.sign = function (message, privateKey, noncefn, data) {\n  var d = BN.fromBuffer(privateKey);\n  if (d.isOverflow() || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL);\n\n  if (noncefn === null) {\n    var drbg = new HmacDRBG('sha256', privateKey, message, data);\n\n    noncefn = function noncefn() {\n      return drbg.generate(32);\n    };\n  }\n\n  var bnMessage = BN.fromBuffer(message);\n\n  for (var count = 0;; ++count) {\n    var nonce = noncefn(message, privateKey, null, data, count);\n    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL);\n    var k = BN.fromBuffer(nonce);\n    if (k.isOverflow() || k.isZero()) continue;\n    var kp = g.mul(k);\n    var r = kp.x.fireduce();\n    if (r.isZero()) continue;\n    var s = k.uinvm().umul(r.umul(d).ureduce().iadd(bnMessage).fireduce()).ureduce();\n    if (s.isZero()) continue;\n    var recovery = (kp.x.ucmp(r) !== 0 ? 2 : 0) | (kp.y.isOdd() ? 1 : 0);\n\n    if (s.isHigh()) {\n      s = BN.n.sub(s);\n      recovery ^= 1;\n    }\n\n    return {\n      signature: Buffer.concat([r.toBuffer(), s.toBuffer()]),\n      recovery: recovery\n    };\n  }\n};\n\nexports.verify = function (message, signature, publicKey) {\n  var sigr = BN.fromBuffer(signature.slice(0, 32));\n  var sigs = BN.fromBuffer(signature.slice(32, 64));\n  if (sigr.isOverflow() || sigs.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);\n  if (sigs.isHigh() || sigr.isZero() || sigs.isZero()) return false;\n  var pub = ECPoint.fromPublicKey(publicKey);\n  if (pub === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  var sinv = sigs.uinvm();\n  var u1 = sinv.umul(BN.fromBuffer(message)).ureduce();\n  var u2 = sinv.umul(sigr).ureduce();\n  var point = g.mulAdd(u1, pub, u2);\n  if (point.inf) return false; // return ECPoint.fromECJPoint(point).x.fireduce().ucmp(sigr) === 0\n  // Inversion-free\n\n  var z2 = point.z.redSqr();\n  if (sigr.redMul(z2).ucmp(point.x) === 0) return true;\n  if (sigr.ucmp(BN.psn) >= 0) return false;\n  return sigr.iadd(BN.psn).redMul(z2).ucmp(point.x) === 0;\n};\n\nexports.recover = function (message, signature, recovery, compressed) {\n  var sigr = BN.fromBuffer(signature.slice(0, 32));\n  var sigs = BN.fromBuffer(signature.slice(32, 64));\n  if (sigr.isOverflow() || sigs.isOverflow()) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);\n\n  do {\n    if (sigr.isZero() || sigs.isZero()) break;\n    var kpx = sigr;\n\n    if (recovery >> 1) {\n      if (kpx.ucmp(BN.psn) >= 0) break;\n      kpx = sigr.add(BN.n);\n    }\n\n    var kpPublicKey = Buffer.concat([Buffer.from([0x02 + (recovery & 0x01)]), kpx.toBuffer()]);\n    var kp = ECPoint.fromPublicKey(kpPublicKey);\n    if (kp === null) break;\n    var rInv = sigr.uinvm();\n    var s1 = BN.n.sub(BN.fromBuffer(message)).umul(rInv).ureduce();\n    var s2 = sigs.umul(rInv).ureduce();\n    var point = ECPoint.fromECJPoint(g.mulAdd(s1, kp, s2));\n    return point.toPublicKey(compressed);\n  } while (false);\n\n  throw new Error(messages.ECDSA_RECOVER_FAIL);\n};\n\nexports.ecdh = function (publicKey, privateKey) {\n  var shared = exports.ecdhUnsafe(publicKey, privateKey, true);\n  return createHash('sha256').update(shared).digest();\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  var point = ECPoint.fromPublicKey(publicKey);\n  if (point === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);\n  var scalar = BN.fromBuffer(privateKey);\n  if (scalar.isOverflow() || scalar.isZero()) throw new Error(messages.ECDH_FAIL);\n  return point.mul(scalar).toPublicKey(compressed);\n};","map":null,"metadata":{},"sourceType":"script"}
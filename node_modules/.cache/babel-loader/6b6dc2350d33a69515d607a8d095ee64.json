{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // We use this for base 36 maths\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar bytes_1 = require(\"./bytes\");\n\nvar keccak256_1 = require(\"./keccak256\");\n\nvar rlp_1 = require(\"./rlp\");\n\nvar errors = require(\"../errors\"); ///////////////////////////////\n\n\nfunction getChecksumAddress(address) {\n  if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address\n    });\n  }\n\n  address = address.toLowerCase();\n  var chars = address.substring(2).split('');\n  var hashed = new Uint8Array(40);\n\n  for (var i_1 = 0; i_1 < 40; i_1++) {\n    hashed[i_1] = chars[i_1].charCodeAt(0);\n  }\n\n  hashed = bytes_1.arrayify(keccak256_1.keccak256(hashed));\n\n  for (var i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return '0x' + chars.join('');\n} // Shims for environments that are missing some required constants and functions\n\n\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nfunction log10(x) {\n  if (Math.log10) {\n    return Math.log10(x);\n  }\n\n  return Math.log(x) / Math.LN10;\n} // See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\n\n\nvar ibanLookup = {};\n\nfor (var i = 0; i < 10; i++) {\n  ibanLookup[String(i)] = String(i);\n}\n\nfor (var i = 0; i < 26; i++) {\n  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n} // How many decimal digits can we process? (for 64-bit float, this is 15)\n\n\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address) {\n  address = address.toUpperCase();\n  address = address.substring(4) + address.substring(0, 2) + '00';\n  var expanded = '';\n  address.split('').forEach(function (c) {\n    expanded += ibanLookup[c];\n  }); // Javascript can handle integers safely up to 15 (decimal) digits\n\n  while (expanded.length >= safeDigits) {\n    var block = expanded.substring(0, safeDigits);\n    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n  }\n\n  var checksum = String(98 - parseInt(expanded, 10) % 97);\n\n  while (checksum.length < 2) {\n    checksum = '0' + checksum;\n  }\n\n  return checksum;\n}\n\n;\n\nfunction getAddress(address) {\n  var result = null;\n\n  if (typeof address !== 'string') {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address\n    });\n  }\n\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    // Missing the 0x prefix\n    if (address.substring(0, 2) !== '0x') {\n      address = '0x' + address;\n    }\n\n    result = getChecksumAddress(address); // It is a checksummed address with a bad checksum\n\n    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n      errors.throwError('bad address checksum', errors.INVALID_ARGUMENT, {\n        arg: 'address',\n        value: address\n      });\n    } // Maybe ICAP? (we only support direct mode)\n\n  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    // It is an ICAP address with a bad checksum\n    if (address.substring(2, 4) !== ibanChecksum(address)) {\n      errors.throwError('bad icap checksum', errors.INVALID_ARGUMENT, {\n        arg: 'address',\n        value: address\n      });\n    }\n\n    result = new bn_js_1.default.BN(address.substring(4), 36).toString(16);\n\n    while (result.length < 40) {\n      result = '0' + result;\n    }\n\n    result = getChecksumAddress('0x' + result);\n  } else {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address\n    });\n  }\n\n  return result;\n}\n\nexports.getAddress = getAddress;\n\nfunction getIcapAddress(address) {\n  var base36 = new bn_js_1.default.BN(getAddress(address).substring(2), 16).toString(36).toUpperCase();\n\n  while (base36.length < 30) {\n    base36 = '0' + base36;\n  }\n\n  return 'XE' + ibanChecksum('XE00' + base36) + base36;\n}\n\nexports.getIcapAddress = getIcapAddress; // http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\nfunction getContractAddress(transaction) {\n  if (!transaction.from) {\n    throw new Error('missing from address');\n  }\n\n  var nonce = transaction.nonce;\n  return getAddress('0x' + keccak256_1.keccak256(rlp_1.encode([getAddress(transaction.from), bytes_1.stripZeros(bytes_1.hexlify(nonce))])).substring(26));\n}\n\nexports.getContractAddress = getContractAddress;","map":null,"metadata":{},"sourceType":"script"}
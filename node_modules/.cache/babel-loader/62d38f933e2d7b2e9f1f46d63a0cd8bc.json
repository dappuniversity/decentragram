{"ast":null,"code":"\"use strict\"; //See: https://github.com/ethereum/wiki/wiki/RLP\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bytes_1 = require(\"./bytes\");\n\nfunction arrayifyInteger(value) {\n  var result = [];\n\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n\n  return result;\n}\n\nfunction unarrayifyInteger(data, offset, length) {\n  var result = 0;\n\n  for (var i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n\n  return result;\n}\n\nfunction _encode(object) {\n  if (Array.isArray(object)) {\n    var payload = [];\n    object.forEach(function (child) {\n      payload = payload.concat(_encode(child));\n    });\n\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n\n    var length = arrayifyInteger(payload.length);\n    length.unshift(0xf7 + length.length);\n    return length.concat(payload);\n  }\n\n  var data = Array.prototype.slice.call(bytes_1.arrayify(object));\n\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n\n  var length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n  return length.concat(data);\n}\n\nfunction encode(object) {\n  return bytes_1.hexlify(_encode(object));\n}\n\nexports.encode = encode;\n\nfunction _decodeChildren(data, offset, childOffset, length) {\n  var result = [];\n\n  while (childOffset < offset + 1 + length) {\n    var decoded = _decode(data, childOffset);\n\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n\n    if (childOffset > offset + 1 + length) {\n      throw new Error('invalid rlp');\n    }\n  }\n\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n} // returns { consumed: number, result: Object }\n\n\nfunction _decode(data, offset) {\n  if (data.length === 0) {\n    throw new Error('invalid rlp data');\n  } // Array with extra length prefix\n\n\n  if (data[offset] >= 0xf8) {\n    var lengthLength = data[offset] - 0xf7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      throw new Error('too short');\n    }\n\n    var length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      throw new Error('to short');\n    }\n\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    var length = data[offset] - 0xc0;\n\n    if (offset + 1 + length > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    var lengthLength = data[offset] - 0xb7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    var length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      throw new Error('invalid rlp data');\n    }\n\n    var result = bytes_1.hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    var length = data[offset] - 0x80;\n\n    if (offset + 1 + length > data.length) {\n      throw new Error('invlaid rlp data');\n    }\n\n    var result = bytes_1.hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n\n  return {\n    consumed: 1,\n    result: bytes_1.hexlify(data[offset])\n  };\n}\n\nfunction decode(data) {\n  var bytes = bytes_1.arrayify(data);\n\n  var decoded = _decode(bytes, 0);\n\n  if (decoded.consumed !== bytes.length) {\n    throw new Error('invalid rlp data');\n  }\n\n  return decoded.result;\n}\n\nexports.decode = decode;","map":null,"metadata":{},"sourceType":"script"}
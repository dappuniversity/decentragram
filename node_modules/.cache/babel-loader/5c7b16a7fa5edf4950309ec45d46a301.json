{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('websocket'), require('xhr2-cookies'), require('url-parse'), require('@babel/runtime/helpers/typeof'), require('lodash/isFunction'), require('lodash/isObject'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/get'), require('@babel/runtime/helpers/inherits'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('eventemitter3'), require('lodash/isArray'), require('http'), require('https')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', 'websocket', 'xhr2-cookies', 'url-parse', '@babel/runtime/helpers/typeof', 'lodash/isFunction', 'lodash/isObject', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/get', '@babel/runtime/helpers/inherits', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', 'eventemitter3', 'lodash/isArray', 'http', 'https'], factory) : (global = global || self, factory(global.Web3Providers = {}, global._classCallCheck, global._createClass, global.websocket, global.xhr2Cookies, global.URL, global._typeof, global.isFunction, global.isObject, global._possibleConstructorReturn, global._getPrototypeOf, global._get, global._inherits, global._regeneratorRuntime, global._asyncToGenerator, global.EventEmitter, global.isArray, global.http, global.https));\n})(this, function (exports, _classCallCheck, _createClass, websocket, xhr2Cookies, URL, _typeof, isFunction, isObject, _possibleConstructorReturn, _getPrototypeOf, _get, _inherits, _regeneratorRuntime, _asyncToGenerator, EventEmitter, isArray, http, https) {\n  'use strict';\n\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  URL = URL && URL.hasOwnProperty('default') ? URL['default'] : URL;\n  _typeof = _typeof && _typeof.hasOwnProperty('default') ? _typeof['default'] : _typeof;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  EventEmitter = EventEmitter && EventEmitter.hasOwnProperty('default') ? EventEmitter['default'] : EventEmitter;\n  isArray = isArray && isArray.hasOwnProperty('default') ? isArray['default'] : isArray;\n  http = http && http.hasOwnProperty('default') ? http['default'] : http;\n  https = https && https.hasOwnProperty('default') ? https['default'] : https;\n\n  var global = function () {\n    return this || (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self;\n  }() || new Function('return this')();\n\n  var ProviderResolver = function () {\n    function ProviderResolver(providersModuleFactory) {\n      _classCallCheck(this, ProviderResolver);\n\n      this.providersModuleFactory = providersModuleFactory;\n    }\n\n    _createClass(ProviderResolver, [{\n      key: \"resolve\",\n      value: function resolve(provider, net) {\n        if (!provider) {\n          return provider;\n        }\n\n        if (typeof provider === 'string') {\n          if (/^http(s)?:\\/\\//i.test(provider)) {\n            return this.providersModuleFactory.createHttpProvider(provider);\n          }\n\n          if (/^ws(s)?:\\/\\//i.test(provider)) {\n            return this.providersModuleFactory.createWebsocketProvider(provider);\n          }\n\n          if (provider && isObject(net) && isFunction(net.connect)) {\n            return this.providersModuleFactory.createIpcProvider(provider, net);\n          }\n        }\n\n        if (provider.sendPayload && provider.subscribe) {\n          return provider;\n        }\n\n        if (typeof global.mist !== 'undefined' && provider.constructor.name === 'EthereumProvider') {\n          return this.providersModuleFactory.createMistEthereumProvider(provider);\n        }\n\n        if (provider.isEIP1193) {\n          return this.providersModuleFactory.createWeb3EthereumProvider(provider);\n        }\n\n        if (this.isMetamaskInpageProvider(provider)) {\n          return this.providersModuleFactory.createMetamaskProvider(provider);\n        }\n\n        return this.providersModuleFactory.createCustomProvider(provider);\n      }\n    }, {\n      key: \"isMetamaskInpageProvider\",\n      value: function isMetamaskInpageProvider(provider) {\n        return provider.constructor.name === 'MetamaskInpageProvider';\n      }\n    }]);\n\n    return ProviderResolver;\n  }();\n\n  var messageId = 0;\n\n  var JsonRpcMapper = function () {\n    function JsonRpcMapper() {\n      _classCallCheck(this, JsonRpcMapper);\n    }\n\n    _createClass(JsonRpcMapper, null, [{\n      key: \"toPayload\",\n      value: function toPayload(method, params) {\n        if (!method) {\n          throw new Error(\"JSONRPC method should be specified for params: \\\"\".concat(JSON.stringify(params), \"\\\"!\"));\n        }\n\n        var id = messageId;\n        messageId++;\n        return {\n          jsonrpc: '2.0',\n          id: id,\n          method: method,\n          params: params || []\n        };\n      }\n    }]);\n\n    return JsonRpcMapper;\n  }();\n\n  var JsonRpcResponseValidator = function () {\n    function JsonRpcResponseValidator() {\n      _classCallCheck(this, JsonRpcResponseValidator);\n    }\n\n    _createClass(JsonRpcResponseValidator, null, [{\n      key: \"validate\",\n      value: function validate(response) {\n        var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (isObject(response)) {\n          if (response.error) {\n            if (response.error instanceof Error) {\n              return new Error(\"Node error: \".concat(response.error.message));\n            }\n\n            return new Error(\"Node error: \".concat(JSON.stringify(response.error)));\n          }\n\n          if (payload && response.id !== payload.id) {\n            return new Error(\"Validation error: Invalid JSON-RPC response ID (request: \".concat(payload.id, \" / response: \").concat(response.id, \")\"));\n          }\n\n          if (response.result === undefined) {\n            return new Error('Validation error: Undefined JSON-RPC result');\n          }\n\n          return true;\n        }\n\n        return new Error('Validation error: Response should be of type Object');\n      }\n    }]);\n\n    return JsonRpcResponseValidator;\n  }();\n\n  var AbstractSocketProvider = function (_EventEmitter) {\n    _inherits(AbstractSocketProvider, _EventEmitter);\n\n    function AbstractSocketProvider(connection, timeout) {\n      var _this;\n\n      _classCallCheck(this, AbstractSocketProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractSocketProvider).call(this));\n      _this.connection = connection;\n      _this.timeout = timeout;\n      _this.subscriptions = {};\n\n      _this.registerEventListeners();\n\n      _this.READY = 'ready';\n      _this.CONNECT = 'connect';\n      _this.ERROR = 'error';\n      _this.CLOSE = 'close';\n      _this.SOCKET_MESSAGE = 'socket_message';\n      _this.SOCKET_READY = 'socket_ready';\n      _this.SOCKET_CLOSE = 'socket_close';\n      _this.SOCKET_ERROR = 'socket_error';\n      _this.SOCKET_CONNECT = 'socket_connect';\n      _this.SOCKET_NETWORK_CHANGED = 'socket_networkChanged';\n      _this.SOCKET_ACCOUNTS_CHANGED = 'socket_accountsChanged';\n      return _this;\n    }\n\n    _createClass(AbstractSocketProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return true;\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {}\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.removeAllListeners(this.SOCKET_MESSAGE);\n        this.removeAllListeners(this.SOCKET_READY);\n        this.removeAllListeners(this.SOCKET_CLOSE);\n        this.removeAllListeners(this.SOCKET_ERROR);\n        this.removeAllListeners(this.SOCKET_CONNECT);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect(code, reason) {}\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"onReady\",\n      value: function onReady(event) {\n        this.emit(this.READY, event);\n        this.emit(this.SOCKET_READY, event);\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(error) {\n        this.emit(this.ERROR, error);\n        this.emit(this.SOCKET_ERROR, error);\n        this.removeAllSocketListeners();\n        this.removeAllListeners();\n      }\n    }, {\n      key: \"onClose\",\n      value: function onClose() {\n        var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.emit(this.CLOSE, error);\n        this.emit(this.SOCKET_CLOSE, error);\n        this.removeAllSocketListeners();\n        this.removeAllListeners();\n      }\n    }, {\n      key: \"onConnect\",\n      value: function () {\n        var _onConnect = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n          var subscriptionKeys, subscriptionId, _i, _subscriptionKeys, key;\n\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  subscriptionKeys = Object.keys(this.subscriptions);\n\n                  if (!(subscriptionKeys.length > 0)) {\n                    _context2.next = 13;\n                    break;\n                  }\n\n                  _i = 0, _subscriptionKeys = subscriptionKeys;\n\n                case 3:\n                  if (!(_i < _subscriptionKeys.length)) {\n                    _context2.next = 13;\n                    break;\n                  }\n\n                  key = _subscriptionKeys[_i];\n                  _context2.next = 7;\n                  return this.subscribe(this.subscriptions[key].subscribeMethod, this.subscriptions[key].parameters[0], this.subscriptions[key].parameters.slice(1));\n\n                case 7:\n                  subscriptionId = _context2.sent;\n                  delete this.subscriptions[subscriptionId];\n                  this.subscriptions[key].id = subscriptionId;\n\n                case 10:\n                  _i++;\n                  _context2.next = 3;\n                  break;\n\n                case 13:\n                  this.emit(this.SOCKET_CONNECT);\n                  this.emit(this.CONNECT);\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function onConnect() {\n          return _onConnect.apply(this, arguments);\n        }\n\n        return onConnect;\n      }()\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(response) {\n        var event;\n\n        if (!isObject(response)) {\n          response = JSON.parse(response);\n        }\n\n        if (isArray(response)) {\n          event = response[0].id;\n        } else if (typeof response.id === 'undefined') {\n          event = this.getSubscriptionEvent(response.params.subscription);\n          response = response.params;\n        } else {\n          event = response.id;\n        }\n\n        this.emit(this.SOCKET_MESSAGE, response);\n        this.emit(event, response);\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.removeAllListeners();\n        this.registerEventListeners();\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {\n        var _this2 = this;\n\n        var subscribeMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'eth_subscribe';\n        var subscriptionMethod = arguments.length > 1 ? arguments[1] : undefined;\n        var parameters = arguments.length > 2 ? arguments[2] : undefined;\n        parameters.unshift(subscriptionMethod);\n        return this.send(subscribeMethod, parameters).then(function (subscriptionId) {\n          _this2.subscriptions[subscriptionId] = {\n            id: subscriptionId,\n            subscribeMethod: subscribeMethod,\n            parameters: parameters\n          };\n          return subscriptionId;\n        }).catch(function (error) {\n          throw new Error(\"Provider error: \".concat(error));\n        });\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe(subscriptionId) {\n        var _this3 = this;\n\n        var unsubscribeMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'eth_unsubscribe';\n\n        if (this.hasSubscription(subscriptionId)) {\n          return this.send(unsubscribeMethod, [subscriptionId]).then(function (response) {\n            if (response) {\n              _this3.removeAllListeners(_this3.getSubscriptionEvent(subscriptionId));\n\n              delete _this3.subscriptions[subscriptionId];\n            }\n\n            return response;\n          });\n        }\n\n        return Promise.reject(new Error(\"Provider error: Subscription with ID \".concat(subscriptionId, \" does not exist.\")));\n      }\n    }, {\n      key: \"clearSubscriptions\",\n      value: function clearSubscriptions() {\n        var _this4 = this;\n\n        var unsubscribeMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'eth_unsubscribe';\n        var unsubscribePromises = [];\n        Object.keys(this.subscriptions).forEach(function (key) {\n          _this4.removeAllListeners(key);\n\n          unsubscribePromises.push(_this4.unsubscribe(_this4.subscriptions[key].id, unsubscribeMethod));\n        });\n        return Promise.all(unsubscribePromises).then(function (results) {\n          if (results.includes(false)) {\n            throw new Error(\"Could not unsubscribe all subscriptions: \".concat(JSON.stringify(results)));\n          }\n\n          return true;\n        });\n      }\n    }, {\n      key: \"hasSubscription\",\n      value: function hasSubscription(subscriptionId) {\n        return typeof this.getSubscriptionEvent(subscriptionId) !== 'undefined';\n      }\n    }, {\n      key: \"getSubscriptionEvent\",\n      value: function getSubscriptionEvent(subscriptionId) {\n        var _this5 = this;\n\n        if (this.subscriptions[subscriptionId]) {\n          return subscriptionId;\n        }\n\n        var event;\n        Object.keys(this.subscriptions).forEach(function (key) {\n          if (_this5.subscriptions[key].id === subscriptionId) {\n            event = key;\n          }\n        });\n        return event;\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {}\n    }]);\n\n    return AbstractSocketProvider;\n  }(EventEmitter);\n\n  var WebsocketProvider = function (_AbstractSocketProvid) {\n    _inherits(WebsocketProvider, _AbstractSocketProvid);\n\n    function WebsocketProvider(connection, timeout) {\n      var _this;\n\n      _classCallCheck(this, WebsocketProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebsocketProvider).call(this, connection, timeout));\n      _this.host = _this.connection.url;\n      return _this;\n    }\n\n    _createClass(WebsocketProvider, [{\n      key: \"onMessage\",\n      value: function onMessage(messageEvent) {\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onMessage\", this).call(this, messageEvent.data);\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(event) {\n        if (event.code === 'ECONNREFUSED') {\n          this.reconnect();\n          return;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onError\", this).call(this, event);\n      }\n    }, {\n      key: \"onClose\",\n      value: function onClose(closeEvent) {\n        if (closeEvent.code !== 1000 || closeEvent.wasClean === false) {\n          this.reconnect();\n          return;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onClose\", this).call(this);\n      }\n    }, {\n      key: \"reconnect\",\n      value: function reconnect() {\n        var _this2 = this;\n\n        setTimeout(function () {\n          _this2.removeAllSocketListeners();\n\n          var connection = [];\n\n          if (_this2.connection.constructor.name === 'W3CWebsocket') {\n            connection = new _this2.connection.constructor(_this2.host, _this2.connection._client.protocol, null, _this2.connection._client.headers, _this2.connection._client.requestOptions, _this2.connection._client.config);\n          } else {\n            connection = new _this2.connection.constructor(_this2.host, _this2.connection.protocol || undefined);\n          }\n\n          _this2.connection = connection;\n\n          _this2.registerEventListeners();\n        }, 5000);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        this.connection.close(code, reason);\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.addEventListener('message', this.onMessage.bind(this));\n        this.connection.addEventListener('open', this.onReady.bind(this));\n        this.connection.addEventListener('open', this.onConnect.bind(this));\n        this.connection.addEventListener('close', this.onClose.bind(this));\n        this.connection.addEventListener('error', this.onError.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeEventListener('message', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeEventListener('open', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeEventListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeEventListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeEventListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"isConnecting\",\n      value: function isConnecting() {\n        return this.connection.readyState === this.connection.CONNECTING;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this3 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this3.once('error', reject);\n\n          if (!_this3.isConnecting()) {\n            var timeout, id;\n\n            if (_this3.connection.readyState !== _this3.connection.OPEN) {\n              return reject(new Error('Connection error: Connection is not open on send()'));\n            }\n\n            try {\n              _this3.connection.send(JSON.stringify(payload));\n            } catch (error) {\n              reject(error);\n            }\n\n            if (_this3.timeout) {\n              timeout = setTimeout(function () {\n                reject(new Error('Connection error: Timeout exceeded'));\n              }, _this3.timeout);\n            }\n\n            if (isArray(payload)) {\n              id = payload[0].id;\n            } else {\n              id = payload.id;\n            }\n\n            _this3.once(id, function (response) {\n              if (timeout) {\n                clearTimeout(timeout);\n              }\n\n              return resolve(response);\n            });\n\n            return;\n          }\n\n          _this3.once('connect', function () {\n            _this3.sendPayload(payload).then(resolve).catch(reject);\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.readyState === this.connection.OPEN;\n      }\n    }]);\n\n    return WebsocketProvider;\n  }(AbstractSocketProvider);\n\n  var IpcProvider = function (_AbstractSocketProvid) {\n    _inherits(IpcProvider, _AbstractSocketProvid);\n\n    function IpcProvider(connection, path) {\n      var _this;\n\n      _classCallCheck(this, IpcProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(IpcProvider).call(this, connection, null));\n      _this.host = path;\n      _this.lastChunk = '';\n      return _this;\n    }\n\n    _createClass(IpcProvider, [{\n      key: \"disconnect\",\n      value: function disconnect() {\n        this.connection.destroy();\n      }\n    }, {\n      key: \"reconnect\",\n      value: function reconnect() {\n        this.connection.connect({\n          path: this.path\n        });\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(message) {\n        var _this2 = this;\n\n        var result = null;\n        var returnValues = [];\n        var dechunkedData = message.toString().replace(/\\}[\\n\\r]?\\{/g, '}|--|{').replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{').replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{').replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{').split('|--|');\n        dechunkedData.forEach(function (data) {\n          result = null;\n\n          if (_this2.lastChunk) {\n            data = _this2.lastChunk + data;\n          }\n\n          try {\n            result = JSON.parse(data);\n          } catch (error) {\n            _this2.lastChunk = data;\n            return;\n          }\n\n          _this2.lastChunk = null;\n          returnValues.push(result);\n        });\n        returnValues.forEach(function (chunk) {\n          _get(_getPrototypeOf(IpcProvider.prototype), \"onMessage\", _this2).call(_this2, chunk);\n        });\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n        this.connection.on('close', this.onClose.bind(this));\n        this.connection.on('timeout', this.onClose.bind(this));\n        this.connection.on('ready', this.onReady.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('ready', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(IpcProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this3 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this3.once('error', reject);\n\n          if (!_this3.connection.writable) {\n            _this3.connection.connect({\n              path: _this3.path\n            });\n          }\n\n          if (_this3.connection.write(JSON.stringify(payload))) {\n            var id;\n\n            if (isArray(payload)) {\n              id = payload[0].id;\n            } else {\n              id = payload.id;\n            }\n\n            _this3.once(id, resolve);\n\n            return;\n          }\n\n          return reject(new Error(\"Connection error: Couldn't write on the socket with Socket.write(payload)\"));\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return !this.connection.pending;\n      }\n    }]);\n\n    return IpcProvider;\n  }(AbstractSocketProvider);\n\n  var HttpProvider = function () {\n    function HttpProvider() {\n      var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http://localhost:8545';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var providersModuleFactory = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, HttpProvider);\n\n      this.host = host;\n      this.timeout = options.timeout || 0;\n      this.headers = options.headers;\n      this.withCredentials = options.withCredentials || false;\n      this.connected = true;\n      this.providersModuleFactory = providersModuleFactory;\n      this.agent = {};\n      var keepAlive = false;\n\n      if (options.keepAlive === true || options.keepAlive !== false) {\n        keepAlive = true;\n      }\n\n      if (host.substring(0, 5) === 'https') {\n        this.agent['httpsAgent'] = new https.Agent({\n          keepAlive: keepAlive\n        });\n      } else {\n        this.agent['httpAgent'] = new http.Agent({\n          keepAlive: keepAlive\n        });\n      }\n    }\n\n    _createClass(HttpProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return false;\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {\n        throw new Error('Subscriptions are not supported with the HttpProvider.');\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        throw new Error('Subscriptions are not supported with the HttpProvider.');\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this = this;\n\n        return new Promise(function (resolve, reject) {\n          var request = _this.providersModuleFactory.createXMLHttpRequest(_this.host, _this.timeout, _this.headers, _this.agent, _this.withCredentials);\n\n          request.onreadystatechange = function () {\n            if (request.readyState !== 0 && request.readyState !== 1) {\n              _this.connected = true;\n            }\n\n            if (request.readyState === 4) {\n              if (request.status === 200) {\n                try {\n                  return resolve(JSON.parse(request.responseText));\n                } catch (error) {\n                  reject(new Error(\"Invalid JSON as response: \".concat(request.responseText)));\n                }\n              }\n\n              if (_this.isInvalidHttpEndpoint(request)) {\n                reject(new Error(\"Connection refused or URL couldn't be resolved: \".concat(_this.host)));\n              }\n\n              if (request.status >= 400 && request.status <= 499) {\n                reject(new Error(\"HttpProvider ERROR: \".concat(request.responseText, \" (code: \").concat(request.status, \")\")));\n              }\n            }\n          };\n\n          request.ontimeout = function () {\n            _this.connected = false;\n            reject(new Error(\"Connection error: Timeout exceeded after \".concat(_this.timeout, \"ms\")));\n          };\n\n          try {\n            request.send(JSON.stringify(payload));\n          } catch (error) {\n            _this.connected = false;\n            reject(error);\n          }\n        });\n      }\n    }, {\n      key: \"isInvalidHttpEndpoint\",\n      value: function isInvalidHttpEndpoint(request) {\n        return request.response === null && request.status === 0;\n      }\n    }]);\n\n    return HttpProvider;\n  }();\n\n  var BatchRequest = function () {\n    function BatchRequest(moduleInstance) {\n      _classCallCheck(this, BatchRequest);\n\n      this.moduleInstance = moduleInstance;\n      this.methods = [];\n    }\n\n    _createClass(BatchRequest, [{\n      key: \"add\",\n      value: function add(method) {\n        if (!isObject(method) && method) {\n          throw new Error('Please provide a object of type AbstractMethod.');\n        }\n\n        this.methods.push(method);\n      }\n    }, {\n      key: \"execute\",\n      value: function execute() {\n        var _this = this;\n\n        return this.moduleInstance.currentProvider.sendBatch(this.methods, this.moduleInstance).then(function (response) {\n          var errors = [];\n\n          _this.methods.forEach(function (method, index) {\n            if (!isArray(response)) {\n              method.callback(new Error(\"BatchRequest error: Response should be of type Array but is: \".concat(_typeof(response))), null);\n              errors.push(\"Response should be of type Array but is: \".concat(_typeof(response)));\n              return;\n            }\n\n            var responseItem = response[index] || null;\n            var validationResult = JsonRpcResponseValidator.validate(responseItem);\n\n            if (validationResult) {\n              try {\n                var mappedResult = method.afterExecution(responseItem.result);\n                response[index] = mappedResult;\n                method.callback(false, mappedResult);\n              } catch (error) {\n                errors.push(error);\n                method.callback(error, null);\n              }\n\n              return;\n            }\n\n            errors.push(validationResult);\n            method.callback(validationResult, null);\n          });\n\n          if (errors.length > 0) {\n            throw new Error(\"BatchRequest error: \".concat(JSON.stringify(errors)));\n          }\n\n          return {\n            methods: _this.methods,\n            response: response\n          };\n        });\n      }\n    }]);\n\n    return BatchRequest;\n  }();\n\n  var Web3EthereumProvider = function (_AbstractSocketProvid) {\n    _inherits(Web3EthereumProvider, _AbstractSocketProvid);\n\n    function Web3EthereumProvider(connection) {\n      var _this;\n\n      _classCallCheck(this, Web3EthereumProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Web3EthereumProvider).call(this, connection, null));\n      _this.host = 'Web3EthereumProvider';\n      return _this;\n    }\n\n    _createClass(Web3EthereumProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('notification', this.onMessage.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('connect', this.onReady.bind(this));\n        this.connection.on('close', this.onClose.bind(this));\n        this.connection.on('networkChanged', this.onNetworkChanged.bind(this));\n        this.connection.on('accountsChanged', this.onAccountsChanged.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_NETWORK_CHANGED:\n            this.connection.removeListener('networkChanged', this.onNetworkChanged);\n            break;\n\n          case this.SOCKET_ACCOUNTS_CHANGED:\n            this.connection.removeListener('accountsChanged', this.onAccountsChanged);\n            break;\n\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('notification', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('connect', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('close', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(Web3EthereumProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.connection.removeAllListeners();\n      }\n    }, {\n      key: \"onNetworkChanged\",\n      value: function onNetworkChanged(networkId) {\n        this.emit('networkChanged', networkId);\n      }\n    }, {\n      key: \"onAccountsChanged\",\n      value: function onAccountsChanged(accounts) {\n        this.emit('accountsChanged', accounts);\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(response) {\n        this.emit(this.getSubscriptionEvent(response.subscription), response);\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  response = this.connection.send(method, parameters);\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 4;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 4:\n                  return _context.abrupt(\"return\", response);\n\n                case 5:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var _this2 = this;\n\n        var methodCalls = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          methodCalls.push(_this2.connection.send(method.rpcMethod, method.parameters));\n        });\n        return Promise.all(methodCalls);\n      }\n    }]);\n\n    return Web3EthereumProvider;\n  }(AbstractSocketProvider);\n\n  var MetamaskProvider = function (_AbstractSocketProvid) {\n    _inherits(MetamaskProvider, _AbstractSocketProvid);\n\n    function MetamaskProvider(inpageProvider) {\n      var _this;\n\n      _classCallCheck(this, MetamaskProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MetamaskProvider).call(this, inpageProvider, null));\n      _this.host = 'metamask';\n      return _this;\n    }\n\n    _createClass(MetamaskProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('accountsChanged', this.onAccountsChanged.bind(this));\n        this.connection.on('networkChanged', this.onReady.bind(this));\n        this.connection.on('networkChanged', this.onNetworkChanged.bind(this));\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(metamaskParam, payload) {\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"onMessage\", this).call(this, payload);\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_NETWORK_CHANGED:\n            this.connection.removeListener('networkChanged', this.onNetworkChanged);\n            break;\n\n          case this.SOCKET_ACCOUNTS_CHANGED:\n            this.connection.removeListener('accountsChanged', this.onAccountsChanged);\n            break;\n\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n        }\n\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.connection.removeListener(this.SOCKET_NETWORK_CHANGED, this.onNetworkChanged);\n        this.connection.removeListener(this.SOCKET_ACCOUNTS_CHANGED, this.onAccountsChanged);\n\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"removeAllSocketListeners\", this).call(this);\n      }\n    }, {\n      key: \"onNetworkChanged\",\n      value: function onNetworkChanged(networkId) {\n        this.emit('networkChanged', networkId);\n      }\n    }, {\n      key: \"onAccountsChanged\",\n      value: function onAccountsChanged(accounts) {\n        this.emit('accountsChanged', accounts);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this2 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this2.connection.send(payload, function (error, response) {\n            _this2.removeAllListeners(payload.id);\n\n            if (!error) {\n              return resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.isConnected();\n      }\n    }]);\n\n    return MetamaskProvider;\n  }(AbstractSocketProvider);\n\n  var MistEthereumProvider = function (_AbstractSocketProvid) {\n    _inherits(MistEthereumProvider, _AbstractSocketProvid);\n\n    function MistEthereumProvider(connection) {\n      var _this;\n\n      _classCallCheck(this, MistEthereumProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MistEthereumProvider).call(this, connection, null));\n      _this.host = 'mist';\n      return _this;\n    }\n\n    _createClass(MistEthereumProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('connect', this.onReady.bind(this));\n        this.connection.on('end', this.onClose.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('end', this.onClose);\n            break;\n        }\n\n        _get(_getPrototypeOf(MistEthereumProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this2 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this2.connection.send(payload, function (error, response) {\n            _this2.removeAllListeners(payload.id);\n\n            if (!error) {\n              return resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.isConnected();\n      }\n    }]);\n\n    return MistEthereumProvider;\n  }(AbstractSocketProvider);\n\n  var CustomProvider = function () {\n    function CustomProvider(connection) {\n      _classCallCheck(this, CustomProvider);\n\n      this.host = 'CustomProvider';\n      this.connection = connection;\n      this.checkConnectionMethods();\n    }\n\n    _createClass(CustomProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return false;\n      }\n    }, {\n      key: \"checkConnectionMethods\",\n      value: function checkConnectionMethods() {\n        if (this.connection.send || this.connection.sendAsync) {\n          return true;\n        }\n\n        throw new Error('Invalid provider injected!');\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {\n        throw new Error('Subscriptions are not supported with the CustomProvider.');\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        throw new Error('Subscriptions are not supported with the CustomProvider.');\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this = this;\n\n        return new Promise(function (resolve, reject) {\n          if (_this.connection.sendAsync) {\n            _this.connection.sendAsync(payload, function (error, response) {\n              if (!error) {\n                resolve(response);\n              }\n\n              reject(error);\n            });\n\n            return;\n          }\n\n          _this.connection.send(payload, function (error, response) {\n            if (!error) {\n              resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }]);\n\n    return CustomProvider;\n  }();\n\n  var ProvidersModuleFactory = function () {\n    function ProvidersModuleFactory() {\n      _classCallCheck(this, ProvidersModuleFactory);\n    }\n\n    _createClass(ProvidersModuleFactory, [{\n      key: \"createBatchRequest\",\n      value: function createBatchRequest(moduleInstance) {\n        return new BatchRequest(moduleInstance);\n      }\n    }, {\n      key: \"createProviderResolver\",\n      value: function createProviderResolver() {\n        return new ProviderResolver(this);\n      }\n    }, {\n      key: \"createHttpProvider\",\n      value: function createHttpProvider(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new HttpProvider(url, options, this);\n      }\n    }, {\n      key: \"createXMLHttpRequest\",\n      value: function createXMLHttpRequest(host, timeout, headers, agent, withCredentials) {\n        var request;\n\n        if (typeof process !== 'undefined' && process.versions != null && process.versions.node != null) {\n          request = new xhr2Cookies.XMLHttpRequest();\n          request.nodejsSet(agent);\n        } else {\n          request = new XMLHttpRequest();\n        }\n\n        request.open('POST', host, true);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.timeout = timeout;\n        request.withCredentials = withCredentials;\n\n        if (headers) {\n          headers.forEach(function (header) {\n            request.setRequestHeader(header.name, header.value);\n          });\n        }\n\n        return request;\n      }\n    }, {\n      key: \"createWebsocketProvider\",\n      value: function createWebsocketProvider(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var connection = '';\n\n        if (typeof process !== 'undefined' && process.versions != null && process.versions.node != null) {\n          var headers = options.headers || {};\n          var urlObject = new URL(url);\n\n          if (!headers.authorization && urlObject.username && urlObject.password) {\n            var authToken = Buffer.from(\"\".concat(urlObject.username, \":\").concat(urlObject.password)).toString('base64');\n            headers.authorization = \"Basic \".concat(authToken);\n          }\n\n          connection = new websocket.w3cwebsocket(url, options.protocol, null, headers, null, options.clientConfig);\n        } else {\n          connection = new window.WebSocket(url, options.protocol);\n        }\n\n        return new WebsocketProvider(connection, options.timeout);\n      }\n    }, {\n      key: \"createIpcProvider\",\n      value: function createIpcProvider(path, net) {\n        return new IpcProvider(net.connect({\n          path: path\n        }), path);\n      }\n    }, {\n      key: \"createWeb3EthereumProvider\",\n      value: function createWeb3EthereumProvider(connection) {\n        return new Web3EthereumProvider(connection);\n      }\n    }, {\n      key: \"createMetamaskProvider\",\n      value: function createMetamaskProvider(inpageProvider) {\n        return new MetamaskProvider(inpageProvider);\n      }\n    }, {\n      key: \"createMistEthereumProvider\",\n      value: function createMistEthereumProvider(mistEthereumProvider) {\n        return new MistEthereumProvider(mistEthereumProvider);\n      }\n    }, {\n      key: \"createCustomProvider\",\n      value: function createCustomProvider(connection) {\n        return new CustomProvider(connection);\n      }\n    }]);\n\n    return ProvidersModuleFactory;\n  }();\n\n  var global$1 = function () {\n    return this || (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self;\n  }() || new Function('return this')();\n\n  var ProviderDetector = function () {\n    function ProviderDetector() {\n      _classCallCheck(this, ProviderDetector);\n    }\n\n    _createClass(ProviderDetector, null, [{\n      key: \"detect\",\n      value: function detect() {\n        if (typeof global$1.ethereumProvider !== 'undefined' && global$1.ethereumProvider.constructor.name === 'EthereumProvider') {\n          return global$1.ethereumProvider;\n        }\n\n        if (typeof global$1.web3 !== 'undefined' && global$1.web3.currentProvider) {\n          return global$1.web3.currentProvider;\n        }\n\n        return null;\n      }\n    }]);\n\n    return ProviderDetector;\n  }();\n\n  function HttpProvider$1(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ProvidersModuleFactory().createHttpProvider(url, options);\n  }\n\n  function WebsocketProvider$1(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ProvidersModuleFactory().createWebsocketProvider(url, options);\n  }\n\n  function IpcProvider$1(path, net) {\n    return new ProvidersModuleFactory().createIpcProvider(path, net);\n  }\n\n  function BatchRequest$1(moduleInstance) {\n    return new ProvidersModuleFactory().createBatchRequest(moduleInstance);\n  }\n\n  function ProviderResolver$1() {\n    return new ProvidersModuleFactory().createProviderResolver();\n  }\n\n  exports.BatchRequest = BatchRequest$1;\n  exports.HttpProvider = HttpProvider$1;\n  exports.IpcProvider = IpcProvider$1;\n  exports.ProviderDetector = ProviderDetector;\n  exports.ProviderResolver = ProviderResolver$1;\n  exports.ProvidersModuleFactory = ProvidersModuleFactory;\n  exports.Web3EthereumProvider = Web3EthereumProvider;\n  exports.WebsocketProvider = WebsocketProvider$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/typeof'), require('lodash/isObject'), require('lodash/isString'), require('lodash/isArray'), require('lodash/isBoolean'), require('lodash/isNumber'), require('lodash/isNull'), require('number-to-bn'), require('utf8'), require('eth-lib/lib/hash'), require('bn.js'), require('ethjs-unit'), require('randombytes'), require('lodash/map')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/typeof', 'lodash/isObject', 'lodash/isString', 'lodash/isArray', 'lodash/isBoolean', 'lodash/isNumber', 'lodash/isNull', 'number-to-bn', 'utf8', 'eth-lib/lib/hash', 'bn.js', 'ethjs-unit', 'randombytes', 'lodash/map'], factory) : (global = global || self, factory(global.Web3Utils = {}, global._typeof, global.isObject, global.isString, global.isArray, global.isBoolean, global.isNumber, global.isNull, global.numberToBN, global.utf8, global.Hash, global.BN, global.ethjsUnit, global.randombytes, global.map));\n})(this, function (exports, _typeof, isObject, isString, isArray, isBoolean, isNumber, isNull, numberToBN, utf8, Hash, BN, ethjsUnit, randombytes, map) {\n  'use strict';\n\n  _typeof = _typeof && _typeof.hasOwnProperty('default') ? _typeof['default'] : _typeof;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;\n  isArray = isArray && isArray.hasOwnProperty('default') ? isArray['default'] : isArray;\n  isBoolean = isBoolean && isBoolean.hasOwnProperty('default') ? isBoolean['default'] : isBoolean;\n  isNumber = isNumber && isNumber.hasOwnProperty('default') ? isNumber['default'] : isNumber;\n  isNull = isNull && isNull.hasOwnProperty('default') ? isNull['default'] : isNull;\n  numberToBN = numberToBN && numberToBN.hasOwnProperty('default') ? numberToBN['default'] : numberToBN;\n  utf8 = utf8 && utf8.hasOwnProperty('default') ? utf8['default'] : utf8;\n  Hash = Hash && Hash.hasOwnProperty('default') ? Hash['default'] : Hash;\n  BN = BN && BN.hasOwnProperty('default') ? BN['default'] : BN;\n  randombytes = randombytes && randombytes.hasOwnProperty('default') ? randombytes['default'] : randombytes;\n  map = map && map.hasOwnProperty('default') ? map['default'] : map;\n\n  var isBN = function isBN(object) {\n    return BN.isBN(object);\n  };\n\n  var isBigNumber = function isBigNumber(object) {\n    return object && object.constructor && object.constructor.name === 'BigNumber';\n  };\n\n  var toBN = function toBN(number) {\n    try {\n      return numberToBN(number);\n    } catch (error) {\n      throw new Error(\"\".concat(error, \" Given value: \\\"\").concat(number, \"\\\"\"));\n    }\n  };\n\n  var toTwosComplement = function toTwosComplement(number) {\n    return \"0x\".concat(toBN(number).toTwos(256).toString(16, 64));\n  };\n\n  var isAddress = function isAddress(address) {\n    var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n      return false;\n    } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n      return true;\n    } else {\n      return checkAddressChecksum(address, chainId);\n    }\n  };\n\n  var stripHexPrefix = function stripHexPrefix(string) {\n    return string.slice(0, 2) === '0x' ? string.slice(2) : string;\n  };\n\n  var checkAddressChecksum = function checkAddressChecksum(address) {\n    var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var stripAddress = stripHexPrefix(address).toLowerCase();\n    var prefix = chainId != null ? chainId.toString() + '0x' : '';\n    var keccakHash = Hash.keccak256(prefix + stripAddress).toString('hex').replace(/^0x/i, '');\n\n    for (var i = 0; i < stripAddress.length; i++) {\n      var output = parseInt(keccakHash[i], 16) >= 8 ? stripAddress[i].toUpperCase() : stripAddress[i];\n\n      if (stripHexPrefix(address)[i] !== output) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var leftPad = function leftPad(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string;\n  };\n\n  var rightPad = function rightPad(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0');\n  };\n\n  var utf8ToHex = function utf8ToHex(value) {\n    value = utf8.encode(value);\n    var hex = '';\n    value = value.replace(/^(?:\\u0000)*/, '');\n    value = value.split('').reverse().join('');\n    value = value.replace(/^(?:\\u0000)*/, '');\n    value = value.split('').reverse().join('');\n\n    for (var i = 0; i < value.length; i++) {\n      var code = value.charCodeAt(i);\n      var n = code.toString(16);\n      hex += n.length < 2 ? \"0\".concat(n) : n;\n    }\n\n    return \"0x\".concat(hex);\n  };\n\n  var hexToUtf8 = function hexToUtf8(hex) {\n    if (!isHexStrict(hex)) throw new Error(\"The parameter \\\"\".concat(hex, \"\\\" must be a valid HEX string.\"));\n    var string = '';\n    var code = 0;\n    hex = hex.replace(/^0x/i, '');\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split('').reverse().join('');\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split('').reverse().join('');\n    var l = hex.length;\n\n    for (var i = 0; i < l; i += 2) {\n      code = parseInt(hex.substr(i, 2), 16);\n      string += String.fromCharCode(code);\n    }\n\n    return utf8.decode(string);\n  };\n\n  var hexToNumber = function hexToNumber(value) {\n    if (!value) {\n      return value;\n    }\n\n    return toBN(value).toNumber();\n  };\n\n  var hexToNumberString = function hexToNumberString(value) {\n    if (!value) return value;\n    return toBN(value).toString(10);\n  };\n\n  var numberToHex = function numberToHex(value) {\n    if (isNull(value) || typeof value === 'undefined') {\n      return value;\n    }\n\n    if (!isFinite(value) && !isHexStrict(value)) {\n      throw new Error(\"Given input \\\"\".concat(value, \"\\\" is not a number.\"));\n    }\n\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? \"-0x\".concat(result.substr(1)) : \"0x\".concat(result);\n  };\n\n  var bytesToHex = function bytesToHex(bytes) {\n    var hex = [];\n\n    for (var i = 0; i < bytes.length; i++) {\n      hex.push((bytes[i] >>> 4).toString(16));\n      hex.push((bytes[i] & 0xf).toString(16));\n    }\n\n    return \"0x\".concat(hex.join('').replace(/^0+/, ''));\n  };\n\n  var hexToBytes = function hexToBytes(hex) {\n    hex = hex.toString(16);\n\n    if (!isHexStrict(hex)) {\n      throw new Error(\"Given value \\\"\".concat(hex, \"\\\" is not a valid hex string.\"));\n    }\n\n    hex = hex.replace(/^0x/i, '');\n    hex = hex.length % 2 ? '0' + hex : hex;\n    var bytes = [];\n\n    for (var c = 0; c < hex.length; c += 2) {\n      bytes.push(parseInt(hex.substr(c, 2), 16));\n    }\n\n    return bytes;\n  };\n\n  var toHex = function toHex(value, returnType) {\n    if (isAddress(value)) {\n      return returnType ? 'address' : \"0x\".concat(value.toLowerCase().replace(/^0x/i, ''));\n    }\n\n    if (isBoolean(value)) {\n      return returnType ? 'bool' : value ? '0x01' : '0x00';\n    }\n\n    if (isObject(value) && !isBigNumber(value) && !isBN(value)) {\n      return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n    }\n\n    if (isString(value)) {\n      if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n        return returnType ? 'int256' : numberToHex(value);\n      } else if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n        return returnType ? 'bytes' : value;\n      } else if (!isFinite(value)) {\n        return returnType ? 'string' : utf8ToHex(value);\n      }\n    }\n\n    return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);\n  };\n\n  var isHexStrict = function isHexStrict(hex) {\n    return (isString(hex) || isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n  };\n\n  var isHex = function isHex(hex) {\n    return (isString(hex) || isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n  };\n\n  var isBloom = function isBloom(bloom) {\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n      return false;\n    } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var isTopic = function isTopic(topic) {\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n      return false;\n    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var KECCAK256_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n\n  var keccak256 = function keccak256(value) {\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n      value = hexToBytes(value);\n    }\n\n    var returnValue = Hash.keccak256(value);\n\n    if (returnValue === KECCAK256_NULL_S) {\n      return null;\n    } else {\n      return returnValue;\n    }\n  };\n\n  keccak256._Hash = Hash;\n\n  var getSignatureParameters = function getSignatureParameters(signature) {\n    if (!isHexStrict(signature)) {\n      throw new Error(\"Given value \\\"\".concat(signature, \"\\\" is not a valid hex string.\"));\n    }\n\n    var r = signature.slice(0, 66);\n    var s = \"0x\".concat(signature.slice(66, 130));\n    var v = \"0x\".concat(signature.slice(130, 132));\n    v = hexToNumber(v);\n    if (![27, 28].includes(v)) v += 27;\n    return {\n      r: r,\n      s: s,\n      v: v\n    };\n  };\n\n  var utils =\n  /*#__PURE__*/\n  Object.freeze({\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    toTwosComplement: toTwosComplement,\n    isAddress: isAddress,\n    stripHexPrefix: stripHexPrefix,\n    checkAddressChecksum: checkAddressChecksum,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    bytesToHex: bytesToHex,\n    hexToBytes: hexToBytes,\n    toHex: toHex,\n    isHexStrict: isHexStrict,\n    isHex: isHex,\n    isBloom: isBloom,\n    isTopic: isTopic,\n    keccak256: keccak256,\n    getSignatureParameters: getSignatureParameters\n  });\n\n  var _elementaryName = function _elementaryName(name) {\n    if (name.startsWith('int[')) {\n      return \"int256\".concat(name.slice(3));\n    }\n\n    if (name === 'int') {\n      return 'int256';\n    }\n\n    if (name.startsWith('uint[')) {\n      return \"uint256\".concat(name.slice(4));\n    }\n\n    if (name === 'uint') {\n      return 'uint256';\n    }\n\n    if (name.startsWith('fixed[')) {\n      return \"fixed128x128\".concat(name.slice(5));\n    }\n\n    if (name === 'fixed') {\n      return 'fixed128x128';\n    }\n\n    if (name.startsWith('ufixed[')) {\n      return \"ufixed128x128\".concat(name.slice(6));\n    }\n\n    if (name === 'ufixed') {\n      return 'ufixed128x128';\n    }\n\n    return name;\n  };\n\n  var _parseTypeN = function _parseTypeN(type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n  };\n\n  var _parseTypeNArray = function _parseTypeNArray(type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n  };\n\n  var _parseNumber = function _parseNumber(argument) {\n    var type = _typeof(argument);\n\n    if (type === 'string') {\n      if (isHexStrict(argument)) {\n        return new BN(argument.replace(/0x/i, ''), 16);\n      } else {\n        return new BN(argument, 10);\n      }\n    } else if (type === 'number') {\n      return new BN(argument);\n    } else if (isBigNumber(argument)) {\n      return new BN(argument.toString(10));\n    } else if (isBN(argument)) {\n      return argument;\n    } else {\n      throw new Error(\"\".concat(argument, \" is not a number\"));\n    }\n  };\n\n  var _solidityPack = function _solidityPack(type, value, arraySize) {\n    var size, number;\n    type = _elementaryName(type);\n\n    if (type === 'bytes') {\n      if (value.replace(/^0x/i, '').length % 2 !== 0) {\n        throw new Error(\"Invalid bytes characters \".concat(value.length));\n      }\n\n      return value;\n    } else if (type === 'string') {\n      return utf8ToHex(value);\n    } else if (type === 'bool') {\n      return value ? '01' : '00';\n    } else if (type.startsWith('address')) {\n      if (arraySize) {\n        size = 64;\n      } else {\n        size = 40;\n      }\n\n      if (!isAddress(value)) {\n        throw new Error(\"\".concat(value, \" is not a valid address, or the checksum is invalid.\"));\n      }\n\n      return leftPad(value.toLowerCase(), size);\n    }\n\n    size = _parseTypeN(type);\n\n    if (type.startsWith('bytes')) {\n      if (!size) {\n        throw new Error('bytes[] not yet supported in solidity');\n      }\n\n      if (arraySize) {\n        size = 32;\n      }\n\n      if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {\n        throw new Error(\"Invalid bytes\".concat(size, \" for \").concat(value));\n      }\n\n      return rightPad(value, size * 2);\n    } else if (type.startsWith('uint')) {\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error(\"Invalid uint\".concat(size, \" size\"));\n      }\n\n      number = _parseNumber(value);\n\n      if (number.bitLength() > size) {\n        throw new Error(\"Supplied uint exceeds width: \".concat(size, \" vs \").concat(number.bitLength()));\n      }\n\n      if (number.lt(new BN(0))) {\n        throw new Error(\"Supplied uint \".concat(number.toString(), \" is negative\"));\n      }\n\n      return size ? leftPad(number.toString('hex'), size / 8 * 2) : number;\n    } else if (type.startsWith('int')) {\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error(\"Invalid int\".concat(size, \" size\"));\n      }\n\n      number = _parseNumber(value);\n\n      if (number.bitLength() > size) {\n        throw new Error(\"Supplied int exceeds width: \".concat(size, \" vs \").concat(number.bitLength()));\n      }\n\n      if (number.lt(new BN(0))) {\n        return number.toTwos(size).toString('hex');\n      } else {\n        return size ? leftPad(number.toString('hex'), size / 8 * 2) : number;\n      }\n    } else {\n      throw new Error(\"Unsupported or invalid type: \".concat(type));\n    }\n  };\n\n  var _processSoliditySha3Arguments = function _processSoliditySha3Arguments(argument) {\n    if (isArray(argument)) {\n      throw new Error('Autodetection of array types is not supported.');\n    }\n\n    var type;\n    var value = '';\n    var hexArgument, arraySize;\n\n    if (isObject(argument) && (argument.hasOwnProperty('v') || argument.hasOwnProperty('t') || argument.hasOwnProperty('value') || argument.hasOwnProperty('type'))) {\n      type = argument.hasOwnProperty('t') ? argument.t : argument.type;\n      value = argument.hasOwnProperty('v') ? argument.v : argument.value;\n    } else {\n      type = toHex(argument, true);\n      value = toHex(argument);\n\n      if (!type.startsWith('int') && !type.startsWith('uint')) {\n        type = 'bytes';\n      }\n    }\n\n    if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n      value = new BN(value);\n    }\n\n    if (isArray(value)) {\n      arraySize = _parseTypeNArray(type);\n\n      if (arraySize && value.length !== arraySize) {\n        throw new Error(\"\".concat(type, \" is not matching the given array \").concat(JSON.stringify(value)));\n      } else {\n        arraySize = value.length;\n      }\n    }\n\n    if (isArray(value)) {\n      hexArgument = value.map(function (value_) {\n        return _solidityPack(type, value_, arraySize).toString('hex').replace('0x', '');\n      });\n      return hexArgument.join('');\n    } else {\n      hexArgument = _solidityPack(type, value, arraySize);\n      return hexArgument.toString('hex').replace('0x', '');\n    }\n  };\n\n  var soliditySha3 = function soliditySha3() {\n    var arguments_ = Array.prototype.slice.call(arguments);\n    var hexArguments = map(arguments_, _processSoliditySha3Arguments);\n    return keccak256(\"0x\".concat(hexArguments.join('')));\n  };\n\n  var randomHex = function randomHex(size) {\n    return '0x' + randombytes(size).toString('hex');\n  };\n\n  var jsonInterfaceMethodToString = function jsonInterfaceMethodToString(json) {\n    if (isObject(json) && json.name && json.name.includes('(')) {\n      return json.name;\n    }\n\n    return \"\".concat(json.name, \"(\").concat(_flattenTypes(false, json.inputs).join(','), \")\");\n  };\n\n  var _flattenTypes = function _flattenTypes(includeTuple, puts) {\n    var types = [];\n    puts.forEach(function (param) {\n      if (_typeof(param.components) === 'object') {\n        if (param.type.substring(0, 5) !== 'tuple') {\n          throw new Error('components found but type is not tuple; report on GitHub');\n        }\n\n        var suffix = '';\n        var arrayBracket = param.type.indexOf('[');\n\n        if (arrayBracket >= 0) {\n          suffix = param.type.substring(arrayBracket);\n        }\n\n        var result = _flattenTypes(includeTuple, param.components);\n\n        if (isArray(result) && includeTuple) {\n          types.push(\"tuple(\".concat(result.join(','), \")\").concat(suffix));\n        } else if (!includeTuple) {\n          types.push(\"(\".concat(result.join(','), \")\").concat(suffix));\n        } else {\n          types.push(\"(\".concat(result, \")\"));\n        }\n      } else {\n        types.push(param.type);\n      }\n    });\n    return types;\n  };\n\n  var hexToAscii = function hexToAscii(hex) {\n    if (!isHexStrict(hex)) throw new Error('The parameter must be a valid HEX string.');\n    var value = '';\n    var i = 0;\n    var l = hex.length;\n\n    if (hex.substring(0, 2) === '0x') {\n      i = 2;\n    }\n\n    for (; i < l; i += 2) {\n      var code = parseInt(hex.substr(i, 2), 16);\n      value += String.fromCharCode(code);\n    }\n\n    return value;\n  };\n\n  var asciiToHex = function asciiToHex(value) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    var hex = '';\n\n    for (var i = 0; i < value.length; i++) {\n      var code = value.charCodeAt(i);\n      var n = code.toString(16);\n      hex += n.length < 2 ? \"0\".concat(n) : n;\n    }\n\n    return '0x' + rightPad(hex, length * 2);\n  };\n\n  var getUnitValue = function getUnitValue(unit) {\n    unit = unit ? unit.toLowerCase() : 'ether';\n\n    if (!ethjsUnit.unitMap[unit]) {\n      throw new Error(\"This unit \\\"\".concat(unit, \"\\\" doesn't exist, please use the one of the following units\").concat(JSON.stringify(ethjsUnit.unitMap, null, 2)));\n    }\n\n    return unit;\n  };\n\n  var fromWei = function fromWei(number, unit) {\n    unit = getUnitValue(unit);\n\n    if (!isBN(number) && !isString(number)) {\n      throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n\n    return isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n  };\n\n  var toWei = function toWei(number, unit) {\n    unit = getUnitValue(unit);\n\n    if (!isBN(number) && !isString(number)) {\n      throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n\n    return isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n  };\n\n  var toChecksumAddress = function toChecksumAddress(address) {\n    var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (typeof address !== 'string') {\n      return '';\n    }\n\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) throw new Error(\"Given address \\\"\".concat(address, \"\\\" is not a valid Ethereum address.\"));\n    var stripAddress = stripHexPrefix$1(address).toLowerCase();\n    var prefix = chainId != null ? chainId.toString() + '0x' : '';\n    var keccakHash = Hash.keccak256(prefix + stripAddress).toString('hex').replace(/^0x/i, '');\n    var checksumAddress = '0x';\n\n    for (var i = 0; i < stripAddress.length; i++) {\n      checksumAddress += parseInt(keccakHash[i], 16) >= 8 ? stripAddress[i].toUpperCase() : stripAddress[i];\n    }\n\n    return checksumAddress;\n  };\n\n  var keccak256$1 = keccak256;\n  var sha3 = keccak256;\n  var toDecimal = hexToNumber;\n  var hexToNumber$1 = hexToNumber;\n  var fromDecimal = numberToHex;\n  var numberToHex$1 = numberToHex;\n  var hexToUtf8$1 = hexToUtf8;\n  var hexToString = hexToUtf8;\n  var toUtf8 = hexToUtf8;\n  var stringToHex = utf8ToHex;\n  var fromUtf8 = utf8ToHex;\n  var utf8ToHex$1 = utf8ToHex;\n  var toAscii = hexToAscii;\n  var fromAscii = asciiToHex;\n  var padLeft = leftPad;\n  var padRight = rightPad;\n  var getSignatureParameters$1 = getSignatureParameters;\n  var isAddress$1 = isAddress;\n  var isBN$1 = isBN;\n  var checkAddressChecksum$1 = checkAddressChecksum;\n  var toBN$1 = toBN;\n  var toHex$1 = toHex;\n  var hexToNumberString$1 = hexToNumberString;\n  var toTwosComplement$1 = toTwosComplement;\n  var isHex$1 = isHex;\n  var isHexStrict$1 = isHexStrict;\n  var isBloom$1 = isBloom;\n  var isTopic$1 = isTopic;\n  var bytesToHex$1 = bytesToHex;\n  var hexToBytes$1 = hexToBytes;\n  var stripHexPrefix$1 = stripHexPrefix;\n  exports.BN = BN;\n  exports.asciiToHex = asciiToHex;\n  exports.bytesToHex = bytesToHex$1;\n  exports.checkAddressChecksum = checkAddressChecksum$1;\n  exports.fromAscii = fromAscii;\n  exports.fromDecimal = fromDecimal;\n  exports.fromUtf8 = fromUtf8;\n  exports.fromWei = fromWei;\n  exports.getSignatureParameters = getSignatureParameters$1;\n  exports.getUnitValue = getUnitValue;\n  exports.hexToAscii = hexToAscii;\n  exports.hexToBytes = hexToBytes$1;\n  exports.hexToNumber = hexToNumber$1;\n  exports.hexToNumberString = hexToNumberString$1;\n  exports.hexToString = hexToString;\n  exports.hexToUtf8 = hexToUtf8$1;\n  exports.isAddress = isAddress$1;\n  exports.isBN = isBN$1;\n  exports.isBloom = isBloom$1;\n  exports.isHex = isHex$1;\n  exports.isHexStrict = isHexStrict$1;\n  exports.isTopic = isTopic$1;\n  exports.jsonInterfaceMethodToString = jsonInterfaceMethodToString;\n  exports.keccak256 = keccak256$1;\n  exports.numberToHex = numberToHex$1;\n  exports.padLeft = padLeft;\n  exports.padRight = padRight;\n  exports.randomHex = randomHex;\n  exports.sha3 = sha3;\n  exports.soliditySha3 = soliditySha3;\n  exports.stringToHex = stringToHex;\n  exports.stripHexPrefix = stripHexPrefix$1;\n  exports.toAscii = toAscii;\n  exports.toBN = toBN$1;\n  exports.toChecksumAddress = toChecksumAddress;\n  exports.toDecimal = toDecimal;\n  exports.toHex = toHex$1;\n  exports.toTwosComplement = toTwosComplement$1;\n  exports.toUtf8 = toUtf8;\n  exports.toWei = toWei;\n  exports.utf8ToHex = utf8ToHex$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}
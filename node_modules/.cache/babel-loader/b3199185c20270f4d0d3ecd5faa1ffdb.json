{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _require = require('readable-stream'),\n    Duplex = _require.Duplex;\n\nvar PullDuplexStream =\n/*#__PURE__*/\nfunction (_Duplex) {\n  _inherits(PullDuplexStream, _Duplex);\n\n  function PullDuplexStream(source, sink, options) {\n    var _this;\n\n    _classCallCheck(this, PullDuplexStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PullDuplexStream).call(this, options));\n    _this.source = source;\n    _this.drainingSource = false;\n    _this.sink = sink;\n    _this.input = [];\n    _this.writeCallbacks = [];\n    _this.internalSourceCallbacks = [];\n\n    if (_this.sink) {\n      _this.sink(_this._internalSource.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    }\n\n    return _this;\n  }\n\n  _createClass(PullDuplexStream, [{\n    key: \"drainPull\",\n    value: function drainPull() {\n      var self = this;\n      this.drainingSource = true;\n      this.source(null, function next(end, data) {\n        if (end instanceof Error) {\n          return self.emit('error', end);\n        }\n\n        if (end) {\n          return self.push(null);\n        }\n\n        if (self.push(data)) {\n          self.source(null, next);\n        } else {\n          self.drainingSource = false;\n        }\n      });\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this.source && !this.drainingSource) {\n        this.drainPull();\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(null, chunk);\n        callback();\n      } else {\n        this.input.push(chunk);\n        this.writeCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"_internalSource\",\n    value: function _internalSource(end, cb) {\n      if (end) {\n        if (this.writeCallbacks.length > 0) {\n          // call write callback with error\n          this.writeCallbacks.shift()(end instanceof Error ? end : new Error('Aborted'));\n        }\n\n        return cb(end);\n      }\n\n      if (this.input.length > 0) {\n        cb(null, this.input.shift());\n        this.writeCallbacks.shift()();\n      } else {\n        this.internalSourceCallbacks.push(cb);\n      }\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      // end the internal source\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(true);\n      }\n\n      callback();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, cb) {\n      // abort the source\n      if (!this._readableState.ended && this.source) {\n        this.source(true, function () {// do nothing\n        });\n      } // propagate error to sink\n\n\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(err);\n      }\n\n      cb(err);\n    }\n  }]);\n\n  return PullDuplexStream;\n}(Duplex);\n\nfunction wrapper(source, sink, options) {\n  if (source && typeof source === 'object') {\n    source = source.source;\n    sink = source.sink;\n  }\n\n  return new PullDuplexStream(source, sink, Object.assign({\n    readableObjectMode: true,\n    writableObjectMode: true\n  }, options));\n}\n\nmodule.exports = {\n  duplex: wrapper,\n  readable: function readable(source, options) {\n    return wrapper(source, null, options);\n  },\n  writeable: function writeable(sink, options) {\n    return wrapper(null, sink, options);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}
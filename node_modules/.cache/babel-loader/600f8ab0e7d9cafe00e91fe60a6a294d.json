{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar ieee754 = require('ieee754');\n\nvar Bignumber = require('bignumber.js').BigNumber;\n\nvar parser = require('./decoder.asm');\n\nvar utils = require('./utils');\n\nvar c = require('./constants');\n\nvar Simple = require('./simple');\n\nvar Tagged = require('./tagged');\n\nvar _require2 = require('iso-url'),\n    URL = _require2.URL;\n/**\n * Transform binary cbor data into JavaScript objects.\n */\n\n\nvar Decoder =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  function Decoder(opts) {\n    _classCallCheck(this, Decoder);\n\n    opts = opts || {};\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000;\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size);\n    } // Heap use to share the input with the parser\n\n\n    this._heap = new ArrayBuffer(opts.size);\n    this._heap8 = new Uint8Array(this._heap);\n    this._buffer = Buffer.from(this._heap);\n\n    this._reset(); // Known tags\n\n\n    this._knownTags = Object.assign({\n      0: function _(val) {\n        return new Date(val);\n      },\n      1: function _(val) {\n        return new Date(val * 1000);\n      },\n      2: function _(val) {\n        return utils.arrayBufferToBignumber(val);\n      },\n      3: function _(val) {\n        return c.NEG_ONE.minus(utils.arrayBufferToBignumber(val));\n      },\n      4: function _(v) {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1]);\n      },\n      5: function _(v) {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1]);\n      },\n      32: function _(val) {\n        return new URL(val);\n      },\n      35: function _(val) {\n        return new RegExp(val);\n      }\n    }, opts.tags); // Initialize asm based parser\n\n    this.parser = parser(global, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap);\n  }\n\n  _createClass(Decoder, [{\n    key: \"_closeParent\",\n    // Finish the current parent\n    value: function _closeParent() {\n      var p = this._parents.pop();\n\n      if (p.length > 0) {\n        throw new Error(\"Missing \".concat(p.length, \" elements\"));\n      }\n\n      switch (p.type) {\n        case c.PARENT.TAG:\n          this._push(this.createTag(p.ref[0], p.ref[1]));\n\n          break;\n\n        case c.PARENT.BYTE_STRING:\n          this._push(this.createByteString(p.ref, p.length));\n\n          break;\n\n        case c.PARENT.UTF8_STRING:\n          this._push(this.createUtf8String(p.ref, p.length));\n\n          break;\n\n        case c.PARENT.MAP:\n          if (p.values % 2 > 0) {\n            throw new Error('Odd number of elements in the map');\n          }\n\n          this._push(this.createMap(p.ref, p.length));\n\n          break;\n\n        case c.PARENT.OBJECT:\n          if (p.values % 2 > 0) {\n            throw new Error('Odd number of elements in the map');\n          }\n\n          this._push(this.createObject(p.ref, p.length));\n\n          break;\n\n        case c.PARENT.ARRAY:\n          this._push(this.createArray(p.ref, p.length));\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n        this._dec();\n      }\n    } // Reduce the expected length of the current parent by one\n\n  }, {\n    key: \"_dec\",\n    value: function _dec() {\n      var p = this._currentParent; // The current parent does not know the epxected child length\n\n      if (p.length < 0) {\n        return;\n      }\n\n      p.length--; // All children were seen, we can close the current parent\n\n      if (p.length === 0) {\n        this._closeParent();\n      }\n    } // Push any value to the current parent\n\n  }, {\n    key: \"_push\",\n    value: function _push(val, hasChildren) {\n      var p = this._currentParent;\n      p.values++;\n\n      switch (p.type) {\n        case c.PARENT.ARRAY:\n        case c.PARENT.BYTE_STRING:\n        case c.PARENT.UTF8_STRING:\n          if (p.length > -1) {\n            this._ref[this._ref.length - p.length] = val;\n          } else {\n            this._ref.push(val);\n          }\n\n          this._dec();\n\n          break;\n\n        case c.PARENT.OBJECT:\n          if (p.tmpKey != null) {\n            this._ref[p.tmpKey] = val;\n            p.tmpKey = null;\n\n            this._dec();\n          } else {\n            p.tmpKey = val;\n\n            if (typeof p.tmpKey !== 'string') {\n              // too bad, convert to a Map\n              p.type = c.PARENT.MAP;\n              p.ref = utils.buildMap(p.ref);\n            }\n          }\n\n          break;\n\n        case c.PARENT.MAP:\n          if (p.tmpKey != null) {\n            this._ref.set(p.tmpKey, val);\n\n            p.tmpKey = null;\n\n            this._dec();\n          } else {\n            p.tmpKey = val;\n          }\n\n          break;\n\n        case c.PARENT.TAG:\n          this._ref.push(val);\n\n          if (!hasChildren) {\n            this._dec();\n          }\n\n          break;\n\n        default:\n          throw new Error('Unknown parent type');\n      }\n    } // Create a new parent in the parents list\n\n  }, {\n    key: \"_createParent\",\n    value: function _createParent(obj, type, len) {\n      this._parents[this._depth] = {\n        type: type,\n        length: len,\n        ref: obj,\n        values: 0,\n        tmpKey: null\n      };\n    } // Reset all state back to the beginning, also used for initiatlization\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._res = [];\n      this._parents = [{\n        type: c.PARENT.ARRAY,\n        length: -1,\n        ref: this._res,\n        values: 0,\n        tmpKey: null\n      }];\n    } // -- Interface to customize deoding behaviour\n\n  }, {\n    key: \"createTag\",\n    value: function createTag(tagNumber, value) {\n      var typ = this._knownTags[tagNumber];\n\n      if (!typ) {\n        return new Tagged(tagNumber, value);\n      }\n\n      return typ(value);\n    }\n  }, {\n    key: \"createMap\",\n    value: function createMap(obj, len) {\n      return obj;\n    }\n  }, {\n    key: \"createObject\",\n    value: function createObject(obj, len) {\n      return obj;\n    }\n  }, {\n    key: \"createArray\",\n    value: function createArray(arr, len) {\n      return arr;\n    }\n  }, {\n    key: \"createByteString\",\n    value: function createByteString(raw, len) {\n      return Buffer.concat(raw);\n    }\n  }, {\n    key: \"createByteStringFromHeap\",\n    value: function createByteStringFromHeap(start, end) {\n      if (start === end) {\n        return Buffer.alloc(0);\n      }\n\n      return Buffer.from(this._heap.slice(start, end));\n    }\n  }, {\n    key: \"createInt\",\n    value: function createInt(val) {\n      return val;\n    }\n  }, {\n    key: \"createInt32\",\n    value: function createInt32(f, g) {\n      return utils.buildInt32(f, g);\n    }\n  }, {\n    key: \"createInt64\",\n    value: function createInt64(f1, f2, g1, g2) {\n      return utils.buildInt64(f1, f2, g1, g2);\n    }\n  }, {\n    key: \"createFloat\",\n    value: function createFloat(val) {\n      return val;\n    }\n  }, {\n    key: \"createFloatSingle\",\n    value: function createFloatSingle(a, b, c, d) {\n      return ieee754.read([a, b, c, d], 0, false, 23, 4);\n    }\n  }, {\n    key: \"createFloatDouble\",\n    value: function createFloatDouble(a, b, c, d, e, f, g, h) {\n      return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8);\n    }\n  }, {\n    key: \"createInt32Neg\",\n    value: function createInt32Neg(f, g) {\n      return -1 - utils.buildInt32(f, g);\n    }\n  }, {\n    key: \"createInt64Neg\",\n    value: function createInt64Neg(f1, f2, g1, g2) {\n      var f = utils.buildInt32(f1, f2);\n      var g = utils.buildInt32(g1, g2);\n\n      if (f > c.MAX_SAFE_HIGH) {\n        return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));\n      }\n\n      return -1 - (f * c.SHIFT32 + g);\n    }\n  }, {\n    key: \"createTrue\",\n    value: function createTrue() {\n      return true;\n    }\n  }, {\n    key: \"createFalse\",\n    value: function createFalse() {\n      return false;\n    }\n  }, {\n    key: \"createNull\",\n    value: function createNull() {\n      return null;\n    }\n  }, {\n    key: \"createUndefined\",\n    value: function createUndefined() {\n      return undefined;\n    }\n  }, {\n    key: \"createInfinity\",\n    value: function createInfinity() {\n      return Infinity;\n    }\n  }, {\n    key: \"createInfinityNeg\",\n    value: function createInfinityNeg() {\n      return -Infinity;\n    }\n  }, {\n    key: \"createNaN\",\n    value: function createNaN() {\n      return NaN;\n    }\n  }, {\n    key: \"createNaNNeg\",\n    value: function createNaNNeg() {\n      return -NaN;\n    }\n  }, {\n    key: \"createUtf8String\",\n    value: function createUtf8String(raw, len) {\n      return raw.join('');\n    }\n  }, {\n    key: \"createUtf8StringFromHeap\",\n    value: function createUtf8StringFromHeap(start, end) {\n      if (start === end) {\n        return '';\n      }\n\n      return this._buffer.toString('utf8', start, end);\n    }\n  }, {\n    key: \"createSimpleUnassigned\",\n    value: function createSimpleUnassigned(val) {\n      return new Simple(val);\n    } // -- Interface for decoder.asm.js\n\n  }, {\n    key: \"pushInt\",\n    value: function pushInt(val) {\n      this._push(this.createInt(val));\n    }\n  }, {\n    key: \"pushInt32\",\n    value: function pushInt32(f, g) {\n      this._push(this.createInt32(f, g));\n    }\n  }, {\n    key: \"pushInt64\",\n    value: function pushInt64(f1, f2, g1, g2) {\n      this._push(this.createInt64(f1, f2, g1, g2));\n    }\n  }, {\n    key: \"pushFloat\",\n    value: function pushFloat(val) {\n      this._push(this.createFloat(val));\n    }\n  }, {\n    key: \"pushFloatSingle\",\n    value: function pushFloatSingle(a, b, c, d) {\n      this._push(this.createFloatSingle(a, b, c, d));\n    }\n  }, {\n    key: \"pushFloatDouble\",\n    value: function pushFloatDouble(a, b, c, d, e, f, g, h) {\n      this._push(this.createFloatDouble(a, b, c, d, e, f, g, h));\n    }\n  }, {\n    key: \"pushInt32Neg\",\n    value: function pushInt32Neg(f, g) {\n      this._push(this.createInt32Neg(f, g));\n    }\n  }, {\n    key: \"pushInt64Neg\",\n    value: function pushInt64Neg(f1, f2, g1, g2) {\n      this._push(this.createInt64Neg(f1, f2, g1, g2));\n    }\n  }, {\n    key: \"pushTrue\",\n    value: function pushTrue() {\n      this._push(this.createTrue());\n    }\n  }, {\n    key: \"pushFalse\",\n    value: function pushFalse() {\n      this._push(this.createFalse());\n    }\n  }, {\n    key: \"pushNull\",\n    value: function pushNull() {\n      this._push(this.createNull());\n    }\n  }, {\n    key: \"pushUndefined\",\n    value: function pushUndefined() {\n      this._push(this.createUndefined());\n    }\n  }, {\n    key: \"pushInfinity\",\n    value: function pushInfinity() {\n      this._push(this.createInfinity());\n    }\n  }, {\n    key: \"pushInfinityNeg\",\n    value: function pushInfinityNeg() {\n      this._push(this.createInfinityNeg());\n    }\n  }, {\n    key: \"pushNaN\",\n    value: function pushNaN() {\n      this._push(this.createNaN());\n    }\n  }, {\n    key: \"pushNaNNeg\",\n    value: function pushNaNNeg() {\n      this._push(this.createNaNNeg());\n    }\n  }, {\n    key: \"pushArrayStart\",\n    value: function pushArrayStart() {\n      this._createParent([], c.PARENT.ARRAY, -1);\n    }\n  }, {\n    key: \"pushArrayStartFixed\",\n    value: function pushArrayStartFixed(len) {\n      this._createArrayStartFixed(len);\n    }\n  }, {\n    key: \"pushArrayStartFixed32\",\n    value: function pushArrayStartFixed32(len1, len2) {\n      var len = utils.buildInt32(len1, len2);\n\n      this._createArrayStartFixed(len);\n    }\n  }, {\n    key: \"pushArrayStartFixed64\",\n    value: function pushArrayStartFixed64(len1, len2, len3, len4) {\n      var len = utils.buildInt64(len1, len2, len3, len4);\n\n      this._createArrayStartFixed(len);\n    }\n  }, {\n    key: \"pushObjectStart\",\n    value: function pushObjectStart() {\n      this._createObjectStartFixed(-1);\n    }\n  }, {\n    key: \"pushObjectStartFixed\",\n    value: function pushObjectStartFixed(len) {\n      this._createObjectStartFixed(len);\n    }\n  }, {\n    key: \"pushObjectStartFixed32\",\n    value: function pushObjectStartFixed32(len1, len2) {\n      var len = utils.buildInt32(len1, len2);\n\n      this._createObjectStartFixed(len);\n    }\n  }, {\n    key: \"pushObjectStartFixed64\",\n    value: function pushObjectStartFixed64(len1, len2, len3, len4) {\n      var len = utils.buildInt64(len1, len2, len3, len4);\n\n      this._createObjectStartFixed(len);\n    }\n  }, {\n    key: \"pushByteStringStart\",\n    value: function pushByteStringStart() {\n      this._parents[this._depth] = {\n        type: c.PARENT.BYTE_STRING,\n        length: -1,\n        ref: [],\n        values: 0,\n        tmpKey: null\n      };\n    }\n  }, {\n    key: \"pushByteString\",\n    value: function pushByteString(start, end) {\n      this._push(this.createByteStringFromHeap(start, end));\n    }\n  }, {\n    key: \"pushUtf8StringStart\",\n    value: function pushUtf8StringStart() {\n      this._parents[this._depth] = {\n        type: c.PARENT.UTF8_STRING,\n        length: -1,\n        ref: [],\n        values: 0,\n        tmpKey: null\n      };\n    }\n  }, {\n    key: \"pushUtf8String\",\n    value: function pushUtf8String(start, end) {\n      this._push(this.createUtf8StringFromHeap(start, end));\n    }\n  }, {\n    key: \"pushSimpleUnassigned\",\n    value: function pushSimpleUnassigned(val) {\n      this._push(this.createSimpleUnassigned(val));\n    }\n  }, {\n    key: \"pushTagStart\",\n    value: function pushTagStart(tag) {\n      this._parents[this._depth] = {\n        type: c.PARENT.TAG,\n        length: 1,\n        ref: [tag]\n      };\n    }\n  }, {\n    key: \"pushTagStart4\",\n    value: function pushTagStart4(f, g) {\n      this.pushTagStart(utils.buildInt32(f, g));\n    }\n  }, {\n    key: \"pushTagStart8\",\n    value: function pushTagStart8(f1, f2, g1, g2) {\n      this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));\n    }\n  }, {\n    key: \"pushTagUnassigned\",\n    value: function pushTagUnassigned(tagNumber) {\n      this._push(this.createTag(tagNumber));\n    }\n  }, {\n    key: \"pushBreak\",\n    value: function pushBreak() {\n      if (this._currentParent.length > -1) {\n        throw new Error('Unexpected break');\n      }\n\n      this._closeParent();\n    }\n  }, {\n    key: \"_createObjectStartFixed\",\n    value: function _createObjectStartFixed(len) {\n      if (len === 0) {\n        this._push(this.createObject({}));\n\n        return;\n      }\n\n      this._createParent({}, c.PARENT.OBJECT, len);\n    }\n  }, {\n    key: \"_createArrayStartFixed\",\n    value: function _createArrayStartFixed(len) {\n      if (len === 0) {\n        this._push(this.createArray([]));\n\n        return;\n      }\n\n      this._createParent(new Array(len), c.PARENT.ARRAY, len);\n    }\n  }, {\n    key: \"_decode\",\n    value: function _decode(input) {\n      if (input.byteLength === 0) {\n        throw new Error('Input too short');\n      }\n\n      this._reset();\n\n      this._heap8.set(input);\n\n      var code = this.parser.parse(input.byteLength);\n\n      if (this._depth > 1) {\n        while (this._currentParent.length === 0) {\n          this._closeParent();\n        }\n\n        if (this._depth > 1) {\n          throw new Error('Undeterminated nesting');\n        }\n      }\n\n      if (code > 0) {\n        throw new Error('Failed to parse');\n      }\n\n      if (this._res.length === 0) {\n        throw new Error('No valid result');\n      }\n    } // -- Public Interface\n\n  }, {\n    key: \"decodeFirst\",\n    value: function decodeFirst(input) {\n      this._decode(input);\n\n      return this._res[0];\n    }\n  }, {\n    key: \"decodeAll\",\n    value: function decodeAll(input) {\n      this._decode(input);\n\n      return this._res;\n    }\n    /**\n     * Decode the first cbor object.\n     *\n     * @param {Buffer|string} input\n     * @param {string} [enc='hex'] - Encoding used if a string is passed.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"_depth\",\n    get: function get() {\n      return this._parents.length;\n    }\n  }, {\n    key: \"_currentParent\",\n    get: function get() {\n      return this._parents[this._depth - 1];\n    }\n  }, {\n    key: \"_ref\",\n    get: function get() {\n      return this._currentParent.ref;\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(input, enc) {\n      if (typeof input === 'string') {\n        input = Buffer.from(input, enc || 'hex');\n      }\n\n      var dec = new Decoder({\n        size: input.length\n      });\n      return dec.decodeFirst(input);\n    }\n    /**\n     * Decode all cbor objects.\n     *\n     * @param {Buffer|string} input\n     * @param {string} [enc='hex'] - Encoding used if a string is passed.\n     * @returns {Array<*>}\n     */\n\n  }, {\n    key: \"decodeAll\",\n    value: function decodeAll(input, enc) {\n      if (typeof input === 'string') {\n        input = Buffer.from(input, enc || 'hex');\n      }\n\n      var dec = new Decoder({\n        size: input.length\n      });\n      return dec.decodeAll(input);\n    }\n  }]);\n\n  return Decoder;\n}();\n\nDecoder.decodeFirst = Decoder.decode;\nmodule.exports = Decoder;","map":null,"metadata":{},"sourceType":"script"}
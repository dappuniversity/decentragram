{"ast":null,"code":"var capability = require('./capability');\n\nvar inherits = require('inherits');\n\nvar stream = require('readable-stream');\n\nvar IncomingMessage = function IncomingMessage(response, mode, fetchTimer) {\n  var _this = this;\n\n  stream.Readable.call(this);\n  this._mode = mode;\n  this.headers = {};\n  this.rawHeaders = [];\n  this.trailers = {};\n  this.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n  this.on('end', function () {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    process.nextTick(function () {\n      return _this.emit('close');\n    });\n  });\n  this._fetchResponse = response;\n  this.url = response.url;\n  this.statusCode = response.status;\n  this.statusMessage = response.statusText;\n  response.headers.forEach(function (header, key) {\n    _this.headers[key.toLowerCase()] = header;\n\n    _this.rawHeaders.push(key, header);\n  });\n\n  if (capability.writableStream) {\n    var writable = new WritableStream({\n      write: function write(chunk) {\n        return new Promise(function (resolve, reject) {\n          if (_this._destroyed) {\n            reject();\n          } else if (_this.push(Buffer.from(chunk))) {\n            resolve();\n          } else {\n            _this._resumeFetch = resolve;\n          }\n        });\n      },\n      close: function close() {\n        clearTimeout(fetchTimer);\n\n        if (!_this._destroyed) {\n          _this.push(null);\n        }\n      },\n      abort: function abort(err) {\n        if (!_this._destroyed) {\n          _this.emit('error', err);\n        }\n      }\n    });\n\n    try {\n      response.body.pipeTo(writable).catch(function (err) {\n        console.log(err);\n        self.clearTimeout(fetchTimer);\n\n        if (!_this._destroyed) {\n          _this.emit('error', err);\n        }\n      });\n      return;\n    } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n  } // fallback for when writableStream or pipeTo aren't available\n\n\n  var reader = response.body.getReader();\n\n  function read(context) {\n    reader.read().then(function (result) {\n      if (context._destroyed) {\n        return;\n      }\n\n      if (result.done) {\n        clearTimeout(fetchTimer);\n        context.push(null);\n        return;\n      }\n\n      context.push(Buffer.from(result.value));\n      read(context);\n    }).catch(function (err) {\n      clearTimeout(fetchTimer);\n\n      if (!context._destroyed) {\n        context.emit('error', err);\n      }\n    });\n  }\n\n  read(this);\n};\n\ninherits(IncomingMessage, stream.Readable);\n\nIncomingMessage.prototype._read = function () {\n  var resolve = this._resumeFetch;\n\n  if (resolve) {\n    this._resumeFetch = null;\n    resolve();\n  }\n};\n\nmodule.exports = IncomingMessage;","map":null,"metadata":{},"sourceType":"script"}
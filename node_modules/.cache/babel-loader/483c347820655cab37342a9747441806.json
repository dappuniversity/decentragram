{"ast":null,"code":"var constants = require('fs-constants');\n\nvar eos = require('end-of-stream');\n\nvar inherits = require('inherits');\n\nvar alloc = Buffer.alloc;\n\nvar Readable = require('readable-stream').Readable;\n\nvar Writable = require('readable-stream').Writable;\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nvar headers = require('./headers');\n\nvar DMODE = parseInt('755', 8);\nvar FMODE = parseInt('644', 8);\nvar END_OF_TAR = alloc(1024);\n\nvar noop = function noop() {};\n\nvar overflow = function overflow(self, size) {\n  size &= 511;\n  if (size) self.push(END_OF_TAR.slice(0, 512 - size));\n};\n\nfunction modeToType(mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK:\n      return 'block-device';\n\n    case constants.S_IFCHR:\n      return 'character-device';\n\n    case constants.S_IFDIR:\n      return 'directory';\n\n    case constants.S_IFIFO:\n      return 'fifo';\n\n    case constants.S_IFLNK:\n      return 'symlink';\n  }\n\n  return 'file';\n}\n\nvar Sink = function Sink(to) {\n  Writable.call(this);\n  this.written = 0;\n  this._to = to;\n  this._destroyed = false;\n};\n\ninherits(Sink, Writable);\n\nSink.prototype._write = function (data, enc, cb) {\n  this.written += data.length;\n  if (this._to.push(data)) return cb();\n  this._to._drain = cb;\n};\n\nSink.prototype.destroy = function () {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.emit('close');\n};\n\nvar LinkSink = function LinkSink() {\n  Writable.call(this);\n  this.linkname = '';\n  this._decoder = new StringDecoder('utf-8');\n  this._destroyed = false;\n};\n\ninherits(LinkSink, Writable);\n\nLinkSink.prototype._write = function (data, enc, cb) {\n  this.linkname += this._decoder.write(data);\n  cb();\n};\n\nLinkSink.prototype.destroy = function () {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.emit('close');\n};\n\nvar Void = function Void() {\n  Writable.call(this);\n  this._destroyed = false;\n};\n\ninherits(Void, Writable);\n\nVoid.prototype._write = function (data, enc, cb) {\n  cb(new Error('No body allowed for this entry'));\n};\n\nVoid.prototype.destroy = function () {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.emit('close');\n};\n\nvar Pack = function Pack(opts) {\n  if (!(this instanceof Pack)) return new Pack(opts);\n  Readable.call(this, opts);\n  this._drain = noop;\n  this._finalized = false;\n  this._finalizing = false;\n  this._destroyed = false;\n  this._stream = null;\n};\n\ninherits(Pack, Readable);\n\nPack.prototype.entry = function (header, buffer, callback) {\n  if (this._stream) throw new Error('already piping an entry');\n  if (this._finalized || this._destroyed) return;\n\n  if (typeof buffer === 'function') {\n    callback = buffer;\n    buffer = null;\n  }\n\n  if (!callback) callback = noop;\n  var self = this;\n  if (!header.size || header.type === 'symlink') header.size = 0;\n  if (!header.type) header.type = modeToType(header.mode);\n  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;\n  if (!header.uid) header.uid = 0;\n  if (!header.gid) header.gid = 0;\n  if (!header.mtime) header.mtime = new Date();\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (Buffer.isBuffer(buffer)) {\n    header.size = buffer.length;\n\n    this._encode(header);\n\n    var ok = this.push(buffer);\n    overflow(self, header.size);\n    if (ok) process.nextTick(callback);else this._drain = callback;\n    return new Void();\n  }\n\n  if (header.type === 'symlink' && !header.linkname) {\n    var linkSink = new LinkSink();\n    eos(linkSink, function (err) {\n      if (err) {\n        // stream was closed\n        self.destroy();\n        return callback(err);\n      }\n\n      header.linkname = linkSink.linkname;\n\n      self._encode(header);\n\n      callback();\n    });\n    return linkSink;\n  }\n\n  this._encode(header);\n\n  if (header.type !== 'file' && header.type !== 'contiguous-file') {\n    process.nextTick(callback);\n    return new Void();\n  }\n\n  var sink = new Sink(this);\n  this._stream = sink;\n  eos(sink, function (err) {\n    self._stream = null;\n\n    if (err) {\n      // stream was closed\n      self.destroy();\n      return callback(err);\n    }\n\n    if (sink.written !== header.size) {\n      // corrupting tar\n      self.destroy();\n      return callback(new Error('size mismatch'));\n    }\n\n    overflow(self, header.size);\n    if (self._finalizing) self.finalize();\n    callback();\n  });\n  return sink;\n};\n\nPack.prototype.finalize = function () {\n  if (this._stream) {\n    this._finalizing = true;\n    return;\n  }\n\n  if (this._finalized) return;\n  this._finalized = true;\n  this.push(END_OF_TAR);\n  this.push(null);\n};\n\nPack.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  if (err) this.emit('error', err);\n  this.emit('close');\n  if (this._stream && this._stream.destroy) this._stream.destroy();\n};\n\nPack.prototype._encode = function (header) {\n  if (!header.pax) {\n    var buf = headers.encode(header);\n\n    if (buf) {\n      this.push(buf);\n      return;\n    }\n  }\n\n  this._encodePax(header);\n};\n\nPack.prototype._encodePax = function (header) {\n  var paxHeader = headers.encodePax({\n    name: header.name,\n    linkname: header.linkname,\n    pax: header.pax\n  });\n  var newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  };\n  this.push(headers.encode(newHeader));\n  this.push(paxHeader);\n  overflow(this, paxHeader.length);\n  newHeader.size = header.size;\n  newHeader.type = header.type;\n  this.push(headers.encode(newHeader));\n};\n\nPack.prototype._read = function (n) {\n  var drain = this._drain;\n  this._drain = noop;\n  drain();\n};\n\nmodule.exports = Pack;","map":null,"metadata":{},"sourceType":"script"}
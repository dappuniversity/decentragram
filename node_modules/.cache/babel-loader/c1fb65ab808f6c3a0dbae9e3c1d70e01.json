{"ast":null,"code":"// BLAKE2s hash function in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\nvar util = require('./util'); // Little-endian byte access.\n// Expects a Uint8Array and an index\n// Returns the little-endian uint32 at v[i..i+3]\n\n\nfunction B2S_GET32(v, i) {\n  return v[i] ^ v[i + 1] << 8 ^ v[i + 2] << 16 ^ v[i + 3] << 24;\n} // Mixing function G.\n\n\nfunction B2S_G(a, b, c, d, x, y) {\n  v[a] = v[a] + v[b] + x;\n  v[d] = ROTR32(v[d] ^ v[a], 16);\n  v[c] = v[c] + v[d];\n  v[b] = ROTR32(v[b] ^ v[c], 12);\n  v[a] = v[a] + v[b] + y;\n  v[d] = ROTR32(v[d] ^ v[a], 8);\n  v[c] = v[c] + v[d];\n  v[b] = ROTR32(v[b] ^ v[c], 7);\n} // 32-bit right rotation\n// x should be a uint32\n// y must be between 1 and 31, inclusive\n\n\nfunction ROTR32(x, y) {\n  return x >>> y ^ x << 32 - y;\n} // Initialization Vector.\n\n\nvar BLAKE2S_IV = new Uint32Array([0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19]);\nvar SIGMA = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]); // Compression function. \"last\" flag indicates last block\n\nvar v = new Uint32Array(16);\nvar m = new Uint32Array(16);\n\nfunction blake2sCompress(ctx, last) {\n  var i = 0;\n\n  for (i = 0; i < 8; i++) {\n    // init work variables\n    v[i] = ctx.h[i];\n    v[i + 8] = BLAKE2S_IV[i];\n  }\n\n  v[12] ^= ctx.t; // low 32 bits of offset\n\n  v[13] ^= ctx.t / 0x100000000; // high 32 bits\n\n  if (last) {\n    // last block flag set ?\n    v[14] = ~v[14];\n  }\n\n  for (i = 0; i < 16; i++) {\n    // get little-endian words\n    m[i] = B2S_GET32(ctx.b, 4 * i);\n  } // ten rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 32)\n\n\n  for (i = 0; i < 10; i++) {\n    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)\n    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);\n    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);\n    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);\n    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);\n    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);\n    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);\n    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);\n    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);\n  } // util.debugPrint('   (i=10) v[16]', v, 32)\n\n\n  for (i = 0; i < 8; i++) {\n    ctx.h[i] ^= v[i] ^ v[i + 8];\n  } // util.debugPrint('h[8]', ctx.h, 32)\n\n} // Creates a BLAKE2s hashing context\n// Requires an output length between 1 and 32 bytes\n// Takes an optional Uint8Array key\n\n\nfunction blake2sInit(outlen, key) {\n  if (!(outlen > 0 && outlen <= 32)) {\n    throw new Error('Incorrect output length, should be in [1, 32]');\n  }\n\n  var keylen = key ? key.length : 0;\n\n  if (key && !(keylen > 0 && keylen <= 32)) {\n    throw new Error('Incorrect key length, should be in [1, 32]');\n  }\n\n  var ctx = {\n    h: new Uint32Array(BLAKE2S_IV),\n    // hash state\n    b: new Uint32Array(64),\n    // input block\n    c: 0,\n    // pointer within block\n    t: 0,\n    // input count\n    outlen: outlen // output length in bytes\n\n  };\n  ctx.h[0] ^= 0x01010000 ^ keylen << 8 ^ outlen;\n\n  if (keylen > 0) {\n    blake2sUpdate(ctx, key);\n    ctx.c = 64; // at the end\n  }\n\n  return ctx;\n} // Updates a BLAKE2s streaming hash\n// Requires hash context and Uint8Array (byte array)\n\n\nfunction blake2sUpdate(ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 64) {\n      // buffer full ?\n      ctx.t += ctx.c; // add counters\n\n      blake2sCompress(ctx, false); // compress (not last)\n\n      ctx.c = 0; // counter to zero\n    }\n\n    ctx.b[ctx.c++] = input[i];\n  }\n} // Completes a BLAKE2s streaming hash\n// Returns a Uint8Array containing the message digest\n\n\nfunction blake2sFinal(ctx) {\n  ctx.t += ctx.c; // mark last block offset\n\n  while (ctx.c < 64) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0;\n  }\n\n  blake2sCompress(ctx, true); // final block flag = 1\n  // little endian convert and store\n\n  var out = new Uint8Array(ctx.outlen);\n\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 0xFF;\n  }\n\n  return out;\n} // Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\n\n\nfunction blake2s(input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 32;\n  input = util.normalizeInput(input); // do the math\n\n  var ctx = blake2sInit(outlen, key);\n  blake2sUpdate(ctx, input);\n  return blake2sFinal(ctx);\n} // Computes the BLAKE2S hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\n\n\nfunction blake2sHex(input, key, outlen) {\n  var output = blake2s(input, key, outlen);\n  return util.toHex(output);\n}\n\nmodule.exports = {\n  blake2s: blake2s,\n  blake2sHex: blake2sHex,\n  blake2sInit: blake2sInit,\n  blake2sUpdate: blake2sUpdate,\n  blake2sFinal: blake2sFinal\n};","map":null,"metadata":{},"sourceType":"script"}
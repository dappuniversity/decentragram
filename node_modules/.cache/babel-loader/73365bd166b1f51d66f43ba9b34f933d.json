{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _inherits = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Decoder = require('./decoder');\n\nvar utils = require('./utils');\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\n\n\nvar Diagnose =\n/*#__PURE__*/\nfunction (_Decoder) {\n  _inherits(Diagnose, _Decoder);\n\n  function Diagnose() {\n    _classCallCheck(this, Diagnose);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Diagnose).apply(this, arguments));\n  }\n\n  _createClass(Diagnose, [{\n    key: \"createTag\",\n    value: function createTag(tagNumber, value) {\n      return \"\".concat(tagNumber, \"(\").concat(value, \")\");\n    }\n  }, {\n    key: \"createInt\",\n    value: function createInt(val) {\n      return _get(_getPrototypeOf(Diagnose.prototype), \"createInt\", this).call(this, val).toString();\n    }\n  }, {\n    key: \"createInt32\",\n    value: function createInt32(f, g) {\n      return _get(_getPrototypeOf(Diagnose.prototype), \"createInt32\", this).call(this, f, g).toString();\n    }\n  }, {\n    key: \"createInt64\",\n    value: function createInt64(f1, f2, g1, g2) {\n      return _get(_getPrototypeOf(Diagnose.prototype), \"createInt64\", this).call(this, f1, f2, g1, g2).toString();\n    }\n  }, {\n    key: \"createInt32Neg\",\n    value: function createInt32Neg(f, g) {\n      return _get(_getPrototypeOf(Diagnose.prototype), \"createInt32Neg\", this).call(this, f, g).toString();\n    }\n  }, {\n    key: \"createInt64Neg\",\n    value: function createInt64Neg(f1, f2, g1, g2) {\n      return _get(_getPrototypeOf(Diagnose.prototype), \"createInt64Neg\", this).call(this, f1, f2, g1, g2).toString();\n    }\n  }, {\n    key: \"createTrue\",\n    value: function createTrue() {\n      return 'true';\n    }\n  }, {\n    key: \"createFalse\",\n    value: function createFalse() {\n      return 'false';\n    }\n  }, {\n    key: \"createFloat\",\n    value: function createFloat(val) {\n      var fl = _get(_getPrototypeOf(Diagnose.prototype), \"createFloat\", this).call(this, val);\n\n      if (utils.isNegativeZero(val)) {\n        return '-0_1';\n      }\n\n      return \"\".concat(fl, \"_1\");\n    }\n  }, {\n    key: \"createFloatSingle\",\n    value: function createFloatSingle(a, b, c, d) {\n      var fl = _get(_getPrototypeOf(Diagnose.prototype), \"createFloatSingle\", this).call(this, a, b, c, d);\n\n      return \"\".concat(fl, \"_2\");\n    }\n  }, {\n    key: \"createFloatDouble\",\n    value: function createFloatDouble(a, b, c, d, e, f, g, h) {\n      var fl = _get(_getPrototypeOf(Diagnose.prototype), \"createFloatDouble\", this).call(this, a, b, c, d, e, f, g, h);\n\n      return \"\".concat(fl, \"_3\");\n    }\n  }, {\n    key: \"createByteString\",\n    value: function createByteString(raw, len) {\n      var val = raw.join(', ');\n\n      if (len === -1) {\n        return \"(_ \".concat(val, \")\");\n      }\n\n      return \"h'\".concat(val);\n    }\n  }, {\n    key: \"createByteStringFromHeap\",\n    value: function createByteStringFromHeap(start, end) {\n      var val = Buffer.from(_get(_getPrototypeOf(Diagnose.prototype), \"createByteStringFromHeap\", this).call(this, start, end)).toString('hex');\n      return \"h'\".concat(val, \"'\");\n    }\n  }, {\n    key: \"createInfinity\",\n    value: function createInfinity() {\n      return 'Infinity_1';\n    }\n  }, {\n    key: \"createInfinityNeg\",\n    value: function createInfinityNeg() {\n      return '-Infinity_1';\n    }\n  }, {\n    key: \"createNaN\",\n    value: function createNaN() {\n      return 'NaN_1';\n    }\n  }, {\n    key: \"createNaNNeg\",\n    value: function createNaNNeg() {\n      return '-NaN_1';\n    }\n  }, {\n    key: \"createNull\",\n    value: function createNull() {\n      return 'null';\n    }\n  }, {\n    key: \"createUndefined\",\n    value: function createUndefined() {\n      return 'undefined';\n    }\n  }, {\n    key: \"createSimpleUnassigned\",\n    value: function createSimpleUnassigned(val) {\n      return \"simple(\".concat(val, \")\");\n    }\n  }, {\n    key: \"createArray\",\n    value: function createArray(arr, len) {\n      var val = _get(_getPrototypeOf(Diagnose.prototype), \"createArray\", this).call(this, arr, len);\n\n      if (len === -1) {\n        // indefinite\n        return \"[_ \".concat(val.join(', '), \"]\");\n      }\n\n      return \"[\".concat(val.join(', '), \"]\");\n    }\n  }, {\n    key: \"createMap\",\n    value: function createMap(map, len) {\n      var val = _get(_getPrototypeOf(Diagnose.prototype), \"createMap\", this).call(this, map);\n\n      var list = Array.from(val.keys()).reduce(collectObject(val), '');\n\n      if (len === -1) {\n        return \"{_ \".concat(list, \"}\");\n      }\n\n      return \"{\".concat(list, \"}\");\n    }\n  }, {\n    key: \"createObject\",\n    value: function createObject(obj, len) {\n      var val = _get(_getPrototypeOf(Diagnose.prototype), \"createObject\", this).call(this, obj);\n\n      var map = Object.keys(val).reduce(collectObject(val), '');\n\n      if (len === -1) {\n        return \"{_ \".concat(map, \"}\");\n      }\n\n      return \"{\".concat(map, \"}\");\n    }\n  }, {\n    key: \"createUtf8String\",\n    value: function createUtf8String(raw, len) {\n      var val = raw.join(', ');\n\n      if (len === -1) {\n        return \"(_ \".concat(val, \")\");\n      }\n\n      return \"\\\"\".concat(val, \"\\\"\");\n    }\n  }, {\n    key: \"createUtf8StringFromHeap\",\n    value: function createUtf8StringFromHeap(start, end) {\n      var val = Buffer.from(_get(_getPrototypeOf(Diagnose.prototype), \"createUtf8StringFromHeap\", this).call(this, start, end)).toString('utf8');\n      return \"\\\"\".concat(val, \"\\\"\");\n    }\n  }], [{\n    key: \"diagnose\",\n    value: function diagnose(input, enc) {\n      if (typeof input === 'string') {\n        input = Buffer.from(input, enc || 'hex');\n      }\n\n      var dec = new Diagnose();\n      return dec.decodeFirst(input);\n    }\n  }]);\n\n  return Diagnose;\n}(Decoder);\n\nmodule.exports = Diagnose;\n\nfunction collectObject(val) {\n  return function (acc, key) {\n    if (acc) {\n      return \"\".concat(acc, \", \").concat(key, \": \").concat(val[key]);\n    }\n\n    return \"\".concat(key, \": \").concat(val[key]);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar multihash = require('multihashes');\n\nvar crypto = require('./crypto');\n\nmodule.exports = Multihashing;\n/**\n * Hash the given `buf` using the algorithm specified\n * by `func`.\n *\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\n\nfunction Multihashing(buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  Multihashing.digest(buf, func, length, function (err, digest) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, multihash.encode(digest, func, length));\n  });\n}\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\n\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\nMultihashing.multihash = multihash;\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\n\nMultihashing.digest = function (buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  var cb = callback;\n\n  if (length) {\n    cb = function cb(err, digest) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, digest.slice(0, length));\n    };\n  }\n\n  var hash;\n\n  try {\n    hash = Multihashing.createHash(func);\n  } catch (err) {\n    return cb(err);\n  }\n\n  hash(buf, cb);\n};\n/**\n * @param {string|number} func\n *\n * @returns {function} - The to `func` corresponding hash function.\n */\n\n\nMultihashing.createHash = function (func) {\n  func = multihash.coerceCode(func);\n\n  if (!Multihashing.functions[func]) {\n    throw new Error('multihash function ' + func + ' not yet supported');\n  }\n\n  return Multihashing.functions[func];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\n\n\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256 // add blake functions\n\n};\ncrypto.addBlake(Multihashing.functions);","map":null,"metadata":{},"sourceType":"script"}
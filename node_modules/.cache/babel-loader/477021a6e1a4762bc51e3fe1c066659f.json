{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar Transform = require('readable-stream').Transform;\n\nvar isNode = require('detect-node');\n\nvar PADDING = '--';\nvar NEW_LINE = '\\r\\n';\nvar NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\n\nvar Multipart =\n/*#__PURE__*/\nfunction (_Transform) {\n  _inherits(Multipart, _Transform);\n\n  function Multipart(options) {\n    var _this;\n\n    _classCallCheck(this, Multipart);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Multipart).call(this, Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    })));\n    _this._boundary = _this._generateBoundary();\n    _this._files = [];\n    _this._draining = false;\n    return _this;\n  }\n\n  _createClass(Multipart, [{\n    key: \"_flush\",\n    value: function _flush() {\n      this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n      this.push(null);\n    }\n  }, {\n    key: \"_generateBoundary\",\n    value: function _generateBoundary() {\n      var boundary = '--------------------------';\n\n      for (var i = 0; i < 24; i++) {\n        boundary += Math.floor(Math.random() * 10).toString(16);\n      }\n\n      return boundary;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(file, encoding, callback) {\n      if (Buffer.isBuffer(file)) {\n        this.push(file);\n        return callback(); // early\n      } // not a buffer, must be a file\n\n\n      this._files.push(file);\n\n      this._maybeDrain(callback);\n    }\n  }, {\n    key: \"_maybeDrain\",\n    value: function _maybeDrain(callback) {\n      var _this2 = this;\n\n      if (!this._draining) {\n        if (this._files.length) {\n          this._draining = true;\n\n          var file = this._files.shift();\n\n          this._pushFile(file, function (err) {\n            _this2._draining = false;\n\n            if (err) {\n              _this2.emit('error', err);\n            } else {\n              _this2._maybeDrain(callback);\n            }\n          });\n        } else {\n          this.emit('drained all files');\n          callback();\n        }\n      } else {\n        this.once('drained all files', callback);\n      }\n    }\n  }, {\n    key: \"_pushFile\",\n    value: function _pushFile(file, callback) {\n      var _this3 = this;\n\n      var leading = this._leading(file.headers || {});\n\n      this.push(leading);\n      var content = file.content || Buffer.alloc(0);\n\n      if (Buffer.isBuffer(content)) {\n        this.push(content);\n        this.push(NEW_LINE_BUFFER);\n        return callback(); // early\n      } // From now on we assume content is a stream\n\n\n      content.once('error', this.emit.bind(this, 'error'));\n      content.once('end', function () {\n        _this3.push(NEW_LINE_BUFFER);\n\n        callback(); // TODO: backpressure!!! wait once self is drained so we can proceed\n        // This does not work\n        // this.once('drain', () => {\n        //   callback()\n        // })\n      });\n      content.on('data', function (data) {\n        var drained = _this3.push(data); // Only do the drain dance on Node.js.\n        // In browserland, the underlying stream\n        // does NOT drain because the request is only sent\n        // once this stream ends.\n\n\n        if (!drained && isNode) {\n          content.pause();\n\n          _this3.once('drain', function () {\n            return content.resume();\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_leading\",\n    value: function _leading(headers) {\n      var leading = [PADDING + this._boundary];\n      Object.keys(headers).forEach(function (header) {\n        leading.push(header + ': ' + headers[header]);\n      });\n      leading.push('');\n      leading.push('');\n      var leadingStr = leading.join(NEW_LINE);\n      return Buffer.from(leadingStr);\n    }\n  }]);\n\n  return Multipart;\n}(Transform);\n\nmodule.exports = Multipart;","map":null,"metadata":{},"sourceType":"script"}
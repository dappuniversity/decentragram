{"ast":null,"code":"/* eslint max-depth: 1 */\n'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar varint = require('varint');\n\nvar defined = require('./utils').defined;\n\nfunction toSentenceCase(string) {\n  return \"\".concat(string.substring(0, 1).toUpperCase()).concat(string.substring(1));\n}\n\nfunction addPropertyAccessors(obj, name, _value, defaultValue) {\n  var _Object$definePropert;\n\n  if (Object.prototype.hasOwnProperty.call(obj, name)) {\n    // have already added this property\n    return;\n  }\n\n  var sentenceCaseName = toSentenceCase(name);\n  Object.defineProperties(obj, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, name, {\n    enumerable: true,\n    configurable: true,\n    set: function set(val) {\n      _value = val;\n    },\n    get: function get() {\n      if (_value === undefined) {\n        return defaultValue;\n      }\n\n      return _value;\n    }\n  }), _defineProperty(_Object$definePropert, \"has\".concat(sentenceCaseName), {\n    configurable: true,\n    value: function value() {\n      return _value !== undefined;\n    }\n  }), _defineProperty(_Object$definePropert, \"set\".concat(sentenceCaseName), {\n    configurable: true,\n    value: function value(val) {\n      _value = val;\n    }\n  }), _defineProperty(_Object$definePropert, \"get\".concat(sentenceCaseName), {\n    configurable: true,\n    value: function value() {\n      return _value;\n    }\n  }), _defineProperty(_Object$definePropert, \"clear\".concat(sentenceCaseName), {\n    configurable: true,\n    value: function value() {\n      _value = undefined;\n      obj[name] = undefined;\n    }\n  }), _Object$definePropert));\n}\n\nfunction compileDecode(m, resolve, enc) {\n  var requiredFields = [];\n  var fields = {};\n  var oneofFields = [];\n  var vals = [];\n\n  for (var i = 0; i < enc.length; i++) {\n    var field = m.fields[i];\n    fields[field.tag] = i;\n    var def = field.options && field.options.default;\n    var resolved = resolve(field.type, m.id, false);\n    vals[i] = [def, resolved && resolved.values];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n\n    if (field.required) {\n      requiredFields.push(field.name);\n    }\n\n    if (field.oneof) {\n      oneofFields.push(field.name);\n    }\n  }\n\n  function decodeField(e, field, obj, buf, offset, i) {\n    var name = field.name;\n\n    if (field.oneof) {\n      // clear already defined oneof fields\n      var props = Object.keys(obj);\n\n      for (var j = 0; j < props.length; j++) {\n        if (oneofFields.indexOf(props[j]) > -1) {\n          var sentenceCase = toSentenceCase(props[j]);\n          delete obj[\"has\".concat(sentenceCase)];\n          delete obj[\"get\".concat(sentenceCase)];\n          delete obj[\"set\".concat(sentenceCase)];\n          delete obj[\"clear\".concat(sentenceCase)];\n          delete obj[props[j]];\n        }\n      }\n    }\n\n    var value;\n\n    if (e.message) {\n      var len = varint.decode(buf, offset);\n      offset += varint.decode.bytes;\n      var decoded = e.decode(buf, offset, offset + len);\n\n      if (field.map) {\n        value = obj[name] || {};\n        value[decoded.key] = decoded.value;\n      } else if (field.repeated) {\n        value = obj[name] || [];\n        value.push(decoded);\n      } else {\n        value = decoded;\n      }\n    } else {\n      if (field.repeated) {\n        value = obj[name] || [];\n        value.push(e.decode(buf, offset));\n      } else {\n        value = e.decode(buf, offset);\n      }\n    }\n\n    addPropertyAccessors(obj, name, value);\n    offset += e.decode.bytes;\n    return offset;\n  }\n\n  return function decode(buf, offset, end) {\n    if (offset == null) {\n      offset = 0;\n    }\n\n    if (end == null) {\n      end = buf.length;\n    }\n\n    if (!(end <= buf.length && offset <= buf.length)) {\n      throw new Error('Decoded message is not valid');\n    }\n\n    var oldOffset = offset;\n    var obj = {};\n    var field;\n\n    while (true) {\n      if (end <= offset) {\n        // finished\n        // check required methods\n        var name = '';\n        var j = 0;\n\n        for (j = 0; j < requiredFields.length; j++) {\n          name = requiredFields[j];\n\n          if (!defined(obj[name])) {\n            throw new Error('Decoded message is not valid, missing required field: ' + name);\n          }\n        } // fill out missing defaults\n\n\n        var val;\n        var def;\n\n        for (j = 0; j < enc.length; j++) {\n          field = m.fields[j];\n          def = vals[j][0];\n          val = vals[j][1];\n          name = field.name;\n          var defaultVal = void 0;\n\n          if (Object.prototype.hasOwnProperty.call(obj, name)) {\n            continue;\n          }\n\n          var done = false;\n\n          if (field.oneof) {\n            var props = Object.keys(obj);\n\n            for (var k = 0; k < props.length; k++) {\n              if (oneofFields.indexOf(props[k]) > -1) {\n                done = true;\n                break;\n              }\n            }\n          }\n\n          if (done) {\n            continue;\n          }\n\n          if (val) {\n            // is enum\n            if (field.repeated) {\n              def = [];\n            } else {\n              def = def && val[def] ? val[def].value : val[Object.keys(val)[0]].value;\n              def = parseInt(def || 0, 10);\n            }\n          } else {\n            defaultVal = defaultValue(field);\n            def = coerceValue(field, def);\n          }\n\n          addPropertyAccessors(obj, name, def, defaultVal);\n        }\n\n        decode.bytes = offset - oldOffset;\n        return obj;\n      }\n\n      var prefix = varint.decode(buf, offset);\n      offset += varint.decode.bytes;\n      var tag = prefix >> 3;\n      var i = fields[tag];\n\n      if (i == null) {\n        offset = skip(prefix & 7, buf, offset);\n        continue;\n      }\n\n      var e = enc[i];\n      field = m.fields[i];\n\n      if (field.packed) {\n        var packedEnd = varint.decode(buf, offset);\n        offset += varint.decode.bytes;\n        packedEnd += offset;\n\n        while (offset < packedEnd) {\n          offset = decodeField(e, field, obj, buf, offset, i);\n        }\n      } else {\n        offset = decodeField(e, field, obj, buf, offset, i);\n      }\n    }\n  };\n}\n\nvar skip = function skip(type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset);\n      return offset + varint.decode.bytes;\n\n    case 1:\n      return offset + 8;\n\n    case 2:\n      var len = varint.decode(buffer, offset);\n      return offset + varint.decode.bytes + len;\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported');\n\n    case 5:\n      return offset + 4;\n\n    default:\n      throw new Error('Unknown wire type: ' + type);\n  }\n};\n\nvar defaultValue = function defaultValue(f) {\n  if (f.map) return {};\n  if (f.repeated) return [];\n\n  switch (f.type) {\n    case 'string':\n      return '';\n\n    case 'bool':\n      return false;\n\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return 0;\n\n    default:\n      return null;\n  }\n};\n\nvar coerceValue = function coerceValue(f, def) {\n  if (def === undefined) {\n    return def;\n  }\n\n  switch (f.type) {\n    case 'bool':\n      return def === 'true';\n\n    case 'float':\n    case 'double':\n    case 'sfixed32':\n    case 'fixed32':\n    case 'varint':\n    case 'enum':\n    case 'uint64':\n    case 'uint32':\n    case 'int64':\n    case 'int32':\n    case 'sint64':\n    case 'sint32':\n      return parseInt(def, 10);\n\n    default:\n      return def;\n  }\n};\n\nmodule.exports = compileDecode;","map":null,"metadata":{},"sourceType":"script"}
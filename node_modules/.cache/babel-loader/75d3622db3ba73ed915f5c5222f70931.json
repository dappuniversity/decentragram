{"ast":null,"code":"'use strict';\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nmodule.exports = function base64(alphabet) {\n  // The alphabet is only used to know:\n  //   1. If padding is enabled (must contain '=')\n  //   2. If the output must be url-safe (must contain '-' and '_')\n  //   3. If the input of the output function is valid\n  // The alphabets from RFC 4648 are always used.\n  var padding = alphabet.indexOf('=') > -1;\n  var url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1;\n  return {\n    encode: function encode(input) {\n      var output = '';\n\n      if (typeof input === 'string') {\n        output = Buffer.from(input).toString('base64');\n      } else {\n        output = input.toString('base64');\n      }\n\n      if (url) {\n        output = output.replace(/\\+/g, '-').replace(/\\//g, '_');\n      }\n\n      var pad = output.indexOf('=');\n\n      if (pad > 0 && !padding) {\n        output = output.substring(0, pad);\n      }\n\n      return output;\n    },\n    decode: function decode(input) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var char = _step.value;\n\n          if (alphabet.indexOf(char) < 0) {\n            throw new Error('invalid base64 character');\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return Buffer.from(input, 'base64');\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}
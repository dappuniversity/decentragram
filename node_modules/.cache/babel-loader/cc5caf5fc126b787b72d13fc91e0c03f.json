{"ast":null,"code":"'use strict';\n/* global self */\n\nvar isIPFS = require('is-ipfs');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar CID = require('cids');\n\nvar multiaddr = require('multiaddr');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar multihash = require('multihashes');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar loadCommands = require('./utils/load-commands');\n\nvar getConfig = require('./utils/default-config');\n\nvar sendRequest = require('./utils/send-request');\n\nfunction ipfsClient(hostOrMultiaddr, port, userOptions) {\n  // convert all three params to objects that we can merge.\n  var options = {};\n\n  if (!hostOrMultiaddr) {\n    // autoconfigure host and port in browser\n    if (typeof self !== 'undefined') {\n      options = urlToOptions(self.location);\n    }\n  } else if (multiaddr.isMultiaddr(hostOrMultiaddr)) {\n    options = maToOptions(hostOrMultiaddr);\n  } else if (typeof hostOrMultiaddr === 'object') {\n    options = hostOrMultiaddr;\n  } else if (typeof hostOrMultiaddr === 'string') {\n    if (hostOrMultiaddr[0] === '/') {\n      // throws if multiaddr is malformed or can't be converted to a nodeAddress\n      options = maToOptions(multiaddr(hostOrMultiaddr));\n    } else {\n      // hostOrMultiaddr is domain or ip address as a string\n      options.host = hostOrMultiaddr;\n    }\n  }\n\n  if (port && typeof port !== 'object') {\n    port = {\n      port: port\n    };\n  }\n\n  var config = Object.assign(getConfig(), options, port, userOptions);\n  var requestAPI = sendRequest(config);\n  var cmds = loadCommands(requestAPI, config);\n  cmds.send = requestAPI;\n  return cmds;\n}\n\nfunction maToOptions(multiaddr) {\n  // ma.nodeAddress() throws if multiaddr can't be converted to a nodeAddress\n  var nodeAddr = multiaddr.nodeAddress();\n  var protos = multiaddr.protos(); // only http and https are allowed as protocol,\n  // anything else will be replaced with http\n\n  var exitProtocol = protos[protos.length - 1].name;\n  return {\n    host: nodeAddr.address,\n    port: nodeAddr.port,\n    protocol: exitProtocol.startsWith('http') ? exitProtocol : 'http'\n  };\n}\n\nfunction urlToOptions(url) {\n  return {\n    host: url.hostname,\n    port: url.port || (url.protocol.startsWith('https') ? 443 : 80),\n    protocol: url.protocol.startsWith('http') ? url.protocol.split(':')[0] : 'http'\n  };\n}\n\nmodule.exports = ipfsClient;\nObject.assign(module.exports, {\n  isIPFS: isIPFS,\n  Buffer: Buffer,\n  CID: CID,\n  multiaddr: multiaddr,\n  multibase: multibase,\n  multicodec: multicodec,\n  multihash: multihash,\n  PeerId: PeerId,\n  PeerInfo: PeerInfo\n});","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar EventEmitter = require('events');\n\nvar eos = require('end-of-stream');\n\nvar isNode = require('detect-node');\n\nvar setImmediate = require('async/setImmediate');\n\nvar PubsubMessageStream = require('./utils/pubsub-message-stream');\n\nvar stringlistToArray = require('./utils/stringlist-to-array');\n\nvar moduleConfig = require('./utils/module-config');\n\nvar NotSupportedError = function NotSupportedError() {\n  return new Error('pubsub is currently not supported when run in the browser');\n};\n/* Public API */\n\n\nmodule.exports = function (arg) {\n  var send = moduleConfig(arg);\n  /* Internal subscriptions state and functions */\n\n  var ps = new EventEmitter();\n  var subscriptions = {};\n  ps.id = Math.random();\n  return {\n    subscribe: function subscribe(topic, handler, options, callback) {\n      var defaultOptions = {\n        discover: false\n      };\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = defaultOptions;\n      }\n\n      if (!options) {\n        options = defaultOptions;\n      } // Throw an error if ran in the browsers\n\n\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(function () {\n          return callback(NotSupportedError());\n        });\n      } // promisify doesn't work as we always pass a\n      // function as last argument (`handler`)\n\n\n      if (!callback) {\n        return new Promise(function (resolve, reject) {\n          _subscribe(topic, handler, options, function (err) {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      }\n\n      _subscribe(topic, handler, options, callback);\n    },\n    unsubscribe: function unsubscribe(topic, handler, callback) {\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(function () {\n          return callback(NotSupportedError());\n        });\n      }\n\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\n        var err = new Error(\"Not subscribed to '\".concat(topic, \"'\"));\n\n        if (!callback) {\n          return Promise.reject(err);\n        }\n\n        return setImmediate(function () {\n          return callback(err);\n        });\n      }\n\n      if (!handler && !callback) {\n        ps.removeAllListeners(topic);\n      } else {\n        ps.removeListener(topic, handler);\n      } // Drop the request once we are actually done\n\n\n      if (ps.listenerCount(topic) === 0) {\n        if (!callback) {\n          return new Promise(function (resolve, reject) {\n            // When the response stream has ended, resolve the promise\n            eos(subscriptions[topic].res, function (err) {\n              // FIXME: Artificial timeout needed to ensure unsubscribed\n              setTimeout(function () {\n                if (err) return reject(err);\n                resolve();\n              });\n            });\n            subscriptions[topic].req.abort();\n            subscriptions[topic] = null;\n          });\n        } // When the response stream has ended, call the callback\n\n\n        eos(subscriptions[topic].res, function (err) {\n          // FIXME: Artificial timeout needed to ensure unsubscribed\n          setTimeout(function () {\n            return callback(err);\n          });\n        });\n        subscriptions[topic].req.abort();\n        subscriptions[topic] = null;\n        return;\n      }\n\n      if (!callback) {\n        return Promise.resolve();\n      }\n\n      setImmediate(function () {\n        return callback();\n      });\n    },\n    publish: promisify(function (topic, data, callback) {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      if (!Buffer.isBuffer(data)) {\n        return callback(new Error('data must be a Buffer'));\n      }\n\n      var request = {\n        path: 'pubsub/pub',\n        args: [topic, data]\n      };\n      send(request, callback);\n    }),\n    ls: promisify(function (callback) {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      var request = {\n        path: 'pubsub/ls'\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n    peers: promisify(function (topic, callback) {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      var request = {\n        path: 'pubsub/peers',\n        args: [topic]\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n    setMaxListeners: function setMaxListeners(n) {\n      return ps.setMaxListeners(n);\n    }\n  };\n\n  function _subscribe(topic, handler, options, callback) {\n    ps.on(topic, handler);\n\n    if (subscriptions[topic]) {\n      // TODO: should a callback error be returned?\n      return callback();\n    } // Request params\n\n\n    var request = {\n      path: 'pubsub/sub',\n      args: [topic],\n      qs: {\n        discover: options.discover\n      } // Start the request and transform the response\n      // stream to Pubsub messages stream\n\n    };\n    subscriptions[topic] = {};\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, function (err, stream) {\n      if (err) {\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n        return callback(err);\n      }\n\n      subscriptions[topic].res = stream;\n      stream.on('data', function (msg) {\n        ps.emit(topic, msg);\n      });\n      stream.on('error', function (err) {\n        ps.emit('error', err);\n      });\n      eos(stream, function (err) {\n        if (err) {\n          ps.emit('error', err);\n        }\n\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n      });\n      callback();\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}
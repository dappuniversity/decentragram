{"ast":null,"code":"var tokenize = require('./tokenize');\n\nvar MAX_RANGE = 0x1FFFFFFF; // \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared \"packed\".\"\n// https://developers.google.com/protocol-buffers/docs/encoding#optional\n\nvar PACKABLE_TYPES = [// varint wire types\n'int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'bool', // + ENUMS\n// 64-bit wire types\n'fixed64', 'sfixed64', 'double', // 32-bit wire types\n'fixed32', 'sfixed32', 'float'];\n\nvar onfieldoptions = function onfieldoptions(tokens) {\n  var opts = {};\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '[':\n      case ',':\n        tokens.shift();\n        var name = tokens.shift();\n\n        if (name === '(') {\n          // handling [(A) = B]\n          name = tokens.shift();\n          tokens.shift(); // remove the end of bracket\n        }\n\n        if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0]);\n        tokens.shift();\n        if (tokens[0] === ']') throw new Error('Unexpected ] in field option');\n        opts[name] = tokens.shift();\n        break;\n\n      case ']':\n        tokens.shift();\n        return opts;\n\n      default:\n        throw new Error('Unexpected token in field options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for field options');\n};\n\nvar onfield = function onfield(tokens) {\n  var field = {\n    name: null,\n    type: null,\n    tag: -1,\n    map: null,\n    oneof: null,\n    required: false,\n    repeated: false,\n    options: {}\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case '=':\n        tokens.shift();\n        field.tag = Number(tokens.shift());\n        break;\n\n      case 'map':\n        field.type = 'map';\n        field.map = {\n          from: null,\n          to: null\n        };\n        tokens.shift();\n        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.from = tokens.shift();\n        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.map.to = tokens.shift();\n        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0]);\n        tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case 'repeated':\n      case 'required':\n      case 'optional':\n        var t = tokens.shift();\n        field.required = t === 'required';\n        field.repeated = t === 'repeated';\n        field.type = tokens.shift();\n        field.name = tokens.shift();\n        break;\n\n      case '[':\n        field.options = onfieldoptions(tokens);\n        break;\n\n      case ';':\n        if (field.name === null) throw new Error('Missing field name');\n        if (field.type === null) throw new Error('Missing type in message field: ' + field.name);\n        if (field.tag === -1) throw new Error('Missing tag number in message field: ' + field.name);\n        tokens.shift();\n        return field;\n\n      default:\n        throw new Error('Unexpected token in message field: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No ; found for message field');\n};\n\nvar onmessagebody = function onmessagebody(tokens) {\n  var body = {\n    enums: [],\n    options: {},\n    messages: [],\n    fields: [],\n    extends: [],\n    extensions: null\n  };\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'map':\n      case 'repeated':\n      case 'optional':\n      case 'required':\n        body.fields.push(onfield(tokens));\n        break;\n\n      case 'enum':\n        body.enums.push(onenum(tokens));\n        break;\n\n      case 'message':\n        body.messages.push(onmessage(tokens));\n        break;\n\n      case 'extensions':\n        body.extensions = onextensions(tokens);\n        break;\n\n      case 'oneof':\n        tokens.shift();\n        var name = tokens.shift();\n        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0]);\n        tokens.shift();\n\n        while (tokens[0] !== '}') {\n          tokens.unshift('optional');\n          var field = onfield(tokens);\n          field.oneof = name;\n          body.fields.push(field);\n        }\n\n        tokens.shift();\n        break;\n\n      case 'extend':\n        body.extends.push(onextend(tokens));\n        break;\n\n      case ';':\n        tokens.shift();\n        break;\n\n      case 'reserved':\n        tokens.shift();\n\n        while (tokens[0] !== ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (body.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        body.options[opt.name] = opt.value;\n        break;\n\n      default:\n        // proto3 does not require the use of optional/required, assumed as optional\n        // \"singular: a well-formed message can have zero or one of this field (but not more than one).\"\n        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules\n        tokens.unshift('optional');\n        body.fields.push(onfield(tokens));\n    }\n  }\n\n  return body;\n};\n\nvar onextend = function onextend(tokens) {\n  var out = {\n    name: tokens[1],\n    message: onmessage(tokens)\n  };\n  return out;\n};\n\nvar onextensions = function onextensions(tokens) {\n  tokens.shift();\n  var from = Number(tokens.shift());\n  if (isNaN(from)) throw new Error('Invalid from in extensions definition');\n  if (tokens.shift() !== 'to') throw new Error(\"Expected keyword 'to' in extensions definition\");\n  var to = tokens.shift();\n  if (to === 'max') to = MAX_RANGE;\n  to = Number(to);\n  if (isNaN(to)) throw new Error('Invalid to in extensions definition');\n  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition');\n  return {\n    from: from,\n    to: to\n  };\n};\n\nvar onmessage = function onmessage(tokens) {\n  tokens.shift();\n  var lvl = 1;\n  var body = [];\n  var msg = {\n    name: tokens.shift(),\n    options: {},\n    enums: [],\n    extends: [],\n    messages: [],\n    fields: []\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '{') lvl++;else if (tokens[0] === '}') lvl--;\n\n    if (!lvl) {\n      tokens.shift();\n      body = onmessagebody(body);\n      msg.enums = body.enums;\n      msg.messages = body.messages;\n      msg.fields = body.fields;\n      msg.extends = body.extends;\n      msg.extensions = body.extensions;\n      msg.options = body.options;\n      return msg;\n    }\n\n    body.push(tokens.shift());\n  }\n\n  if (lvl) throw new Error('No closing tag for message');\n};\n\nvar onpackagename = function onpackagename(tokens) {\n  tokens.shift();\n  var name = tokens.shift();\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return name;\n};\n\nvar onsyntaxversion = function onsyntaxversion(tokens) {\n  tokens.shift();\n  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0]);\n  tokens.shift();\n  var version = tokens.shift();\n\n  switch (version) {\n    case '\"proto2\"':\n      version = 2;\n      break;\n\n    case '\"proto3\"':\n      version = 3;\n      break;\n\n    default:\n      throw new Error('Expected protobuf syntax version but found ' + version);\n  }\n\n  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0]);\n  tokens.shift();\n  return version;\n};\n\nvar onenumvalue = function onenumvalue(tokens) {\n  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '));\n  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1]);\n  if (tokens[3] !== ';' && tokens[3] !== '[') throw new Error('Expected ; or [ but found ' + tokens[1]);\n  var name = tokens.shift();\n  tokens.shift();\n  var val = {\n    value: null,\n    options: {}\n  };\n  val.value = Number(tokens.shift());\n\n  if (tokens[0] === '[') {\n    val.options = onfieldoptions(tokens);\n  }\n\n  tokens.shift(); // expecting the semicolon here\n\n  return {\n    name: name,\n    val: val\n  };\n};\n\nvar onenum = function onenum(tokens) {\n  tokens.shift();\n  var options = {};\n  var e = {\n    name: tokens.shift(),\n    values: {},\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return e;\n    }\n\n    if (tokens[0] === 'option') {\n      options = onoption(tokens);\n      e.options[options.name] = options.value;\n      continue;\n    }\n\n    var val = onenumvalue(tokens);\n    e.values[val.name] = val.val;\n  }\n\n  throw new Error('No closing tag for enum');\n};\n\nvar onoption = function onoption(tokens) {\n  var name = null;\n  var value = null;\n\n  var parse = function parse(value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  while (tokens.length) {\n    if (tokens[0] === ';') {\n      tokens.shift();\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        tokens.shift();\n        var hasBracket = tokens[0] === '(';\n        if (hasBracket) tokens.shift();\n        name = tokens.shift();\n\n        if (hasBracket) {\n          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n          tokens.shift();\n        }\n\n        if (tokens[0][0] === '.') {\n          name += tokens.shift();\n        }\n\n        break;\n\n      case '=':\n        tokens.shift();\n        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0]);\n        value = parse(tokens.shift());\n\n        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {\n          throw new Error('Unexpected value for option optimize_for: ' + value);\n        } else if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        break;\n\n      default:\n        throw new Error('Unexpected token in option: ' + tokens[0]);\n    }\n  }\n};\n\nvar onoptionMap = function onoptionMap(tokens) {\n  var parse = function parse(value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value.replace(/^\"+|\"+$/gm, '');\n  };\n\n  var map = {};\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift();\n      return map;\n    }\n\n    var hasBracket = tokens[0] === '(';\n    if (hasBracket) tokens.shift();\n    var key = tokens.shift();\n\n    if (hasBracket) {\n      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n      tokens.shift();\n    }\n\n    var value = null;\n\n    switch (tokens[0]) {\n      case ':':\n        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key);\n        tokens.shift();\n        value = parse(tokens.shift());\n\n        if (value === '{') {\n          // option foo = {bar: baz}\n          value = onoptionMap(tokens);\n        }\n\n        map[key] = value;\n\n        if (tokens[0] === ';') {\n          tokens.shift();\n        }\n\n        break;\n\n      case '{':\n        tokens.shift();\n        value = onoptionMap(tokens);\n        if (map[key] === undefined) map[key] = [];\n        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key);\n        map[key].push(value);\n        break;\n\n      default:\n        throw new Error('Unexpected token in option map: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for option map');\n};\n\nvar onimport = function onimport(tokens) {\n  tokens.shift();\n  var file = tokens.shift().replace(/^\"+|\"+$/gm, '');\n  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected \";\"');\n  tokens.shift();\n  return file;\n};\n\nvar onservice = function onservice(tokens) {\n  tokens.shift();\n  var service = {\n    name: tokens.shift(),\n    methods: [],\n    options: {}\n  };\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return service;\n    }\n\n    switch (tokens[0]) {\n      case 'option':\n        var opt = onoption(tokens);\n        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n        service.options[opt.name] = opt.value;\n        break;\n\n      case 'rpc':\n        service.methods.push(onrpc(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token in service: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for service');\n};\n\nvar onrpc = function onrpc(tokens) {\n  tokens.shift();\n  var rpc = {\n    name: tokens.shift(),\n    input_type: null,\n    output_type: null,\n    client_streaming: false,\n    server_streaming: false,\n    options: {}\n  };\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.client_streaming = true;\n  }\n\n  rpc.input_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0]);\n  tokens.shift();\n  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === 'stream') {\n    tokens.shift();\n    rpc.server_streaming = true;\n  }\n\n  rpc.output_type = tokens.shift();\n  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0]);\n  tokens.shift();\n\n  if (tokens[0] === ';') {\n    tokens.shift();\n    return rpc;\n  }\n\n  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0]);\n  tokens.shift();\n\n  while (tokens.length) {\n    if (tokens[0] === '}') {\n      tokens.shift(); // there goes optional semicolon after the enclosing \"}\"\n\n      if (tokens[0] === ';') tokens.shift();\n      return rpc;\n    }\n\n    if (tokens[0] === 'option') {\n      var opt = onoption(tokens);\n      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name);\n      rpc.options[opt.name] = opt.value;\n    } else {\n      throw new Error('Unexpected token in rpc options: ' + tokens[0]);\n    }\n  }\n\n  throw new Error('No closing tag for rpc');\n};\n\nvar parse = function parse(buf) {\n  var tokens = tokenize(buf.toString()); // check for isolated strings in tokens by looking for opening quote\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (/^(\"|')([^'\"]*)$/.test(tokens[i])) {\n      var j;\n\n      if (tokens[i].length === 1) {\n        j = i + 1;\n      } else {\n        j = i;\n      } // look ahead for the closing quote and collapse all\n      // in-between tokens into a single token\n\n\n      for (j; j < tokens.length; j++) {\n        if (/^[^'\"\\\\]*(?:\\\\.[^'\"\\\\]*)*(\"|')$/.test(tokens[j])) {\n          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1));\n          break;\n        }\n      }\n    }\n  }\n\n  var schema = {\n    syntax: 3,\n    package: null,\n    imports: [],\n    enums: [],\n    messages: [],\n    options: {},\n    extends: []\n  };\n  var firstline = true;\n\n  while (tokens.length) {\n    switch (tokens[0]) {\n      case 'package':\n        schema.package = onpackagename(tokens);\n        break;\n\n      case 'syntax':\n        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file');\n        schema.syntax = onsyntaxversion(tokens);\n        break;\n\n      case 'message':\n        schema.messages.push(onmessage(tokens));\n        break;\n\n      case 'enum':\n        schema.enums.push(onenum(tokens));\n        break;\n\n      case 'option':\n        var opt = onoption(tokens);\n        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name);\n        schema.options[opt.name] = opt.value;\n        break;\n\n      case 'import':\n        schema.imports.push(onimport(tokens));\n        break;\n\n      case 'extend':\n        schema.extends.push(onextend(tokens));\n        break;\n\n      case 'service':\n        if (!schema.services) schema.services = [];\n        schema.services.push(onservice(tokens));\n        break;\n\n      default:\n        throw new Error('Unexpected token: ' + tokens[0]);\n    }\n\n    firstline = false;\n  } // now iterate over messages and propagate extends\n\n\n  schema.extends.forEach(function (ext) {\n    schema.messages.forEach(function (msg) {\n      if (msg.name === ext.name) {\n        ext.message.fields.forEach(function (field) {\n          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {\n            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number');\n          }\n\n          msg.fields.push(field);\n        });\n      }\n    });\n  });\n  schema.messages.forEach(function (msg) {\n    msg.fields.forEach(function (field) {\n      var fieldSplit;\n      var messageName;\n      var nestedEnumName;\n      var message;\n\n      function enumNameIsFieldType(en) {\n        return en.name === field.type;\n      }\n\n      function enumNameIsNestedEnumName(en) {\n        return en.name === nestedEnumName;\n      }\n\n      if (field.options && field.options.packed === 'true') {\n        if (PACKABLE_TYPES.indexOf(field.type) === -1) {\n          // let's see if it's an enum\n          if (field.type.indexOf('.') === -1) {\n            if (msg.enums && msg.enums.some(enumNameIsFieldType)) {\n              return;\n            }\n          } else {\n            fieldSplit = field.type.split('.');\n\n            if (fieldSplit.length > 2) {\n              throw new Error('what is this?');\n            }\n\n            messageName = fieldSplit[0];\n            nestedEnumName = fieldSplit[1];\n            schema.messages.some(function (msg) {\n              if (msg.name === messageName) {\n                message = msg;\n                return msg;\n              }\n            });\n\n            if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {\n              return;\n            }\n          }\n\n          throw new Error('Fields of type ' + field.type + ' cannot be declared [packed=true]. ' + 'Only repeated fields of primitive numeric types (types which use ' + 'the varint, 32-bit, or 64-bit wire types) can be declared \"packed\". ' + 'See https://developers.google.com/protocol-buffers/docs/encoding#optional');\n        }\n      }\n    });\n  });\n  return schema;\n};\n\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}
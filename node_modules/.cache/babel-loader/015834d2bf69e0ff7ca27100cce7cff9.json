{"ast":null,"code":"'use strict';\n\nvar nodeify = require('../nodeify');\n\nvar webcrypto = require('../webcrypto');\n\nvar randomBytes = require('../random-bytes');\n\nexports.utils = require('./rsa-utils');\n\nexports.generateKey = function (bits, callback) {\n  nodeify(webcrypto.subtle.generateKey({\n    name: 'RSASSA-PKCS1-v1_5',\n    modulusLength: bits,\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign', 'verify']).then(exportKey).then(function (keys) {\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  }), callback);\n}; // Takes a jwk key\n\n\nexports.unmarshalPrivateKey = function (key, callback) {\n  var privateKey = webcrypto.subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign']);\n  nodeify(Promise.all([privateKey, derivePublicFromPrivate(key)]).then(function (keys) {\n    return exportKey({\n      privateKey: keys[0],\n      publicKey: keys[1]\n    });\n  }).then(function (keys) {\n    return {\n      privateKey: keys[0],\n      publicKey: keys[1]\n    };\n  }), callback);\n};\n\nexports.getRandomValues = randomBytes;\n\nexports.hashAndSign = function (key, msg, callback) {\n  nodeify(webcrypto.subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['sign']).then(function (privateKey) {\n    return webcrypto.subtle.sign({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, privateKey, Uint8Array.from(msg));\n  }).then(function (sig) {\n    return Buffer.from(sig);\n  }), callback);\n};\n\nexports.hashAndVerify = function (key, sig, msg, callback) {\n  nodeify(webcrypto.subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['verify']).then(function (publicKey) {\n    return webcrypto.subtle.verify({\n      name: 'RSASSA-PKCS1-v1_5'\n    }, publicKey, sig, msg);\n  }), callback);\n};\n\nfunction exportKey(pair) {\n  return Promise.all([webcrypto.subtle.exportKey('jwk', pair.privateKey), webcrypto.subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nfunction derivePublicFromPrivate(jwKey) {\n  return webcrypto.subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg buffer to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our buffer a binary string\n  - Convert resulting nodeForge buffer to buffer: it returns a binary string, turn that into a uint8array(buffer)\n\n*/\n\n\nvar _require = require('./jwk2pem'),\n    jwk2pub = _require.jwk2pub,\n    jwk2priv = _require.jwk2priv;\n\nfunction convertKey(key, pub, msg, handle) {\n  var fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  var fmsg = Buffer.from(msg).toString('binary');\n  var fomsg = handle(fmsg, fkey);\n  return Buffer.from(fomsg, 'binary');\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, function (msg, key) {\n    return key.encrypt(msg);\n  });\n};\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, function (msg, key) {\n    return key.decrypt(msg);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}
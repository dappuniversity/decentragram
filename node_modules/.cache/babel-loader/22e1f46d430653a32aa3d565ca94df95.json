{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\New-Insta\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _require = require('./utils'),\n    ensureMultiaddr = _require.ensureMultiaddr;\n\nvar uniqBy = require('unique-by'); // Because JavaScript doesn't let you overload the compare in Set()..\n\n\nvar MultiaddrSet =\n/*#__PURE__*/\nfunction () {\n  function MultiaddrSet(multiaddrs) {\n    _classCallCheck(this, MultiaddrSet);\n\n    this._multiaddrs = multiaddrs || [];\n    this._observedMultiaddrs = [];\n  }\n\n  _createClass(MultiaddrSet, [{\n    key: \"add\",\n    value: function add(ma) {\n      ma = ensureMultiaddr(ma);\n\n      if (!this.has(ma)) {\n        this._multiaddrs.push(ma);\n      }\n    } // addSafe - prevent multiaddr explosionâ„¢\n    // Multiaddr explosion is when you dial to a bunch of nodes and every node\n    // gives you a different observed address and you start storing them all to\n    // share with other peers. This seems like a good idea until you realize that\n    // most of those addresses are unique to the subnet that peer is in and so,\n    // they are completely worthless for all the other peers. This method is\n    // exclusively used by identify.\n\n  }, {\n    key: \"addSafe\",\n    value: function addSafe(ma) {\n      var _this = this;\n\n      ma = ensureMultiaddr(ma);\n\n      var check = this._observedMultiaddrs.some(function (m, i) {\n        if (m.equals(ma)) {\n          _this.add(ma);\n\n          _this._observedMultiaddrs.splice(i, 1);\n\n          return true;\n        }\n      });\n\n      if (!check) {\n        this._observedMultiaddrs.push(ma);\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this._multiaddrs.slice();\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      return this._multiaddrs.forEach(fn);\n    }\n  }, {\n    key: \"filterBy\",\n    value: function filterBy(maFmt) {\n      if (typeof maFmt !== 'object' || typeof maFmt.matches !== 'function' || typeof maFmt.partialMatch !== 'function' || typeof maFmt.toString !== 'function') return [];\n      return this._multiaddrs.filter(function (ma) {\n        return maFmt.matches(ma);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(ma) {\n      ma = ensureMultiaddr(ma);\n      return this._multiaddrs.some(function (m) {\n        return m.equals(ma);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(ma) {\n      var _this2 = this;\n\n      ma = ensureMultiaddr(ma);\n\n      this._multiaddrs.some(function (m, i) {\n        if (m.equals(ma)) {\n          _this2._multiaddrs.splice(i, 1);\n\n          return true;\n        }\n      });\n    } // replaces selected existing multiaddrs with new ones\n\n  }, {\n    key: \"replace\",\n    value: function replace(existing, fresh) {\n      var _this3 = this;\n\n      if (!Array.isArray(existing)) {\n        existing = [existing];\n      }\n\n      if (!Array.isArray(fresh)) {\n        fresh = [fresh];\n      }\n\n      existing.forEach(function (m) {\n        return _this3.delete(m);\n      });\n      fresh.forEach(function (m) {\n        return _this3.add(m);\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._multiaddrs = [];\n    } // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n    // different\n    // TODO this is not an ideal solution, probably this code should just be\n    // in libp2p-tcp\n\n  }, {\n    key: \"distinct\",\n    value: function distinct() {\n      return uniqBy(this._multiaddrs, function (ma) {\n        return [ma.toOptions().port, ma.toOptions().transport].join();\n      });\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._multiaddrs.length;\n    }\n  }]);\n\n  return MultiaddrSet;\n}();\n\nmodule.exports = MultiaddrSet;","map":null,"metadata":{},"sourceType":"script"}
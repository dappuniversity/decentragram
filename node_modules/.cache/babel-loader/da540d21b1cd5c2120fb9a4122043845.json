{"ast":null,"code":"'use strict';\n\nvar _require = require('readable-stream'),\n    Duplex = _require.Duplex;\n\nvar eachSeries = require('async/eachSeries');\n\nvar isStream = require('is-stream');\n\nvar once = require('once');\n\nvar prepareFile = require('./prepare-file');\n\nvar Multipart = require('./multipart');\n\nfunction headers(file, i) {\n  var filename = file.path ? encodeURIComponent(file.path) : '';\n  var header = {\n    'Content-Disposition': \"form-data; name=\\\"data\".concat(i, \"\\\"; filename=\\\"\").concat(filename, \"\\\"\")\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = function (send, path) {\n  return function (options) {\n    var request;\n    var ended = false;\n    var writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    var multipart = new Multipart();\n    var retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = function (n) {};\n\n    retStream._write = function (file, enc, _next) {\n      var next = once(_next);\n\n      try {\n        var files = prepareFile(file, options).map(function (file, i) {\n          return Object.assign({\n            headers: headers(file, i)\n          }, file);\n        });\n        writing = true;\n        eachSeries(files, function (file, cb) {\n          return multipart.write(file, enc, cb);\n        }, function (err) {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', function () {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    var qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true';\n    }\n\n    var args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', function (err) {\n      retStream.emit('error', err);\n    });\n    request = send(args, function (err, response) {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', function (err) {\n        return retStream.emit('error', err);\n      });\n\n      if (options.converter) {\n        response.on('data', function (d) {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        var Converter = options.converter;\n        var convertedResponse = new Converter();\n        convertedResponse.once('end', function () {\n          return retStream.push(null);\n        });\n        convertedResponse.on('data', function (d) {\n          return retStream.push(d);\n        });\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', function (d) {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', function () {\n          return retStream.push(null);\n        });\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', function () {\n      return multipart.emit('drain');\n    });\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}
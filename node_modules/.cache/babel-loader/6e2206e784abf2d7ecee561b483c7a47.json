{"ast":null,"code":"'use strict';\n\nvar base58 = require('bs58');\n\nvar multihash = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar Multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar CID = require('cids');\n\nvar urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/;\nvar pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/;\nvar defaultProtocolMatch = 1;\nvar defaultHashMath = 4;\nvar fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/;\nvar fqdnHashMatch = 1;\nvar fqdnProtocolMatch = 2;\n\nfunction isMultihash(hash) {\n  var formatted = convertToString(hash);\n\n  try {\n    var buffer = Buffer.from(base58.decode(formatted));\n    multihash.decode(buffer);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultibase(hash) {\n  try {\n    return multibase.isEncoded(hash);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isCID(hash) {\n  try {\n    new CID(hash); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input);\n}\n\nfunction isIpfs(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  var formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  var match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  var hash = match[hashMatch];\n\n  if (hash && pattern === fqdnPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n\nfunction isIpns(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 ? arguments[3] : undefined;\n  var formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  var match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  if (hashMatch && pattern === fqdnPattern) {\n    var hash = match[hashMatch]; // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n\n    hash = hash.toLowerCase();\n    return isCID(hash);\n  }\n\n  return true;\n}\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n\nfunction convertToString(input) {\n  if (Buffer.isBuffer(input)) {\n    return base58.encode(input);\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n\nvar ipfsSubdomain = function ipfsSubdomain(url) {\n  return isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n};\n\nvar ipnsSubdomain = function ipnsSubdomain(url) {\n  return isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n};\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: function base32cid(cid) {\n    return isMultibase(cid) === 'base32' && isCID(cid);\n  },\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: function subdomain(url) {\n    return ipfsSubdomain(url) || ipnsSubdomain(url);\n  },\n  subdomainPattern: fqdnPattern,\n  ipfsUrl: function ipfsUrl(url) {\n    return isIpfs(url, urlPattern);\n  },\n  ipnsUrl: function ipnsUrl(url) {\n    return isIpns(url, urlPattern);\n  },\n  url: function url(_url) {\n    return isIpfs(_url, urlPattern) || isIpns(_url, urlPattern);\n  },\n  urlPattern: urlPattern,\n  ipfsPath: function ipfsPath(path) {\n    return isIpfs(path, pathPattern);\n  },\n  ipnsPath: function ipnsPath(path) {\n    return isIpns(path, pathPattern);\n  },\n  path: function path(_path) {\n    return isIpfs(_path, pathPattern) || isIpns(_path, pathPattern);\n  },\n  pathPattern: pathPattern,\n  urlOrPath: function urlOrPath(x) {\n    return isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern);\n  },\n  cidPath: function cidPath(path) {\n    return isString(path) && !isCID(path) && isIpfs(\"/ipfs/\".concat(path), pathPattern);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * Cipher base API.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nmodule.exports = forge.cipher = forge.cipher || {}; // registered algorithms\n\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n/**\n * Creates a cipher object that can be used to encrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\n\nforge.cipher.createCipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n/**\n * Creates a decipher object that can be used to decrypt data using the given\n * algorithm and key. The algorithm may be provided as a string value for a\n * previously registered algorithm or it may be given as a cipher algorithm\n * API object.\n *\n * @param algorithm the algorithm to use, either a string or an algorithm API\n *          object.\n * @param key the key to use, as a binary-encoded string of bytes or a\n *          byte buffer.\n *\n * @return the cipher.\n */\n\n\nforge.cipher.createDecipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n/**\n * Registers an algorithm by name. If the name was already registered, the\n * algorithm API object will be overwritten.\n *\n * @param name the name of the algorithm.\n * @param algorithm the algorithm API object.\n */\n\n\nforge.cipher.registerAlgorithm = function (name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n/**\n * Gets a registered algorithm by name.\n *\n * @param name the name of the algorithm.\n *\n * @return the algorithm, if found, null if not.\n */\n\n\nforge.cipher.getAlgorithm = function (name) {\n  name = name.toUpperCase();\n\n  if (name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n\n  return null;\n};\n\nvar BlockCipher = forge.cipher.BlockCipher = function (options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n/**\n * Starts or restarts the encryption or decryption process, whichever\n * was previously configured.\n *\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\n * 32-bit integers, then it must be 4 integers long.\n *\n * Note: an IV is not required or used in ECB mode.\n *\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\n * by NIST SP-800-38D but another length may be given.\n *\n * @param options the options to use:\n *          iv the initialization vector to use as a binary-encoded string of\n *            bytes, null to reuse the last ciphered block from a previous\n *            update() (this \"residue\" method is for legacy support only).\n *          additionalData additional authentication data as a binary-encoded\n *            string of bytes, for 'GCM' mode, (default: none).\n *          tagLength desired length of authentication tag, in bits, for\n *            'GCM' mode (0-128, default: 128).\n *          tag the authentication tag to check if decrypting, as a\n *             binary-encoded string of bytes.\n *          output the output the buffer to write to, null to create one.\n */\n\n\nBlockCipher.prototype.start = function (options) {\n  options = options || {};\n  var opts = {};\n\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n/**\n * Updates the next block according to the cipher mode.\n *\n * @param input the buffer to read from.\n */\n\n\nBlockCipher.prototype.update = function (input) {\n  if (input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  } // do cipher operation until it needs more input and not finished\n\n\n  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {} // free consumed memory from input buffer\n\n\n  this._input.compact();\n};\n/**\n * Finishes encrypting or decrypting.\n *\n * @param pad a padding function to use in CBC mode, null for default,\n *          signature(blockSize, buffer, decrypt).\n *\n * @return true if successful, false on error.\n */\n\n\nBlockCipher.prototype.finish = function (pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function (input) {\n      return pad(this.blockSize, input, false);\n    };\n\n    this.mode.unpad = function (output) {\n      return pad(this.blockSize, output, true);\n    };\n  } // build options for padding and afterFinish functions\n\n\n  var options = {};\n  options.decrypt = this._decrypt; // get # of bytes that won't fill a block\n\n  options.overflow = this._input.length() % this.blockSize;\n\n  if (!this._decrypt && this.mode.pad) {\n    if (!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  } // do final update\n\n\n  this._finish = true;\n  this.update();\n\n  if (this._decrypt && this.mode.unpad) {\n    if (!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n\n  if (this.mode.afterFinish) {\n    if (!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}
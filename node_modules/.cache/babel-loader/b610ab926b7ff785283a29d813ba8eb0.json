{"ast":null,"code":"var util = require('util');\n\nvar bl = require('bl');\n\nvar headers = require('./headers');\n\nvar Writable = require('readable-stream').Writable;\n\nvar PassThrough = require('readable-stream').PassThrough;\n\nvar noop = function noop() {};\n\nvar overflow = function overflow(size) {\n  size &= 511;\n  return size && 512 - size;\n};\n\nvar emptyStream = function emptyStream(self, offset) {\n  var s = new Source(self, offset);\n  s.end();\n  return s;\n};\n\nvar mixinPax = function mixinPax(header, pax) {\n  if (pax.path) header.name = pax.path;\n  if (pax.linkpath) header.linkname = pax.linkpath;\n  if (pax.size) header.size = parseInt(pax.size, 10);\n  header.pax = pax;\n  return header;\n};\n\nvar Source = function Source(self, offset) {\n  this._parent = self;\n  this.offset = offset;\n  PassThrough.call(this, {\n    autoDestroy: false\n  });\n};\n\nutil.inherits(Source, PassThrough);\n\nSource.prototype.destroy = function (err) {\n  this._parent.destroy(err);\n};\n\nvar Extract = function Extract(opts) {\n  if (!(this instanceof Extract)) return new Extract(opts);\n  Writable.call(this, opts);\n  opts = opts || {};\n  this._offset = 0;\n  this._buffer = bl();\n  this._missing = 0;\n  this._partial = false;\n  this._onparse = noop;\n  this._header = null;\n  this._stream = null;\n  this._overflow = null;\n  this._cb = null;\n  this._locked = false;\n  this._destroyed = false;\n  this._pax = null;\n  this._paxGlobal = null;\n  this._gnuLongPath = null;\n  this._gnuLongLinkPath = null;\n  var self = this;\n  var b = self._buffer;\n\n  var oncontinue = function oncontinue() {\n    self._continue();\n  };\n\n  var onunlock = function onunlock(err) {\n    self._locked = false;\n    if (err) return self.destroy(err);\n    if (!self._stream) oncontinue();\n  };\n\n  var onstreamend = function onstreamend() {\n    self._stream = null;\n    var drain = overflow(self._header.size);\n    if (drain) self._parse(drain, ondrain);else self._parse(512, onheader);\n    if (!self._locked) oncontinue();\n  };\n\n  var ondrain = function ondrain() {\n    self._buffer.consume(overflow(self._header.size));\n\n    self._parse(512, onheader);\n\n    oncontinue();\n  };\n\n  var onpaxglobalheader = function onpaxglobalheader() {\n    var size = self._header.size;\n    self._paxGlobal = headers.decodePax(b.slice(0, size));\n    b.consume(size);\n    onstreamend();\n  };\n\n  var onpaxheader = function onpaxheader() {\n    var size = self._header.size;\n    self._pax = headers.decodePax(b.slice(0, size));\n    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var ongnulongpath = function ongnulongpath() {\n    var size = self._header.size;\n    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var ongnulonglinkpath = function ongnulonglinkpath() {\n    var size = self._header.size;\n    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var onheader = function onheader() {\n    var offset = self._offset;\n    var header;\n\n    try {\n      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding);\n    } catch (err) {\n      self.emit('error', err);\n    }\n\n    b.consume(512);\n\n    if (!header) {\n      self._parse(512, onheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'gnu-long-path') {\n      self._parse(header.size, ongnulongpath);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'gnu-long-link-path') {\n      self._parse(header.size, ongnulonglinkpath);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (self._gnuLongPath) {\n      header.name = self._gnuLongPath;\n      self._gnuLongPath = null;\n    }\n\n    if (self._gnuLongLinkPath) {\n      header.linkname = self._gnuLongLinkPath;\n      self._gnuLongLinkPath = null;\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax);\n      self._pax = null;\n    }\n\n    self._locked = true;\n\n    if (!header.size || header.type === 'directory') {\n      self._parse(512, onheader);\n\n      self.emit('entry', header, emptyStream(self, offset), onunlock);\n      return;\n    }\n\n    self._stream = new Source(self, offset);\n    self.emit('entry', header, self._stream, onunlock);\n\n    self._parse(header.size, onstreamend);\n\n    oncontinue();\n  };\n\n  this._onheader = onheader;\n\n  this._parse(512, onheader);\n};\n\nutil.inherits(Extract, Writable);\n\nExtract.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  if (err) this.emit('error', err);\n  this.emit('close');\n  if (this._stream) this._stream.emit('close');\n};\n\nExtract.prototype._parse = function (size, onparse) {\n  if (this._destroyed) return;\n  this._offset += size;\n  this._missing = size;\n  if (onparse === this._onheader) this._partial = false;\n  this._onparse = onparse;\n};\n\nExtract.prototype._continue = function () {\n  if (this._destroyed) return;\n  var cb = this._cb;\n  this._cb = noop;\n  if (this._overflow) this._write(this._overflow, undefined, cb);else cb();\n};\n\nExtract.prototype._write = function (data, enc, cb) {\n  if (this._destroyed) return;\n  var s = this._stream;\n  var b = this._buffer;\n  var missing = this._missing;\n  if (data.length) this._partial = true; // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length;\n    this._overflow = null;\n    if (s) return s.write(data, cb);\n    b.append(data);\n    return cb();\n  } // end-of-chunk. the parser should call cb.\n\n\n  this._cb = cb;\n  this._missing = 0;\n  var overflow = null;\n\n  if (data.length > missing) {\n    overflow = data.slice(missing);\n    data = data.slice(0, missing);\n  }\n\n  if (s) s.end(data);else b.append(data);\n  this._overflow = overflow;\n\n  this._onparse();\n};\n\nExtract.prototype._final = function (cb) {\n  if (this._partial) return this.destroy(new Error('Unexpected end of data'));\n  cb();\n};\n\nmodule.exports = Extract;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\30698\\\\DecentraBook\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar mh = require('multihashes');\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar assert = require('assert');\n\nvar waterfall = require('async/waterfall');\n\nvar withIs = require('class-is');\n\nvar PeerId =\n/*#__PURE__*/\nfunction () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"marshalPubKey\",\n    // Return the protobuf version of the public key, matching go ipfs formatting\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return cryptoKeys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return cryptoKeys.marshalPrivateKey(this.privKey);\n      }\n    }\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      var pid = this.toB58String(); // All sha256 nodes start with Qm\n      // We can skip the Qm to make the peer.ID more useful\n\n      if (pid.startsWith('Qm')) {\n        pid = pid.slice(2);\n      }\n\n      var maxRunes = 6;\n\n      if (pid.length < maxRunes) {\n        maxRunes = pid.length;\n      }\n\n      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return mh.toHexString(this.id);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      if (Buffer.isBuffer(id)) {\n        return this.id.equals(id);\n      } else if (id.id) {\n        return this.id.equals(id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(callback) {\n      // TODO Needs better checking\n      if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n        callback();\n      } else {\n        callback(new Error('Keys not match'));\n      }\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n\n      var decoded = mh.decode(this.id);\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n        return this._pubKey;\n      }\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    }\n  }]);\n\n  return PeerId;\n}();\n\nvar PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nvar computeDigest = function computeDigest(pubKey, cb) {\n  if (pubKey.bytes.length <= 42) {\n    var digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash(function (err, digest) {\n      cb(err, digest);\n    });\n  }\n};\n\nvar computePeerId = function computePeerId(privKey, pubKey, cb) {\n  computeDigest(pubKey, function (err, digest) {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n}; // generation\n\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, function (err, privKey) {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var pubKey;\n\n  try {\n    var buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  computePeerId(null, pubKey, callback);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, function (err, privKey) {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var id;\n  var rawPrivKey;\n  var rawPubKey;\n  var pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n\n  waterfall([function (cb) {\n    return cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb);\n  }, function (priv, cb) {\n    computeDigest(priv.public, function (err, digest) {\n      cb(err, digest, priv);\n    });\n  }, function (privDigest, priv, cb) {\n    if (pub) {\n      computeDigest(pub, function (err, pubDigest) {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], function (err, privDigest, priv, pubDigest) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}
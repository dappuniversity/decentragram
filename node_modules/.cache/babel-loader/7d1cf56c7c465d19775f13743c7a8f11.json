{"ast":null,"code":"'use strict';\n\nvar Qs = require('qs');\n\nvar qsDefaultEncoder = require('qs/lib/utils').encode;\n\nvar isNode = require('detect-node');\n\nvar ndjson = require('ndjson');\n\nvar pump = require('pump');\n\nvar once = require('once');\n\nvar _require = require('iso-stream-http'),\n    getRequest = _require.getRequest;\n\nvar streamToValue = require('./stream-to-value');\n\nvar streamToJsonValue = require('./stream-to-json-value');\n\nvar log = require('debug')('ipfs-http-client:request'); // -- Internal\n\n\nfunction hasJSONHeaders(res) {\n  return res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n}\n\nfunction parseError(res, cb) {\n  var error = new Error(\"Server responded with \".concat(res.statusCode));\n  error.statusCode = res.statusCode;\n\n  if (!hasJSONHeaders(res)) {\n    return streamToValue(res, function (err, data) {\n      // eslint-disable-line handle-callback-err\n      // the `err` here refers to errors in stream processing, which\n      // we ignore here, since we already have a valid `error` response\n      // from the server above that we have to report to the caller.\n      if (data && data.length) {\n        error.message = data.toString();\n      }\n\n      cb(error);\n    });\n  }\n\n  streamToJsonValue(res, function (err, payload) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n\n    cb(error);\n  });\n}\n\nfunction onRes(buffer, cb) {\n  return function (res) {\n    var stream = Boolean(res.headers['x-stream-output']);\n    var chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    var isJson = hasJSONHeaders(res);\n\n    if (res.req) {\n      log(res.req.method, \"\".concat(res.req.getHeaders().host).concat(res.req.path), res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    } // Return the response stream directly\n\n\n    if (stream && !buffer) {\n      return cb(null, res);\n    } // Return a stream of JSON objects\n\n\n    if (chunkedObjects && isJson) {\n      var outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', function () {\n        var err = res.trailers['x-stream-error'];\n\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    } // Return a JSON object\n\n\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    } // Return a value\n\n\n    return streamToValue(res, cb);\n  };\n}\n\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r; // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n\n    delete options.qs.r;\n  }\n\n  options.qs['stream-channels'] = true;\n\n  if (options.stream) {\n    options.buffer = false;\n  } // this option is only used internally, not passed to daemon\n\n\n  delete options.qs.followSymlinks;\n  var method = 'POST';\n  var headers = Object.assign({}, config.headers);\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n\n    headers['Content-Type'] = \"multipart/form-data; boundary=\".concat(options.multipartBoundary);\n  }\n\n  var qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: function encoder(data) {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        var uriEncoded = '';\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var byte = _step.value;\n\n            // https://tools.ietf.org/html/rfc3986#page-14\n            // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n            if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n              uriEncoded += String.fromCharCode(byte);\n            } else {\n              var hex = byte.toString(16); // String.prototype.padStart() not widely supported yet\n\n              var padded = hex.length === 1 ? \"0\".concat(hex) : hex;\n              uriEncoded += \"%\".concat(padded);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return uriEncoded;\n      }\n\n      return qsDefaultEncoder(data);\n    }\n  });\n  var reqOptions = {\n    hostname: config.host,\n    path: \"\".concat(config['api-path']).concat(options.path, \"?\").concat(qs),\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: \"\".concat(config.protocol, \":\")\n  };\n  var req = getRequest(reqOptions, onRes(options.buffer, callback));\n  req.on('error', function (err) {\n    callback(err);\n  });\n\n  if (!options.stream) {\n    req.end();\n  }\n\n  return req;\n} //\n// -- Module Interface\n\n\nexports = module.exports = function (config) {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  var send = function send(options, callback) {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n\n    return requestAPI(config, options, callback);\n  }; // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n\n\n  send.andTransform = function (options, transform, callback) {\n    return send(options, function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      transform(res, callback);\n    });\n  };\n\n  return send;\n};","map":null,"metadata":{},"sourceType":"script"}
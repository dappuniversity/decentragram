{"ast":null,"code":"'use strict';\n\nvar whilst = require('async/whilst');\n\nvar hmac = require('../hmac');\n\nvar cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  } // Generates a set of keys for each party by stretching the shared key.\n  // (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\n};\n\nmodule.exports = function (cipherType, hash, secret, callback) {\n  var cipher = cipherMap[cipherType];\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'));\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'));\n  }\n\n  var cipherKeySize = cipher.keySize;\n  var ivSize = cipher.ivSize;\n  var hmacKeySize = 20;\n  var seed = Buffer.from('key expansion');\n  var resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  hmac.create(hash, secret, function (err, m) {\n    if (err) {\n      return callback(err);\n    }\n\n    m.digest(seed, function (err, a) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = [];\n      var j = 0;\n      whilst(function () {\n        return j < resultLength;\n      }, stretch, finish);\n\n      function stretch(cb) {\n        m.digest(Buffer.concat([a, seed]), function (err, b) {\n          if (err) {\n            return cb(err);\n          }\n\n          var todo = b.length;\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n\n          result.push(b);\n          j += todo;\n          m.digest(a, function (err, _a) {\n            if (err) {\n              return cb(err);\n            }\n\n            a = _a;\n            cb();\n          });\n        });\n      }\n\n      function finish(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var half = resultLength / 2;\n        var resultBuffer = Buffer.concat(result);\n        var r1 = resultBuffer.slice(0, half);\n        var r2 = resultBuffer.slice(half, resultLength);\n\n        var createKey = function createKey(res) {\n          return {\n            iv: res.slice(0, ivSize),\n            cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n            macKey: res.slice(ivSize + cipherKeySize)\n          };\n        };\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        });\n      }\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}